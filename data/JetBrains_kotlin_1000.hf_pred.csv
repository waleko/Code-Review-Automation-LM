,code,target,prediction
0,"@@ -0,0 +1 @@
+org.jetbrains.kotlin.idea.inspections.RemoveRedundantBackticksInspection",Please add a test to verify that the quickfix is not offered when an actual keyword is in backticks.,
1,"@@ -0,0 +1 @@
+throw Exception(""not implemented"") //To change body of created methods use File | Settings | File Templates.","`UnsupportedOperationException` would be a better choice
",/
2,"@@ -0,0 +1,10 @@
+// ""Create class object from usage"" ""true""
+// ERROR: Expression 'T' of type '<class-object-for-T>' cannot be invoked as a function
+trait T {
+    class object {
+    }","Can you come up with better use case for quick fix creating class object? This one from the test doesn't seem useful.

Creating class object via intetion could be useful in case of T.foo() call, but in this case foo() function should be created as well (actually, it should be ""create function from usage"" quick fix, not ""create class object from usage"").
",I
3,"@@ -0,0 +1,10 @@
+open class Foo {
+    open fun arguments(arg1: Int, arg2: Long) {
+    }
+}
+
+class Bar : Foo() {
+    override <caret>fun arguments(arg1: Int, arg2: Long) {","I should mention that overridden function is not redundant if it has some other modifiers. For example, sometimes is reasonable to add `final` here, so function itself is not changed, but derived classes are made unable to override it. Also, I think that any annotation here makes the function not redundant. The same for any visibility modifier when you make overridden function more visible then original one. Please consider these cases, fix inspection, and add tests for them.",I
4,"@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        //val expectedType = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element.getFunctionLiteral()]
+        //println(""expected type of the function literal is "" + expectedType)
+        //val expectedType2 = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element]
+        //println(""expected type of the function literal exp is "" + expectedType2)
+
+        if (hasExplicitReturnType(element)) return true
+        if (hasExplicitReceiverType(element)) return true
+        if (hasExplicitParamType(element)) return true
+        return false","A one-liner would be nicer in my opinion:
`return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)`
",I
5,"@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        //val expectedType = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element.getFunctionLiteral()]
+        //println(""expected type of the function literal is "" + expectedType)
+        //val expectedType2 = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element]
+        //println(""expected type of the function literal exp is "" + expectedType2)
+
+        if (hasExplicitReturnType(element)) return true
+        if (hasExplicitReceiverType(element)) return true
+        if (hasExplicitParamType(element)) return true
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()?.getText() ?: parameter.getText() ?: """"","Are all three sub-expressions of this elvis expression tested?
",I
6,"@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        //val expectedType = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element.getFunctionLiteral()]
+        //println(""expected type of the function literal is "" + expectedType)
+        //val expectedType2 = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element]
+        //println(""expected type of the function literal exp is "" + expectedType2)
+
+        if (hasExplicitReturnType(element)) return true
+        if (hasExplicitReceiverType(element)) return true
+        if (hasExplicitParamType(element)) return true
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()?.getText() ?: parameter.getText() ?: """"
+                                              }).makeString("", "", ""("", "")"")
+            println(""parameterString is "" + parameterString)","Don't forget to delete all debug output from your changeset
",I
7,"@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        //val expectedType = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element.getFunctionLiteral()]
+        //println(""expected type of the function literal is "" + expectedType)
+        //val expectedType2 = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element]
+        //println(""expected type of the function literal exp is "" + expectedType2)
+
+        if (hasExplicitReturnType(element)) return true
+        if (hasExplicitReceiverType(element)) return true
+        if (hasExplicitParamType(element)) return true
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()?.getText() ?: parameter.getText() ?: """"
+                                              }).makeString("", "", ""("", "")"")
+            println(""parameterString is "" + parameterString)
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getText() == ""("") firstChild!!.delete()","It's not very acceptable to compare text of nodes, especially when you can do the same structurally:
`firstChild.getElementType() == JetTokens.LPAR`
",I
8,"@@ -0,0 +1,101 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        //val expectedType = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element.getFunctionLiteral()]
+        //println(""expected type of the function literal is "" + expectedType)
+        //val expectedType2 = context[BindingContext.EXPECTED_EXPRESSION_TYPE, element]
+        //println(""expected type of the function literal exp is "" + expectedType2)
+
+        if (hasExplicitReturnType(element)) return true
+        if (hasExplicitReceiverType(element)) return true
+        if (hasExplicitParamType(element)) return true
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()?.getText() ?: parameter.getText() ?: """"
+                                              }).makeString("", "", ""("", "")"")
+            println(""parameterString is "" + parameterString)
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getText() == ""("") firstChild!!.delete()
+            val lastChild = currentParamList?.getLastChild()
+            if (lastChild?.getText() == "")"") lastChild!!.delete()","Ditto (`JetTokens.RPAR`)
",I
9,"@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.ESClause
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.structure.ESExpressionVisitor
+
+class InfoCollector(private val observedEffect: ESEffect) : ESExpressionVisitor<MutableContextInfo> {
+    private var isInverted: Boolean = false
+
+    fun collectFromSchema(schema: EffectSchema): MutableContextInfo =
+            schema.clauses.mapNotNull { collectFromClause(it) }.fold(MutableContextInfo.EMPTY, { resultingInfo, clauseInfo -> resultingInfo.and(clauseInfo) })
+
+    private fun collectFromClause(clause: ESClause): MutableContextInfo? {
+        val premise = clause.condition",This name contradicts with real semantics,I
10,"@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.ESClause
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.structure.ESExpressionVisitor
+
+class InfoCollector(private val observedEffect: ESEffect) : ESExpressionVisitor<MutableContextInfo> {
+    private var isInverted: Boolean = false
+
+    fun collectFromSchema(schema: EffectSchema): MutableContextInfo =
+            schema.clauses.mapNotNull { collectFromClause(it) }.fold(MutableContextInfo.EMPTY, { resultingInfo, clauseInfo -> resultingInfo.and(clauseInfo) })
+
+    private fun collectFromClause(clause: ESClause): MutableContextInfo? {
+        val premise = clause.condition
+
+        // Check for non-conditional effects
+        if (premise is ESBooleanConstant && premise.value) {
+            return MutableContextInfo.EMPTY.fire(clause.effect)","As we have discussed, logically this conclusion is erroneous. I strongly recommend to fix this, because you can create true clause condition in some other context thus getting really wrong conclusion",I
11,"@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.ESClause
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.structure.ESExpressionVisitor
+
+class InfoCollector(private val observedEffect: ESEffect) : ESExpressionVisitor<MutableContextInfo> {
+    private var isInverted: Boolean = false
+
+    fun collectFromSchema(schema: EffectSchema): MutableContextInfo =
+            schema.clauses.mapNotNull { collectFromClause(it) }.fold(MutableContextInfo.EMPTY, { resultingInfo, clauseInfo -> resultingInfo.and(clauseInfo) })
+
+    private fun collectFromClause(clause: ESClause): MutableContextInfo? {
+        val premise = clause.condition
+
+        // Check for non-conditional effects
+        if (premise is ESBooleanConstant && premise.value) {
+            return MutableContextInfo.EMPTY.fire(clause.effect)
+        }
+
+        // Check for information from conditional effects
+        return when (observedEffect.isImplies(clause.effect)) {
+            // observed effect implies clause's effect => clause's effect was fired => clause's condition is true
+            true -> clause.condition.accept(this)
+
+            // Observed effect *may* or *doesn't* implies clause's - no useful information
+            null, false -> null
+        }
+    }
+
+    override fun visitIs(isOperator: ESIs): MutableContextInfo = with(isOperator) {
+        if (isNegated != isInverted) MutableContextInfo.EMPTY.notSubtype(left, type) else MutableContextInfo.EMPTY.subtype(left, type)
+    }
+
+    override fun visitEqual(equal: ESEqual): MutableContextInfo = with(equal) {
+        if (isNegated != isInverted) MutableContextInfo.EMPTY.notEqual(left, right) else MutableContextInfo.EMPTY.equal(left, right)
+    }
+
+    override fun visitAnd(and: ESAnd): MutableContextInfo {
+        val leftInfo = and.left.accept(this)
+        val rightInfo = and.right.accept(this)
+
+        return if (isInverted) leftInfo.or(rightInfo) else leftInfo.and(rightInfo)
+    }
+
+    override fun visitNot(not: ESNot): MutableContextInfo = inverted { not.arg.accept(this) }
+
+    override fun visitOr(or: ESOr): MutableContextInfo {
+        val leftInfo = or.left.accept(this)
+        val rightInfo = or.right.accept(this)
+        return if (isInverted) leftInfo.and(rightInfo) else leftInfo.or(rightInfo)
+    }
+
+    override fun visitVariable(esVariable: ESVariable): MutableContextInfo {
+        throw IllegalStateException(""InfoCollector shouldn't visit non-boolean values"")
+    }
+
+    override fun visitBooleanVariable(esBooleanVariable: ESBooleanVariable): MutableContextInfo =
+            if (isInverted)
+                MutableContextInfo.EMPTY.equal(esBooleanVariable, false.lift())
+            else
+                MutableContextInfo.EMPTY.equal(esBooleanVariable, true.lift())
+
+    override fun visitBooleanConstant(esBooleanConstant: ESBooleanConstant): MutableContextInfo {
+        throw IllegalStateException(""InfoCollector shouldn't visit constants"")
+    }
+
+    override fun visitConstant(esConstant: ESConstant): MutableContextInfo {
+        throw IllegalStateException(""InfoCollector shouldn't visit constants"")
+    }
+
+    override fun visitLambda(esLambda: ESLambda): MutableContextInfo {
+        throw IllegalStateException(""InfoCollector shouldn't visit non-boolean values"")
+    }
+
+    private fun <R> inverted(block: () -> R): R {
+        isInverted = isInverted.not()
+        val result = block()
+        isInverted = isInverted.not()",Ugly construction. Are you sure it's really needed?,`
12,"@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.getCallNameExpression
+
+class KotlinRedundantOverrideInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitNamedFunction(function: KtNamedFunction) {
+                    super.visitNamedFunction(function)
+                    if (!function.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return
+                    if (function.containsOtherModifier()) return",I'd inline this function,I
13,"@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.getCallNameExpression
+
+class KotlinRedundantOverrideInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitNamedFunction(function: KtNamedFunction) {
+                    super.visitNamedFunction(function)
+                    if (!function.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return
+                    if (function.containsOtherModifier()) return
+                    if (function.annotationEntries.size != 0) return
+
+                    val bodyExpression = function.bodyExpression
+                    bodyExpression ?: return",This and previous can be written in one line,I
14,"@@ -0,0 +1,103 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.resolve
+
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
+import org.jetbrains.kotlin.descriptors.annotations.Annotations
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.annotations.argumentValue
+
+private val JAVA_DEPRECATED = FqName(Deprecated::class.java.name)","This was corrupted by the refactoring and is now in fact ""kotlin.Deprecated"". Let's use a hard-coded string instead.
",I
15,"@@ -0,0 +1,103 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.visitors
+
+import org.jetbrains.kotlin.effectsystem.factories.boundSchemaFromClauses
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.factories.negated
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.*
+import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
+
+/**
+ * Reduces given effect schema by evaluating constant expressions,
+ * throwing away senseless checks and infeasible clauses, etc.
+ */
+class Reducer : ESExpressionVisitor<ESExpression?> {
+    fun reduceSchema(schema: EffectSchema): EffectSchema =
+            boundSchemaFromClauses(schema.clauses.mapNotNull { reduceClause(it) })
+
+    private fun reduceClause(clause: org.jetbrains.kotlin.effectsystem.structure.ESClause): org.jetbrains.kotlin.effectsystem.structure.ESClause? {",Fully qualified names for some reason,I
16,"@@ -0,0 +1,103 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.visitors
+
+import org.jetbrains.kotlin.effectsystem.factories.boundSchemaFromClauses
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.factories.negated
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.*
+import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
+
+/**
+ * Reduces given effect schema by evaluating constant expressions,
+ * throwing away senseless checks and infeasible clauses, etc.
+ */
+class Reducer : ESExpressionVisitor<ESExpression?> {
+    fun reduceSchema(schema: EffectSchema): EffectSchema =
+            boundSchemaFromClauses(schema.clauses.mapNotNull { reduceClause(it) })
+
+    private fun reduceClause(clause: org.jetbrains.kotlin.effectsystem.structure.ESClause): org.jetbrains.kotlin.effectsystem.structure.ESClause? {
+        val reducedPremise = clause.condition.accept(this) as ESBooleanExpression
+
+        // Filter never executed premises
+        return if (reducedPremise is ESBooleanConstant && !reducedPremise.value) null else ESClause(reducedPremise, clause.effect)",I don't like this `null` because its meaning is unclear. It's better to introduce thing like `ESFalseClause`.,I don't think we need the `isSubtypeOf` here.
17,"@@ -0,0 +1,103 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.visitors
+
+import org.jetbrains.kotlin.effectsystem.factories.boundSchemaFromClauses
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.factories.negated
+import org.jetbrains.kotlin.effectsystem.impls.*
+import org.jetbrains.kotlin.effectsystem.structure.*
+import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
+
+/**
+ * Reduces given effect schema by evaluating constant expressions,
+ * throwing away senseless checks and infeasible clauses, etc.
+ */
+class Reducer : ESExpressionVisitor<ESExpression?> {
+    fun reduceSchema(schema: EffectSchema): EffectSchema =
+            boundSchemaFromClauses(schema.clauses.mapNotNull { reduceClause(it) })
+
+    private fun reduceClause(clause: org.jetbrains.kotlin.effectsystem.structure.ESClause): org.jetbrains.kotlin.effectsystem.structure.ESClause? {
+        val reducedPremise = clause.condition.accept(this) as ESBooleanExpression
+
+        // Filter never executed premises
+        return if (reducedPremise is ESBooleanConstant && !reducedPremise.value) null else ESClause(reducedPremise, clause.effect)
+    }
+
+    override fun visitIs(isOperator: ESIs): ESBooleanExpression {
+        val reducedArg = isOperator.left.accept(this) as ESValue
+
+        val result = when (reducedArg) {
+            is ESConstant -> reducedArg.type.isSubtypeOf(isOperator.functor.type)
+            is ESVariable -> if (reducedArg.type.isSubtypeOf(isOperator.functor.type)) true else null
+            else -> throw IllegalStateException(""Unknown subtype of ESValue: $reducedArg"")
+        }
+
+        // Result is unknown, do not evaluate
+        result ?: return ESIs(reducedArg, isOperator.functor)
+
+        return result.xor(isOperator.functor.isNegated).lift()
+    }
+
+    override fun visitEqual(equal: ESEqual): ESBooleanExpression {
+        val reducedLeft = equal.left.accept(this) as ESValue
+        val reducedRight = equal.right
+
+        if (reducedLeft is ESConstant) return (reducedLeft.value == reducedRight.value).xor(equal.functor.isNegated).lift()","Just to ask: how does it work with different kinds of comparisons (`==`, `===`)?",I don't think we need the `isSubtypeOf` here.
18,"@@ -0,0 +1,104 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import com.intellij.psi.CommonClassNames
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.NoType
+import javax.lang.model.type.TypeKind
+
+class JavacClass<T : TypeElement>(element: T,
+                                  javac: Javac) : JavacClassifier<TypeElement>(element, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())
+
+    override val isAbstract
+        get() = element.isAbstract
+
+    override val isStatic
+        get() = element.isStatic
+
+    override val isFinal
+        get() = element.isFinal
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val typeParameters: List<JavaTypeParameter>
+        get() = element.typeParameters.map { JavacTypeParameter(it, javac) }
+
+    override val fqName
+        get() = FqName(element.qualifiedName.toString())
+
+    override val supertypes
+        get() = element.interfaces.toMutableList().apply {
+            if (element.superclass !is NoType) add(element.superclass)
+
+            val hasObject = !none { it.toString() == CommonClassNames.JAVA_LANG_OBJECT }
+            if (!hasObject && element.toString() != CommonClassNames.JAVA_LANG_OBJECT) {
+                javac.JAVA_LANG_OBJECT?.let { add(it.element.asType()) }",Should we do it if a class already has a super class?,I don't think we need to override these metho
19,"@@ -0,0 +1,104 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import com.intellij.psi.CommonClassNames
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.NoType
+import javax.lang.model.type.TypeKind
+
+class JavacClass<T : TypeElement>(element: T,
+                                  javac: Javac) : JavacClassifier<TypeElement>(element, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())
+
+    override val isAbstract
+        get() = element.isAbstract
+
+    override val isStatic
+        get() = element.isStatic
+
+    override val isFinal
+        get() = element.isFinal
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val typeParameters: List<JavaTypeParameter>
+        get() = element.typeParameters.map { JavacTypeParameter(it, javac) }
+
+    override val fqName
+        get() = FqName(element.qualifiedName.toString())
+
+    override val supertypes
+        get() = element.interfaces.toMutableList().apply {
+            if (element.superclass !is NoType) add(element.superclass)
+
+            val hasObject = !none { it.toString() == CommonClassNames.JAVA_LANG_OBJECT }
+            if (!hasObject && element.toString() != CommonClassNames.JAVA_LANG_OBJECT) {
+                javac.JAVA_LANG_OBJECT?.let { add(it.element.asType()) }
+            }
+        }.map { JavacClassifierType(it, javac) }
+
+    override val innerClasses
+        get() = element.enclosedElements
+                .filter { it.asType().kind == TypeKind.DECLARED }
+                .filterIsInstance(TypeElement::class.java)
+                .map { JavacClass(it, javac) }
+
+    override val outerClass: JavaClass?
+        get() = element.enclosingElement?.let {
+            if (it.asType().kind != TypeKind.DECLARED) null else JavacClass(it as TypeElement, javac)
+        }
+
+    override val isInterface
+        get() = element.kind == ElementKind.INTERFACE
+
+    override val isAnnotationType
+        get() = element.kind == ElementKind.ANNOTATION_TYPE
+
+    override val isEnum
+        get() = element.kind == ElementKind.ENUM
+
+    override val lightClassOriginKind = null
+
+    override val methods: Collection<JavaMethod>
+        get() = element.enclosedElements","Here (and for many other properties) getters are in use. Are you sure this property is read just a few times and we do not spend too much time here? As a possible alternative, you can use `by lazy`.",I don't think we need to override these metho
20,"@@ -0,0 +1,105 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.TemplateBuilder;
+import com.intellij.codeInsight.template.TemplateBuilderFactory;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.plugin.JetBundle;
+
+import java.util.Collection;
+import java.util.LinkedHashSet;
+
+public class MapPlatformClassToKotlinFix extends JetIntentionAction<JetUserType> {
+    LinkedHashSet<String> possibleTypes;
+
+    public MapPlatformClassToKotlinFix(@NotNull JetUserType element, LinkedHashSet<String> possibleTypes) {
+        super(element);
+        this.possibleTypes = possibleTypes;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return possibleTypes.size() == 1
+               ? JetBundle.message(""map.platform.class.to.kotlin"", element.getText(), possibleTypes.iterator().next())
+               : JetBundle.message(""map.platform.class.to.kotlin.multiple"", element.getText());
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""map.platform.class.to.kotlin.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        JetTypeReference newType = JetPsiFactory.createType(project, possibleTypes.iterator().next());
+        JetTypeElement newTypeElement = newType.getTypeElement();
+        assert newTypeElement != null;
+        PsiElement replacedElement = element.replace(newTypeElement);
+
+        if (possibleTypes.size() > 1) {
+            PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(editor.getDocument());
+            TemplateBuilder builder = TemplateBuilderFactory.getInstance().createTemplateBuilder(replacedElement);
+            builder.replaceElement(replacedElement, new MyLookupExpression(replacedElement.getText(), possibleTypes, null, false, getText()));
+            builder.run(editor, true);
+        }
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetUserType type = QuickFixUtil.getParentElementOfType(diagnostic, JetUserType.class);
+                if (type == null) return null;
+
+                if (!(diagnostic instanceof DiagnosticWithParameters1)) return null;","It would be better to assert type of diagnostic.getFactory() at the begining, and cast diagnostic to DiagnosticWithParameters1<JetElement, Collection<ClassDescriptor>>. See AddStarProjectionsFix. Don't forget to supress unchecked warning in this case.
",I don't think you need the `*` here.
21,"@@ -0,0 +1,105 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.jetbrains.kotlin.it</groupId>
+    <artifactId>test-helloworld</artifactId>
+    <version>1.0</version>
+    <name>Test Hello World project</name>
+
+    <description>
+        Test the kotlin-maven-plugin:compile goal on HelloWorld project.
+    </description>
+
+    <properties>
+        <kotlin.version>0.1-SNAPSHOT</kotlin.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.9</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <!--suppress MavenModelInspection -->
+        <sourceDirectory>${project.basedir}/src/main/kotlin</sourceDirectory>
+        <!--suppress MavenModelInspection -->
+        <!--testSourceDirectory>${project.basedir}/src/test/kotlin</testSourceDirectory-->
+        <plugins>
+            <plugin>
+                <artifactId>kotlin-maven-plugin</artifactId>
+                <groupId>org.jetbrains.kotlin</groupId>
+                <version>${kotlin.version}</version>
+                <executions>
+                    <execution>
+                        <id>compile</id>
+                        <phase>process-sources</phase>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>test-compile</id>
+                        <phase>process-test-sources</phase>
+                        <goals>
+                            <goal>test-compile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+
+    <repositories>
+        <repository>
+            <id>jetbrains-release</id>
+            <url>http://repository.jetbrains.com/releases</url>
+            <releases>
+                <enabled>true</enabled>
+            </releases>
+            <snapshots>
+                <enabled>false</enabled>
+            </snapshots>
+        </repository>
+        <repository>
+            <id>jetbrains-snapshots</id>
+            <url>http://repository.jetbrains.com/kotlin-snapshots</url>
+            <releases>
+                <enabled>false</enabled>
+            </releases>
+            <snapshots>
+                <enabled>true</enabled>
+            </snapshots>
+        </repository>
+    </repositories>
+
+    <pluginRepositories>
+        <pluginRepository>","Do we need all those repositories here?
",I think this should be `0.1-SNAPSHOT`
22,"@@ -0,0 +1,107 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.findUsages.handlers
+
+import com.intellij.find.findUsages.FindUsagesHandler
+import com.intellij.find.findUsages.FindUsagesOptions
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.GlobalSearchScope
+import com.intellij.psi.search.SearchScope
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.findUsages.KotlinFindUsagesHandlerFactory
+import org.jetbrains.kotlin.idea.util.application.runReadAction
+
+import java.util.ArrayList
+import java.util.Collections
+
+public abstract class KotlinFindUsagesHandler<T : PsiElement>(psiElement: T,
+                                                              private val elementsToSearch: Collection<PsiElement>,
+                                                              public val factory: KotlinFindUsagesHandlerFactory)
+    : FindUsagesHandler(psiElement) {
+
+    @suppress(""UNCHECKED_CAST"")
+    public fun getElement(): T {
+        return getPsiElement() as T
+    }
+
+    public constructor(psiElement: T, factory: KotlinFindUsagesHandlerFactory) : this(psiElement, emptyList(), factory) {
+    }
+
+    override fun getPrimaryElements(): Array<PsiElement> {
+        return if (elementsToSearch.isEmpty())
+            arrayOf(getPsiElement())
+        else
+            elementsToSearch.toTypedArray()
+    }
+
+    protected fun searchTextOccurrences(element: PsiElement, processor: Processor<UsageInfo>, options: FindUsagesOptions): Boolean {
+        val scope = options.searchScope
+
+        val searchText = options.isSearchForTextOccurrences && scope is GlobalSearchScope","If you inline this variable, you can get rid of `as` operators below.
",I don't think we need the `@suppress` here.
23,"@@ -0,0 +1,107 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.findUsages.handlers
+
+import com.intellij.find.findUsages.FindUsagesHandler
+import com.intellij.find.findUsages.FindUsagesOptions
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.GlobalSearchScope
+import com.intellij.psi.search.SearchScope
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.findUsages.KotlinFindUsagesHandlerFactory
+import org.jetbrains.kotlin.idea.util.application.runReadAction
+
+import java.util.ArrayList
+import java.util.Collections
+
+public abstract class KotlinFindUsagesHandler<T : PsiElement>(psiElement: T,
+                                                              private val elementsToSearch: Collection<PsiElement>,
+                                                              public val factory: KotlinFindUsagesHandlerFactory)
+    : FindUsagesHandler(psiElement) {
+
+    @suppress(""UNCHECKED_CAST"")
+    public fun getElement(): T {
+        return getPsiElement() as T
+    }
+
+    public constructor(psiElement: T, factory: KotlinFindUsagesHandlerFactory) : this(psiElement, emptyList(), factory) {
+    }
+
+    override fun getPrimaryElements(): Array<PsiElement> {
+        return if (elementsToSearch.isEmpty())
+            arrayOf(getPsiElement())
+        else
+            elementsToSearch.toTypedArray()
+    }
+
+    protected fun searchTextOccurrences(element: PsiElement, processor: Processor<UsageInfo>, options: FindUsagesOptions): Boolean {
+        val scope = options.searchScope
+
+        val searchText = options.isSearchForTextOccurrences && scope is GlobalSearchScope
+
+        if (searchText) {
+            if (options.fastTrack != null) {","If you revert this condition, you can get rid of `else`.
",I don't think we need the `@suppress` here.
24,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.JetClass;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lexer.JetKeywordToken;
+import org.jetbrains.jet.lexer.JetToken;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+
+import static org.jetbrains.jet.lexer.JetTokens.FINAL_KEYWORD;
+import static org.jetbrains.jet.lexer.JetTokens.OPEN_KEYWORD;
+
+public class FinalSupertypeFix extends JetIntentionAction<JetClass> {
+    private final JetClass childClass;
+    private JetClass superClass;
+
+    public FinalSupertypeFix(@NotNull JetClass childClass) {
+        super(childClass);
+        this.childClass = childClass;
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        if (!super.isAvailable(project, editor, file)) {
+            return false;
+        }
+
+        BindingContext context = KotlinCacheManager.getInstance(project).getDeclarationsFromProject(project).getBindingContext();
+        ClassDescriptor childClassDescriptor = context.get(BindingContext.CLASS, childClass);
+        if (childClassDescriptor == null) {
+            return false;
+        }
+        for (JetType supertype: childClassDescriptor.getTypeConstructor().getSupertypes()) {
+            ClassDescriptor superClassDescriptor = (ClassDescriptor) supertype.getConstructor().getDeclarationDescriptor();
+            if (superClassDescriptor == null) {
+                continue;
+            }
+            PsiElement boundElement = BindingContextUtils.descriptorToDeclaration(context, superClassDescriptor);
+            if (boundElement instanceof JetClass) {","Why do you call it ""bound element""?
",I don't think you need this import.
25,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.JetClass;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lexer.JetKeywordToken;
+import org.jetbrains.jet.lexer.JetToken;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+
+import static org.jetbrains.jet.lexer.JetTokens.FINAL_KEYWORD;
+import static org.jetbrains.jet.lexer.JetTokens.OPEN_KEYWORD;
+
+public class FinalSupertypeFix extends JetIntentionAction<JetClass> {
+    private final JetClass childClass;
+    private JetClass superClass;
+
+    public FinalSupertypeFix(@NotNull JetClass childClass) {
+        super(childClass);
+        this.childClass = childClass;
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        if (!super.isAvailable(project, editor, file)) {
+            return false;
+        }
+
+        BindingContext context = KotlinCacheManager.getInstance(project).getDeclarationsFromProject(project).getBindingContext();
+        ClassDescriptor childClassDescriptor = context.get(BindingContext.CLASS, childClass);
+        if (childClassDescriptor == null) {
+            return false;
+        }
+        for (JetType supertype: childClassDescriptor.getTypeConstructor().getSupertypes()) {
+            ClassDescriptor superClassDescriptor = (ClassDescriptor) supertype.getConstructor().getDeclarationDescriptor();
+            if (superClassDescriptor == null) {
+                continue;
+            }
+            PsiElement boundElement = BindingContextUtils.descriptorToDeclaration(context, superClassDescriptor);
+            if (boundElement instanceof JetClass) {
+                superClass = (JetClass) boundElement;
+                if (!superClass.isTrait() && !superClass.isEnum() && superClass.getContainingFile().isWritable()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""add.supertype.modifier"", ""open"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""add.supertype.modifier.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert superClass != null;
+        JetToken[] modifiersThanCanBeReplaced = new JetKeywordToken[] { FINAL_KEYWORD };
+        superClass.replace(AddModifierFix.addModifier(superClass, OPEN_KEYWORD, modifiersThanCanBeReplaced, project, false));
+    }
+
+    @Nullable","Why is this method nullable?
",I don't think you need this import.
26,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+","Please declare all variables exactly before they are needed. It's usually a bad idea to declare all variables at once and then write the whole logic. A reader might think that the following behavior somehow depends on values of all these variables, while in reality your code should look more like: if doesn't have declared param types, return true; **else** if doesn't have declared return type, return true; **else** and so on. That's a lot easier to grasp, since you don't have to carry a lot of context while reading the code
",I think it would be better to use `isApplicab
27,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())","There's an inspection here saying that you should use `[]` instead of `get`
",I think it would be better to use `isApplicab
28,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()","There are warnings saying that `!!` is useless on `func`, since it's been already checked to be non-null.

Also these variables don't add much to the readability, it may be a good idea to inline them
",I think it would be better to use `isApplicab
29,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true","There's a warning saying that `getValueParameters` never returns null. Maybe you meant to check if it's non-empty?
",I think it would be better to use `isApplicab
30,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()","You call `element.getFunctionLiteral()` **a lot** in this function. Why not extract it to a named variable?
",I think it would be better to use `isApplicab
31,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())!!","Ditto (`[]` instead of `get`)
",I think it would be better to use `isApplicab
32,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())!!
+        val valueParameters = func!!.getValueParameters()
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()","Again, please declare all variables exactly before they are needed. In this function, `expectedReturnType` is only needed in Step 2, so declare it there. `expectedReceiverType` is only needed in Step 3, and so on
",I think it would be better to use `isApplicableTo(element: JetFunctionLiteralExpression)` here.
33,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())!!
+        val valueParameters = func!!.getValueParameters()
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+        val parameterString = StringUtil.join(valueParameters,
+                                              {(descriptor: ValueParameterDescriptor?): String ->
+                                                  """" + descriptor!!.getName() +
+                                                  "": "" + DescriptorRenderer.TEXT.renderType(descriptor!!.getType())","There's a warning here about a useless `!!`: you've already asserted that `descriptor` is non-null on the previous line
",I think it would be better to use `isApplicableTo(element: JetFunctionLiteralExpression)` here.
34,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())!!
+        val valueParameters = func!!.getValueParameters()
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+        val parameterString = StringUtil.join(valueParameters,
+                                              {(descriptor: ValueParameterDescriptor?): String ->
+                                                  """" + descriptor!!.getName() +
+                                                  "": "" + DescriptorRenderer.TEXT.renderType(descriptor!!.getType())
+                                              },
+                                              "", "");
+
+        // Step 1: make the parameters types explicit
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), ""("" + parameterString + "")"")","A nicer way would be to use `makeString`, which allows to pass a prefix and a postfix:
`val parameterString = valueParameters.map { ... }.makeString("", "", ""("", "")"")`
",I think it would be better to use `isApplicableTo(element: JetFunctionLiteralExpression)` here.
35,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import com.intellij.openapi.util.text.StringUtil
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+
+        if (!hasDeclaredReturnType && expectedReturnType != null) return true
+        if (!hasDeclaredReceiverType && expectedReceiverType != null) return true
+        if (!hasDeclaredParamsType && func!!.getValueParameters() != null) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val params = element.getFunctionLiteral().getValueParameterList()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context.get(BindingContext.FUNCTION, element.getFunctionLiteral())!!
+        val valueParameters = func!!.getValueParameters()
+        val expectedReturnType = func!!.getReturnType()
+        val expectedReceiverType = func!!.getReceiverParameter()?.getType()
+        val parameterString = StringUtil.join(valueParameters,
+                                              {(descriptor: ValueParameterDescriptor?): String ->
+                                                  """" + descriptor!!.getName() +
+                                                  "": "" + DescriptorRenderer.TEXT.renderType(descriptor!!.getType())
+                                              },
+                                              "", "");
+
+        // Step 1: make the parameters types explicit
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), ""("" + parameterString + "")"")
+        if (params != null) {
+            params.replace(newParameterList)
+        }
+        else {
+            val openBraceElement = element.getFunctionLiteral().getOpenBraceNode().getPsi()
+            val nextSibling = openBraceElement?.getNextSibling()
+            val whitespaceToAdd = (if (nextSibling is PsiWhiteSpace && nextSibling?.getText()?.contains(""\n"")?: false)
+                nextSibling?.copy()","There's a warning here and on the previous line about a useless `?:`
",I think it would be better to use `isApplicableTo(element: JetFunctionLiteralExpression)` here.
36,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import com.intellij.psi.CommonClassNames
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.NoType
+import javax.lang.model.type.TypeKind
+
+class SymbolBasedClass<T : TypeElement>(element: T,",Looks like generic parameter `T` can de dropped here and `element` could just have the type `TypeElement`,I don't think we need this class.
37,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import com.intellij.psi.CommonClassNames
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.NoType
+import javax.lang.model.type.TypeKind
+
+class SymbolBasedClass<T : TypeElement>(element: T,
+                                        javac: JavacWrapper) : SymbolBasedClassifier<TypeElement>(element, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())","There's no point in calling `safeIdentifier` on a non-null string, it's the same as simply `Name.identifier`. Maybe you meant to handle the case of anonymous classes? The docs say an empty string will be returned in that case.",I don't think we need to override `get()` here.
38,"@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import com.intellij.psi.CommonClassNames
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.NoType
+import javax.lang.model.type.TypeKind
+
+class SymbolBasedClass<T : TypeElement>(element: T,
+                                        javac: JavacWrapper) : SymbolBasedClassifier<TypeElement>(element, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())
+
+    override val isAbstract
+        get() = element.isAbstract
+
+    override val isStatic
+        get() = element.isStatic
+
+    override val isFinal
+        get() = element.isFinal
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val typeParameters
+        get() = element.typeParameters.map { SymbolBasedTypeParameter(it, javac) }
+
+    override val fqName
+        get() = FqName(element.qualifiedName.toString())
+
+    override val supertypes","To be honest, I prefer properties and functions with explicit return type, unless omitting it makes code substantially more readable, which is not the case here, I think (I mean not only this file, but all files added in these commits).",I don't think we need to override these methods.
39,"@@ -0,0 +1,11 @@
+// !DIAGNOSTICS: -INVISIBLE_MEMBER -INVISIBLE_REFERENCE -UNUSED_PARAMETER
+// !LANGUAGE: +CalledInPlaceEffect
+
+import kotlin.internal.*
+
+inline fun myRun(@CalledInPlace(InvocationCount.EXACTLY_ONCE) block: () -> Unit) = block()
+
+fun throwInLambda(): Int {
+    val x = myRun { throw java.lang.IllegalArgumentException() }
+    return <!TYPE_MISMATCH!>x<!>","Unclear place. First, why `TYPE_MISMATCH`? In this context, `x` should probably have `Nothing` type. Second, `UNREACHABLE_CODE` is expected here. Third, I don't quite understand why it appears after introduction of language features (the last but one commit).",Why do we need this?
40,"@@ -0,0 +1,11 @@
+// WITH_RUNTIME
+// IS_APPLICABLE: FALSE
+import java.util.LinkedList
+
+fun Int.withIndices(): List<Pair<Int, Int>> = LinkedList<Pair<Int, Int>>()
+
+fun foo(s: Int) {
+    for ((index<caret>, a) in s.withIndices()) {
+
+    }
+}","Also please rename this test
",Why is this needed?
41,"@@ -0,0 +1,110 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+import org.jetbrains.jet.lang.psi.JetCallableReferenceExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import kotlin.properties.Delegates
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.plugin.intentions.branchedTransformations.extractExpressionIfSingle
+import org.jetbrains.jet.lang.psi.JetThrowExpression
+import org.jetbrains.jet.lang.resolve.calls.model.ResolvedCall
+import org.jetbrains.jet.lang.descriptors.CallableDescriptor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.resolve.calls.model.ResolvedValueArgument
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetUserType
+
+public class ConvertIfWithThrowToAssertIntention : JetSelfTargetingIntention<JetIfExpression>(
+        ""convert.if.with.throw.to.assert"", javaClass()) {
+
+    private var resolvedCall: ResolvedCall<out CallableDescriptor> by Delegates.notNull()
+    private var param: ResolvedValueArgument by Delegates.notNull()
+
+    override fun isApplicableTo(element: JetIfExpression): Boolean {
+        if (element.getElse() != null) return false
+
+        val thenExpr = element.getThen()?.extractExpressionIfSingle()
+        if (thenExpr !is JetThrowExpression) return false
+
+        val thrownExpr = getSelector(thenExpr.getThrownExpression())
+        if (thrownExpr !is JetCallExpression) return false
+
+        if (thrownExpr.getCalleeExpression()?.getText() != ""AssertionError"") return false
+
+        val context = AnalyzerFacadeWithCache.getContextForElement(thrownExpr)
+        val nullableResolvedCall = context[BindingContext.RESOLVED_CALL, thrownExpr.getCalleeExpression()]
+        if (nullableResolvedCall == null) return false
+        resolvedCall = nullableResolvedCall
+
+        val paramAmount = resolvedCall.getValueArguments().size
+        if (paramAmount != 1) return false
+
+        val paramDescriptor = resolvedCall.getResultingDescriptor().getValueParameters()[0]
+        param = resolvedCall.getValueArguments()[paramDescriptor]!!
+        if (param.toString() == ""null"") return false
+
+        return DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()).toString() == ""java.lang.AssertionError.<init>""
+    }
+
+    private fun getSelector(element: JetExpression?): JetExpression? {
+        if (element is JetDotQualifiedExpression) {
+            return element.getSelectorExpression()
+        }
+        return element
+    }
+
+    override fun applyTo(element: JetIfExpression, editor: Editor) {
+        val condition = element.getCondition()
+        if (condition == null) return
+
+        val negatedCondition = JetPsiFactory.createExpression(element.getProject(), ""!true"") as JetPrefixExpression
+        negatedCondition.getBaseExpression()!!.replace(condition)
+        condition.replace(negatedCondition)
+
+        val newCondition = element.getCondition() as JetPrefixExpression
+        val simplifier = SimplifyNegatedBinaryExpressionIntention()
+        if (simplifier.isApplicableTo(newCondition)) {
+            simplifier.applyTo(newCondition, editor)
+        }
+
+        val assertText = ""assert(${element.getCondition()?.getText()}, $param)""
+        val assertExpr = JetPsiFactory.createExpression(element.getProject(), assertText)
+
+        val newExpr = element.replace(assertExpr) as JetCallExpression
+        if (isCalResolvedToKotlinAssert(newExpr)) return","ShortenReferences was not working for ""kotlin.assert"" it would always process it back to the full ""kotlin.assert"", i tried debugging it for a couple of days but when i couldn't i figured this method should be just as good, I create the element with the short name ""assert"" and then get the resolved call, if it doesn't resolve to ""kotlin.assert"" i replace it with the dot qualified call
",I don't think we need this import.
42,"@@ -0,0 +1,111 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.android.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+import org.jetbrains.android.facet.AndroidFacet
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors.SUPERTYPE_NOT_INITIALIZED
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction
+import org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory
+import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.makeNotNullable
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+class KotlinAndroidViewConstructorFix(element: KtSuperTypeEntry) : KotlinQuickFixAction<KtSuperTypeEntry>(element) {
+
+    override fun getText() = ""Add Android View constructors using '@JvmOverloads'""
+    override fun getFamilyName() = text
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (AndroidFacet.getInstance(file) == null) return false
+        return super.isAvailable(project, editor, file)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+        val ktClass = element.containingClass() ?: return
+
+        val factory = KtPsiFactory(element)
+
+        val newPrimaryConstructor = factory.createDeclarationByPattern<KtClass>(
+                ""class A constructor(\n $0, $1, $2\n)"",
+                factory.createParameter(""context: android.content.Context""),
+                factory.createParameter(""attrs: android.util.AttributeSet? = null""),
+                factory.createParameter(""defStyleAttr: Int = 0"")
+        ).primaryConstructor ?: return
+
+        val primaryConstructor = ktClass.createPrimaryConstructorIfAbsent().replaced(newPrimaryConstructor)
+        primaryConstructor.valueParameterList?.let { ShortenReferences.DEFAULT.process(it) }
+
+        primaryConstructor.addAnnotation(fqNameAnnotation, whiteSpaceText = "" "")
+
+        element.replace(factory.createSuperTypeCallEntry(element.text + ""(context, attrs, defStyleAttr)""))
+    }
+
+    companion object Factory : KotlinSingleIntentionActionFactory() {
+
+        private val fqNameAnnotation = FqName(""kotlin.jvm.JvmOverloads"")
+
+        private val requiredConstructorParameterTypes =
+                listOf(""android.content.Context"", ""android.util.AttributeSet"", ""kotlin.Int"")
+
+        override fun createAction(diagnostic: Diagnostic): IntentionAction? {
+            val superTypeEntry = SUPERTYPE_NOT_INITIALIZED.cast(diagnostic).psiElement
+
+            val ktClass = superTypeEntry.containingClass() ?: return null
+            if (ktClass.primaryConstructor != null) return null
+
+            val context = superTypeEntry.analyze()
+            val type = superTypeEntry.typeReference?.let { context[BindingContext.TYPE, it] } ?: return null
+
+            if (!type.isAndroidView() && type.supertypes().none { it.isAndroidView() }) return null
+
+            val names = type.constructorParameters() ?: return null
+            if (requiredConstructorParameterTypes !in names) return null
+
+            return KotlinAndroidViewConstructorFix(superTypeEntry)
+        }
+
+        private fun KotlinType.isAndroidView(): Boolean {
+            return constructor.declarationDescriptor?.fqNameUnsafe?.asString() == ""android.view.View""
+        }
+
+        private fun KotlinType.constructorParameters(): List<List<String?>>? {
+            val classDescriptor = constructor.declarationDescriptor as? ClassDescriptor ?: return null
+            return classDescriptor.constructors.map {
+                it.valueParameters.map { IdeDescriptorRenderers.SOURCE_CODE_NOT_NULL_TYPE_APPROXIMATION.renderType(it.type.makeNotNullable()) }
+            }
+        }
+    }","I suggest minor refactoring
```kotlin
private fun KotlinType.getFqNameAsString() = constructor.declarationDescriptor?.fqNameUnsafe?.asString()

private fun KotlinType.isAndroidView() = getFqNameAsString() == ""android.view.View""

// and we can avoid IdeDescriptorRenderers
// ...
    it.valueParameters.map { it.type.getFqNameAsString() }
// ...
}
```
",This file is missing the license header.
43,"@@ -0,0 +1,115 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions.attributeCallReplacements
+
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.JetBundle
+import com.intellij.psi.PsiFile
+import org.jetbrains.jet.lang.psi.psiUtil.getParentByTypesAndPredicate
+import com.intellij.openapi.project.Project
+import com.intellij.codeInsight.intention.impl.BaseIntentionAction
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public abstract class AttributeCallReplacementIntention(val name: String) : BaseIntentionAction() {
+    {
+        setText(getFamilyName())
+    }
+
+    protected class Replacement(val target: JetExpression, val text: String)
+
+    private val elementType = javaClass<JetDotQualifiedExpression>()
+
+    abstract protected fun isApplicableToCall(call: JetCallExpression) : Boolean
+    abstract protected fun makeReplacement(element: JetQualifiedExpression, call: JetCallExpression, receiver: JetExpression) : Replacement
+
+    protected fun getTarget(editor: Editor, file: PsiFile): JetDotQualifiedExpression? {
+        val offset = editor.getCaretModel().getOffset()
+        return file.findElementAt(offset)?.getParentByTypesAndPredicate(false, elementType) {
+            element -> with (element.getSelectorExpression()) {","Is this kosher?
",I don't think we need this abstract class.
44,"@@ -0,0 +1,115 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions.attributeCallReplacements
+
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.JetBundle
+import com.intellij.psi.PsiFile
+import org.jetbrains.jet.lang.psi.psiUtil.getParentByTypesAndPredicate
+import com.intellij.openapi.project.Project
+import com.intellij.codeInsight.intention.impl.BaseIntentionAction
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public abstract class AttributeCallReplacementIntention(val name: String) : BaseIntentionAction() {
+    {
+        setText(getFamilyName())
+    }
+
+    protected class Replacement(val target: JetExpression, val text: String)
+
+    private val elementType = javaClass<JetDotQualifiedExpression>()
+
+    abstract protected fun isApplicableToCall(call: JetCallExpression) : Boolean
+    abstract protected fun makeReplacement(element: JetQualifiedExpression, call: JetCallExpression, receiver: JetExpression) : Replacement
+
+    protected fun getTarget(editor: Editor, file: PsiFile): JetDotQualifiedExpression? {
+        val offset = editor.getCaretModel().getOffset()
+        return file.findElementAt(offset)?.getParentByTypesAndPredicate(false, elementType) {
+            element -> with (element.getSelectorExpression()) {
+                when (this) {
+                    is JetCallExpression -> isApplicableToCall(this)
+                    else -> false
+                }
+            }
+        }
+    }
+
+    public override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        return with (getTarget(editor, file)) {
+            when(this) {
+                null -> false
+                else -> {
+                    updateText(this, this.getSelectorExpression() as JetCallExpression, this.getReceiverExpression())
+                    true
+                }
+            }
+        }
+    }
+
+    // Override this to manually specify the intention text.
+    protected open fun updateText(element: JetQualifiedExpression, call: JetCallExpression, receiver: JetExpression) {
+        val replacement = makeReplacement(element, call, receiver)
+        val before = replacement.target.getText()
+        val after = replacement.text
+        if (before != null)
+            setText(before, after)
+    }
+
+    protected fun setText(before: String, after: String) {
+        setText(JetBundle.message(""replace.attribute.call"", before, after))
+    }
+
+
+    public override fun getFamilyName() : String {
+        return JetBundle.message(""replace.attribute.call.family"", name)
+    }
+
+    public override fun invoke(project: Project, editor: Editor, file: PsiFile): Unit {
+        val target = getTarget(editor, file)
+        assert(target != null, ""Intention is not applicable"")
+        target!! // It matches","There has to be a better way to do this.
",I don't think we need this abstract class.
45,"@@ -0,0 +1,117 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.jvm.compiler
+
+import com.intellij.openapi.Disposable
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.cli.jvm.compiler.EnvironmentConfigFiles
+import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
+import org.jetbrains.kotlin.config.JVMConfigurationKeys
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.renderer.*
+import org.jetbrains.kotlin.resolve.lazy.JvmResolveUtil
+import org.jetbrains.kotlin.test.ConfigurationKind
+import org.jetbrains.kotlin.test.KotlinTestUtils
+import org.jetbrains.kotlin.test.TestCaseWithTmpdir
+import org.jetbrains.kotlin.test.TestJdkKind
+import org.junit.Assert
+
+import java.io.File
+import java.io.IOException
+import java.lang.annotation.Retention
+
+import org.jetbrains.kotlin.test.KotlinTestUtils.*
+import org.jetbrains.kotlin.test.util.RecursiveDescriptorComparator.validateAndCompareDescriptorWithFile
+
+abstract class AbstractCompileJavaAgainstKotlinTest : TestCaseWithTmpdir() {
+
+    @Throws(IOException::class)
+    protected fun doTest(ktFilePath: String) {
+        Assert.assertTrue(ktFilePath.endsWith("".kt""))
+        val ktFile = File(ktFilePath)
+        val javaFile = File(ktFilePath.replaceFirst(""\\.kt$"".toRegex(), "".java""))
+
+        val javaErrorFile = File(ktFilePath.replaceFirst(""\\.kt$"".toRegex(), "".javaerr.txt""))
+
+        val useJavac = true","I'd make this a class property, set it into `false` for old tests and `true` for new tests.",I don't think we need to use wildcard imports.
46,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()",Why?,I don't think you need to override `get()` here.
47,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }",What do you want to find in the empty list (see above)?,I don't think you need to override `get()` here.
48,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract","Is it true for interfaces? They are abstract without a modifier. I'm not sure should we return `abstract = true` for them, but probably yes.",I don't think you need to override `get()` here.
49,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic",Probably false if class is nested in interface (see JCField),I don't think you need to override `get()` here.
50,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = tree.modifiers.visibility",Probably false if class is nested in interface (see JCField),I don't think you need to override `get()` here.
51,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { JCTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCExpression -> JCClassifierType(this, TreePath(treePath, this), javac)",Don't quite understand this branch. Do you have some example?,I don't think you need to override `get()` here.
52,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { JCTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCExpression -> JCClassifierType(this, TreePath(treePath, this), javac)
+                this is JCTree.JCTypeApply -> JCClassifierTypeWithTypeArgument(this, TreePath(treePath, this), javac)
+                else -> null
+            }
+
+            tree.extending?.mapToJavaClassifierType()?.let(this::add)
+            tree.implementing?.map { it.mapToJavaClassifierType() }?.filterNotNull()?.let(this::addAll)
+
+            if (find { it.canonicalText == CommonClassNames.JAVA_LANG_OBJECT } == null) {
+                javac.JAVA_LANG_OBJECT?.let { add(JavacClassifierType(it.element.asType(), javac)) }","Again, do we need it if super class is given explicitly?",I don't think you need to override `get()` here.
53,"@@ -0,0 +1,118 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: Javac) : JCClassifier<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { JCTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCExpression -> JCClassifierType(this, TreePath(treePath, this), javac)
+                this is JCTree.JCTypeApply -> JCClassifierTypeWithTypeArgument(this, TreePath(treePath, this), javac)
+                else -> null
+            }
+
+            tree.extending?.mapToJavaClassifierType()?.let(this::add)
+            tree.implementing?.map { it.mapToJavaClassifierType() }?.filterNotNull()?.let(this::addAll)
+
+            if (find { it.canonicalText == CommonClassNames.JAVA_LANG_OBJECT } == null) {
+                javac.JAVA_LANG_OBJECT?.let { add(JavacClassifierType(it.element.asType(), javac)) }
+            }
+        }
+
+    override val innerClasses
+        get() = tree.members
+                .filterIsInstance(JCTree.JCClassDecl::class.java)
+                .map { JCClass(it, TreePath(treePath, it), javac) }
+
+    override val outerClass
+        get() = (treePath.parentPath.leaf as? JCTree.JCClassDecl)?.let { JCClass(it, treePath.parentPath, javac) }
+
+    override val isInterface by lazy { tree.modifiers.flags and Flags.INTERFACE.toLong() != 0L }","Here you're using `by lazy` instead of `get`. Why here, and why just here?",I don't think you need to override `get()` here.
54,"@@ -0,0 +1,12 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project version=""4"">
+  <component name=""SaveActionSettings"">
+    <option name=""actions"">
+      <set>
+        <option value=""organizeImports"" />
+        <option value=""reformat"" />
+        <option value=""reformatChangedCode"" />
+      </set>
+    </option>
+  </component>
+</project>",Not needed,I don't think you need the encoding here.
55,"@@ -0,0 +1,12 @@
+class A {
+    val a = """"
+    val b = """"
+}
+
+fun box(): String {
+    val a = A::a.name
+    if (a != ""a"") return ""Fail $a""
+    val b = A::`b`.name
+    if (b != ""b"") return ""Fail $b""
+    return ""OK""","This test doesn't check that no classes were generated for the property reference. I don't think it's possible in a `box` test, please try a bytecode listing test instead (`compiler/testData/codegen/bytecodeListing`).

Also please test constructors and functions
",Why is this a<msg>`<msg>`<msg>This is not a<msg>
56,"@@ -0,0 +1,12 @@
+public class TestingUse {
+    fun test6(funcLitfunc: ((x: Int) -> Int) -> Boolean, innerfunc: (y: Int) -> Int): Unit {
+        val result = funcLitfunc(innerfunc)
+        var num = 0
+        if (result == true) num = 1
+        else num = 2","This is a nice test case, but is this code really needed to test your intention? I think it's just confusing...
",I think this should be named `test7`
57,"@@ -0,0 +1,120 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.unwrapBlockOrParenthesis
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class ConstantConditionIfInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitIfExpression(expression: KtIfExpression) {
+                super.visitIfExpression(expression)
+
+                val condition = expression.condition ?: return
+
+                val context = condition.analyze(BodyResolveMode.PARTIAL)
+                val constantValue = condition.constantBooleanValue(context) ?: return
+
+                val fixes = mutableListOf<LocalQuickFix>()
+
+                if (expression.branch(constantValue) != null) {
+                    fixes += SimplifyFix(constantValue, expression.isUsedAsExpression(context))
+                }
+
+                if (!constantValue && expression.`else` == null) {
+                    fixes += RemoveFix()
+                }
+
+                holder.registerProblem(expression, ""Condition of 'if' expression is constant"", *fixes.toTypedArray())
+            }
+        }
+    }
+
+    private class SimplifyFix(
+            private val conditionValue: Boolean,
+            private val isUsedAsExpression: Boolean
+    ) : LocalQuickFix {
+        override fun getFamilyName() = ""Simplify expression""
+
+        override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+            val ifExpression = descriptor.psiElement as? KtIfExpression ?: return
+            val caretModel = ifExpression.findExistingEditor()?.caretModel
+
+            val branch = ifExpression.branch(conditionValue)?.unwrapBlockOrParenthesis() ?: return
+
+            val lastExpression =
+                    if (branch !is KtBlockExpression) {",Probably with `when` it will be more readable,I don't think this is needed.
58,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false","Please don't store any information in mutable `var`s inside your intention: it might cause problems with concurrency. E.g. see what problems Gavin encountered in #411
",I don't think we need this class. We can just us
59,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {","This can be simplified to `paramsTextRange != null && caretLocation in paramsTextRange` or `paramsTextRange?.contains(caretLocation) ?: false`, whichever you like the most
",I don't think you need to override this method.
60,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false","Please convert this to `&&` by DeMorgan, it'll be more readable that way
",I don't think you need to override this method.
61,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        hasImplicitReturnType = !element.hasDeclaredReturnType()
+        hasImplicitReceiverType = element.getFunctionLiteral().getReceiverTypeRef() == null
+        if (hasImplicitReturnType && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.any { it.getTypeReference() == null } || params.isEmpty()) return true","This is rather minor, but you should always strive to do simple checks first and complex checks later. It increases both readability and performance. Here `params.isEmpty()` is obviously very cheap compared to the other condition which involves looping over a collection
",I don't think you need to override this method.
62,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        hasImplicitReturnType = !element.hasDeclaredReturnType()
+        hasImplicitReceiverType = element.getFunctionLiteral().getReceiverTypeRef() == null
+        if (hasImplicitReturnType && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.any { it.getTypeReference() == null } || params.isEmpty()) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor?): String ->","Type of `descriptor` can be a non-null `ValueParameterDescriptor` here, because Kotlin sees Java generic types with non-null type arguments by default, so `valueParameters` is actually `List<ValueParameterDescriptor>`, not `List<ValueParameterDescriptor?>`
",I don't think you need to override this method.
63,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        hasImplicitReturnType = !element.hasDeclaredReturnType()
+        hasImplicitReceiverType = element.getFunctionLiteral().getReceiverTypeRef() == null
+        if (hasImplicitReturnType && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.any { it.getTypeReference() == null } || params.isEmpty()) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor?): String ->
+                                                      """" + descriptor!!.getName() +
+                                                      "": "" + DescriptorRenderer.TEXT.renderType(descriptor.getType())
+                                                  }).makeString("", "", ""("", "")"")
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+        val params = functionLiteral.getValueParameterList()","I think `params` should have been named `oldParameterList`, to oppose `newParameterList`
",I don't think you need to override this method.
64,"@@ -0,0 +1,121 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+    private var hasImplicitReturnType = false
+    private var hasImplicitReceiverType = false
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        hasImplicitReturnType = !element.hasDeclaredReturnType()
+        hasImplicitReceiverType = element.getFunctionLiteral().getReceiverTypeRef() == null
+        if (hasImplicitReturnType && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.any { it.getTypeReference() == null } || params.isEmpty()) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor?): String ->
+                                                      """" + descriptor!!.getName() +
+                                                      "": "" + DescriptorRenderer.TEXT.renderType(descriptor.getType())
+                                                  }).makeString("", "", ""("", "")"")
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+        val params = functionLiteral.getValueParameterList()
+        if (params != null) {
+            params.replace(newParameterList)
+        }
+        else {
+            val openBraceElement = functionLiteral.getOpenBraceNode().getPsi()
+            val nextSibling = openBraceElement?.getNextSibling()
+            val whitespaceToAdd = (if (nextSibling is PsiWhiteSpace && nextSibling?.getText()?.contains(""\n"")?: false)","There's a warning on `?.` here :) If you're not sure whether or not your code has warnings, check the small box in IntelliJ's top-right corner, it should be green
",I don't think you need to override this method.
65,"@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+            caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        if (hasImplicitReturnType(element) && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType(element) && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.isEmpty() || params.any { it.getTypeReference() == null }) return true
+
+        return false","Please collapse these two lines. `if (condition) return true; return false` can be simplified to `return condition`
",I think this should be `isApplicableTo(JetExpre
66,"@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+            caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        if (hasImplicitReturnType(element) && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType(element) && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.isEmpty() || params.any { it.getTypeReference() == null }) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor): String ->","Ditto: I don't think types are needed here
",I think this should be `isApplicableTo(JetExpre
67,"@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+            caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        if (hasImplicitReturnType(element) && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType(element) && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.isEmpty() || params.any { it.getTypeReference() == null }) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor): String ->
+                                                      """" + descriptor.getName() +
+                                                      "": "" + DescriptorRenderer.TEXT.renderType(descriptor.getType())
+                                                  }).makeString("", "", ""("", "")"")
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+        val oldParameterList = functionLiteral.getValueParameterList()
+        if (oldParameterList != null) {
+            oldParameterList.replace(newParameterList)
+        }
+        else {
+            val openBraceElement = functionLiteral.getOpenBraceNode().getPsi()
+            val nextSibling = openBraceElement?.getNextSibling()
+            val whitespaceToAdd = (if (nextSibling is PsiWhiteSpace && nextSibling.getText()?.contains(""\n"")?: false)","I couldn't find tests on this code, am I missing something? It looks kind of complex
",I think this should be `isApplicableTo(JetExpre
68,"@@ -0,0 +1,122 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.descriptors.ValueParameterDescriptor
+import org.jetbrains.jet.renderer.DescriptorRenderer
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+
+public class MakeTypeExplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.explicit.in.lambda"", javaClass()) {
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+            caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, element.getFunctionLiteral()]
+        if (func == null || ErrorUtils.containsErrorType(func)) return false
+
+        if (hasImplicitReturnType(element) && func.getReturnType() != null) return true
+        if (hasImplicitReceiverType(element) && func.getReceiverParameter()?.getType() != null) return true
+
+        val params = element.getValueParameters()
+        if (params.isEmpty() || params.any { it.getTypeReference() == null }) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val func = context[BindingContext.FUNCTION, functionLiteral]!!
+
+        // Step 1: make the parameters types explicit
+        val valueParameters = func.getValueParameters()
+        val parameterString = valueParameters.map({(descriptor: ValueParameterDescriptor): String ->
+                                                      """" + descriptor.getName() +
+                                                      "": "" + DescriptorRenderer.TEXT.renderType(descriptor.getType())
+                                                  }).makeString("", "", ""("", "")"")
+        val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+        val oldParameterList = functionLiteral.getValueParameterList()
+        if (oldParameterList != null) {
+            oldParameterList.replace(newParameterList)
+        }
+        else {
+            val openBraceElement = functionLiteral.getOpenBraceNode().getPsi()
+            val nextSibling = openBraceElement?.getNextSibling()
+            val whitespaceToAdd = (if (nextSibling is PsiWhiteSpace && nextSibling.getText()?.contains(""\n"")?: false)
+                nextSibling.copy()
+            else
+                null)
+            val whitespaceAndArrow = JetPsiFactory.createWhitespaceAndArrow(element.getProject())
+            functionLiteral.addRangeAfter(whitespaceAndArrow.first, whitespaceAndArrow.second, openBraceElement)
+            functionLiteral.addAfter(newParameterList, openBraceElement)
+            if (whitespaceToAdd != null) {
+                functionLiteral.addAfter(whitespaceToAdd, openBraceElement)
+            }
+        }
+        ShortenReferences.process(element.getValueParameters())
+
+
+        // Step 2: make the return type explicit
+        val expectedReturnType = func.getReturnType()
+        if (hasImplicitReturnType(element) && expectedReturnType != null) {
+            val paramList = functionLiteral.getValueParameterList()
+            val returnTypeColon = JetPsiFactory.createColon(element.getProject())
+            val returnTypeExpr = JetPsiFactory.createType(element.getProject(), DescriptorRenderer.TEXT.renderType(expectedReturnType))
+            ShortenReferences.process(returnTypeExpr)
+            functionLiteral.addAfter(returnTypeExpr, paramList)
+            functionLiteral.addAfter(returnTypeColon, paramList)
+        }
+
+        // Step 3: make the receiver type explicit
+        val expectedReceiverType = func.getReceiverParameter()?.getType()
+        if (hasImplicitReceiverType(element) && expectedReceiverType != null) {
+            val receiverTypeString = DescriptorRenderer.TEXT.renderType(expectedReceiverType)
+            val paramListString = functionLiteral.getValueParameterList()?.getText()
+            val paramListWithReceiver = JetPsiFactory.createExpression(element.getProject(), receiverTypeString + ""."" + paramListString)
+            ShortenReferences.process(paramListWithReceiver)
+            functionLiteral.getValueParameterList()?.replace(paramListWithReceiver)
+        }
+    }
+
+    fun hasImplicitReturnType(element: JetFunctionLiteralExpression): Boolean {
+        return !element.hasDeclaredReturnType()
+    }
+
+    fun hasImplicitReceiverType(element: JetFunctionLiteralExpression): Boolean {
+        return element.getFunctionLiteral().getReceiverTypeRef() == null
+    }","The last 2 functions in this file should be `private`
",I think this should be `isApplicableTo(JetExpre
69,"@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class ConvertTwoComparisonsToRangeCheckIntention : SelfTargetingOffsetIndependentIntention<KtBinaryExpression>(KtBinaryExpression::class.java, ""Convert to range check"") {
+
+    private data class RangeExpressionData(val value: String, val min: String, val max: String)
+
+    override fun isApplicableTo(condition: KtBinaryExpression) = generateRangeExpressionData(condition) != null
+
+    override fun applyTo(condition: KtBinaryExpression, editor: Editor?) {
+        val rangeData = generateRangeExpressionData(condition) ?: return
+        condition.replace(KtPsiFactory(condition).createExpressionByPattern(""$0 in $1..$2"", rangeData.value, rangeData.min, rangeData.max))
+    }
+
+    private fun generateRangeExpressionData(condition: KtBinaryExpression): RangeExpressionData? {
+        if (condition.operationToken != KtTokens.ANDAND) return null
+        val firstCondition = condition.left as? KtBinaryExpression ?: return null
+        val secondCondition = condition.right as? KtBinaryExpression ?: return null
+        val firstOpToken = firstCondition.operationToken
+        val secondOpToken = secondCondition.operationToken
+        val firstLeft = firstCondition.left ?: return null
+        val firstRight = firstCondition.right ?: return null
+        val secondLeft = secondCondition.left ?: return null
+        val secondRight = secondCondition.right ?: return null
+
+        return when (firstOpToken) {","This `when` is written in a very straight-forward way. Please, think a bit how to make it shorter. All branches are very like one another.",I don't think we need to override `isApplicable
70,"@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class ConvertTwoComparisonsToRangeCheckIntention : SelfTargetingOffsetIndependentIntention<KtBinaryExpression>(KtBinaryExpression::class.java, ""Convert to range check"") {
+
+    private data class RangeExpressionData(val value: String, val min: String, val max: String)
+
+    override fun isApplicableTo(condition: KtBinaryExpression) = generateRangeExpressionData(condition) != null
+
+    override fun applyTo(condition: KtBinaryExpression, editor: Editor?) {
+        val rangeData = generateRangeExpressionData(condition) ?: return
+        condition.replace(KtPsiFactory(condition).createExpressionByPattern(""$0 in $1..$2"", rangeData.value, rangeData.min, rangeData.max))
+    }
+
+    private fun generateRangeExpressionData(condition: KtBinaryExpression): RangeExpressionData? {
+        if (condition.operationToken != KtTokens.ANDAND) return null
+        val firstCondition = condition.left as? KtBinaryExpression ?: return null
+        val secondCondition = condition.right as? KtBinaryExpression ?: return null
+        val firstOpToken = firstCondition.operationToken
+        val secondOpToken = secondCondition.operationToken
+        val firstLeft = firstCondition.left ?: return null
+        val firstRight = firstCondition.right ?: return null
+        val secondLeft = secondCondition.left ?: return null
+        val secondRight = secondCondition.right ?: return null
+
+        return when (firstOpToken) {
+            KtTokens.GTEQ, KtTokens.GT -> {
+                when (secondOpToken) {
+                    KtTokens.GTEQ, KtTokens.GT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstLeft, firstRight, secondLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstRight, secondRight, firstLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        else -> null
+                    }
+                    KtTokens.LTEQ, KtTokens.LT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstLeft, firstRight, secondRight, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstRight, secondLeft, firstLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        else -> null
+                    }
+                    else -> null
+                }
+            }
+            KtTokens.LTEQ, KtTokens.LT -> {
+                when (secondOpToken) {
+                    KtTokens.GTEQ, KtTokens.GT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstLeft, secondRight, firstRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstRight, firstLeft, secondLeft, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        else -> null
+                    }
+                    KtTokens.LTEQ, KtTokens.LT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstLeft, secondLeft, firstRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstRight, firstLeft, secondRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        else -> null
+                    }
+                    else -> null
+                }
+            }
+            else -> null
+        }
+    }
+
+    private fun generateRangeExpressionData(value: KtExpression, min: KtExpression, max: KtExpression, minDecrementByOne: Boolean = false, maxDecrementByOne: Boolean = false): RangeExpressionData? {
+        if (minDecrementByOne || maxDecrementByOne) {
+            val type = value.getType(value.analyze()) ?: return null
+            if (!KotlinBuiltIns.isInt(type) && !KotlinBuiltIns.isLong(type) && !KotlinBuiltIns.isShort(type) && !KotlinBuiltIns.isChar(type)) return null
+        }
+
+        val minText = if (minDecrementByOne) min.getDecrementByOneString() else min.text
+        val maxText = if (maxDecrementByOne) max.getDecrementByOneString() else max.text
+        return RangeExpressionData(value.text, minText ?: return null, maxText ?: return null)
+    }
+
+    private fun KtExpression.getDecrementByOneString(): String? {
+        val type = getType(analyze()) ?: return null
+
+        when (this) {
+            is KtConstantExpression -> {
+                val number: Number = when {
+                    KotlinBuiltIns.isInt(type) -> text.toInt() - 1
+                    KotlinBuiltIns.isLong(type) -> {
+                        val text = text
+                        val longText = if (text.endsWith(""l"") || text.endsWith(""L"")) text.substring(0, text.length - 1) else text
+                        longText.toLong() - 1
+                    }
+                    KotlinBuiltIns.isShort(type) -> java.lang.Short.parseShort(text) - 1
+                    KotlinBuiltIns.isChar(type) -> text[0].toInt() - 1","I think it is better to replace character with character, either explicit e.g. `'z' - 1` or implicit `'y'`",I don't think we need to override `isApplicable
71,"@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class ConvertTwoComparisonsToRangeCheckIntention : SelfTargetingOffsetIndependentIntention<KtBinaryExpression>(KtBinaryExpression::class.java, ""Convert to range check"") {
+
+    private data class RangeExpressionData(val value: String, val min: String, val max: String)
+
+    override fun isApplicableTo(condition: KtBinaryExpression) = generateRangeExpressionData(condition) != null
+
+    override fun applyTo(condition: KtBinaryExpression, editor: Editor?) {
+        val rangeData = generateRangeExpressionData(condition) ?: return
+        condition.replace(KtPsiFactory(condition).createExpressionByPattern(""$0 in $1..$2"", rangeData.value, rangeData.min, rangeData.max))
+    }
+
+    private fun generateRangeExpressionData(condition: KtBinaryExpression): RangeExpressionData? {
+        if (condition.operationToken != KtTokens.ANDAND) return null
+        val firstCondition = condition.left as? KtBinaryExpression ?: return null
+        val secondCondition = condition.right as? KtBinaryExpression ?: return null
+        val firstOpToken = firstCondition.operationToken
+        val secondOpToken = secondCondition.operationToken
+        val firstLeft = firstCondition.left ?: return null
+        val firstRight = firstCondition.right ?: return null
+        val secondLeft = secondCondition.left ?: return null
+        val secondRight = secondCondition.right ?: return null
+
+        return when (firstOpToken) {
+            KtTokens.GTEQ, KtTokens.GT -> {
+                when (secondOpToken) {
+                    KtTokens.GTEQ, KtTokens.GT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstLeft, firstRight, secondLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstRight, secondRight, firstLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        else -> null
+                    }
+                    KtTokens.LTEQ, KtTokens.LT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstLeft, firstRight, secondRight, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstRight, secondLeft, firstLeft, minDecrementByOne = firstOpToken == KtTokens.GT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        else -> null
+                    }
+                    else -> null
+                }
+            }
+            KtTokens.LTEQ, KtTokens.LT -> {
+                when (secondOpToken) {
+                    KtTokens.GTEQ, KtTokens.GT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstLeft, secondRight, firstRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstRight, firstLeft, secondLeft, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.GT)
+                        else -> null
+                    }
+                    KtTokens.LTEQ, KtTokens.LT -> when {
+                        firstLeft !is KtConstantExpression && firstLeft.evaluatesTo(secondRight) ->
+                            generateRangeExpressionData(firstLeft, secondLeft, firstRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        firstRight !is KtConstantExpression && firstRight.evaluatesTo(secondLeft) ->
+                            generateRangeExpressionData(firstRight, firstLeft, secondRight, minDecrementByOne = firstOpToken == KtTokens.LT, maxDecrementByOne = secondOpToken == KtTokens.LT)
+                        else -> null
+                    }
+                    else -> null
+                }
+            }
+            else -> null
+        }
+    }
+
+    private fun generateRangeExpressionData(value: KtExpression, min: KtExpression, max: KtExpression, minDecrementByOne: Boolean = false, maxDecrementByOne: Boolean = false): RangeExpressionData? {
+        if (minDecrementByOne || maxDecrementByOne) {
+            val type = value.getType(value.analyze()) ?: return null
+            if (!KotlinBuiltIns.isInt(type) && !KotlinBuiltIns.isLong(type) && !KotlinBuiltIns.isShort(type) && !KotlinBuiltIns.isChar(type)) return null
+        }
+
+        val minText = if (minDecrementByOne) min.getDecrementByOneString() else min.text
+        val maxText = if (maxDecrementByOne) max.getDecrementByOneString() else max.text
+        return RangeExpressionData(value.text, minText ?: return null, maxText ?: return null)
+    }
+
+    private fun KtExpression.getDecrementByOneString(): String? {
+        val type = getType(analyze()) ?: return null
+
+        when (this) {
+            is KtConstantExpression -> {
+                val number: Number = when {
+                    KotlinBuiltIns.isInt(type) -> text.toInt() - 1
+                    KotlinBuiltIns.isLong(type) -> {
+                        val text = text
+                        val longText = if (text.endsWith(""l"") || text.endsWith(""L"")) text.substring(0, text.length - 1) else text
+                        longText.toLong() - 1
+                    }
+                    KotlinBuiltIns.isShort(type) -> java.lang.Short.parseShort(text) - 1
+                    KotlinBuiltIns.isChar(type) -> text[0].toInt() - 1
+                    else -> return null
+                }
+                return number.toString()
+            }
+            else -> return ""($text - 1)""","This is very controversial. What if expression is a `String`, for example?",I don't think we need to override `isApplicable
72,"@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: JavacWrapper) : JCElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { JCAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic",What about interface member classes? (they're always static as I know),I don't think you need to override `get()` here
73,"@@ -0,0 +1,124 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.intellij.psi.CommonClassNames
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.JavacClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class JCClass<out T : JCTree.JCClassDecl>(tree: T,
+                                          treePath: TreePath,
+                                          javac: JavacWrapper) : JCElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { JCAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = tree.modifiers.visibility",What about interface member classes? (they're always public as I know),I don't think you need to override `get()` here
74,"@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.android.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.*
+import com.intellij.psi.util.PsiTypesUtil
+import org.jetbrains.android.facet.AndroidFacet
+import org.jetbrains.kotlin.asJava.toLightClass
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors.SUPERTYPE_NOT_INITIALIZED
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction
+import org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.DescriptorToSourceUtils
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+class KotlinAndroidViewConstructorFix(element: KtSuperTypeEntry) : KotlinQuickFixAction<KtSuperTypeEntry>(element) {
+
+    override fun getText() = ""Add Android View constructors using '@JvmOverloads'""
+    override fun getFamilyName() = text
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (AndroidFacet.getInstance(file) == null) return false
+        return super.isAvailable(project, editor, file)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+        val ktClass = element.containingClass() ?: return
+
+        val factory = KtPsiFactory(element)
+
+        val newPrimaryConstructor = factory.createDeclarationByPattern<KtClass>(
+                ""class A constructor(\n $0, $1, $2\n)"",
+                factory.createParameter(""context: android.content.Context""),
+                factory.createParameter(""attrs: android.util.AttributeSet? = null""),
+                factory.createParameter(""defStyleAttr: Int = 0"")
+        ).primaryConstructor!!",i think `?: return` will be better,I don't think we need these imports.
75,"@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.android.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.*
+import com.intellij.psi.util.PsiTypesUtil
+import org.jetbrains.android.facet.AndroidFacet
+import org.jetbrains.kotlin.asJava.toLightClass
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors.SUPERTYPE_NOT_INITIALIZED
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction
+import org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.DescriptorToSourceUtils
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+class KotlinAndroidViewConstructorFix(element: KtSuperTypeEntry) : KotlinQuickFixAction<KtSuperTypeEntry>(element) {
+
+    override fun getText() = ""Add Android View constructors using '@JvmOverloads'""
+    override fun getFamilyName() = text
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (AndroidFacet.getInstance(file) == null) return false
+        return super.isAvailable(project, editor, file)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+        val ktClass = element.containingClass() ?: return
+
+        val factory = KtPsiFactory(element)
+
+        val newPrimaryConstructor = factory.createDeclarationByPattern<KtClass>(
+                ""class A constructor(\n $0, $1, $2\n)"",
+                factory.createParameter(""context: android.content.Context""),
+                factory.createParameter(""attrs: android.util.AttributeSet? = null""),
+                factory.createParameter(""defStyleAttr: Int = 0"")
+        ).primaryConstructor!!
+
+        val primaryConstructor = ktClass.createPrimaryConstructorIfAbsent().replaced(newPrimaryConstructor)
+        ShortenReferences.DEFAULT.process(primaryConstructor.valueParameterList!!)",`primaryConstructor.valueParameterList?.apply { ShortenReferences.DEFAULT.process(this) }`,I don't think we need these imports.
76,"@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.android.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.*
+import com.intellij.psi.util.PsiTypesUtil
+import org.jetbrains.android.facet.AndroidFacet
+import org.jetbrains.kotlin.asJava.toLightClass
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors.SUPERTYPE_NOT_INITIALIZED
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction
+import org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.DescriptorToSourceUtils
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+class KotlinAndroidViewConstructorFix(element: KtSuperTypeEntry) : KotlinQuickFixAction<KtSuperTypeEntry>(element) {
+
+    override fun getText() = ""Add Android View constructors using '@JvmOverloads'""
+    override fun getFamilyName() = text
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (AndroidFacet.getInstance(file) == null) return false
+        return super.isAvailable(project, editor, file)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+        val ktClass = element.containingClass() ?: return
+
+        val factory = KtPsiFactory(element)
+
+        val newPrimaryConstructor = factory.createDeclarationByPattern<KtClass>(
+                ""class A constructor(\n $0, $1, $2\n)"",
+                factory.createParameter(""context: android.content.Context""),
+                factory.createParameter(""attrs: android.util.AttributeSet? = null""),
+                factory.createParameter(""defStyleAttr: Int = 0"")
+        ).primaryConstructor!!
+
+        val primaryConstructor = ktClass.createPrimaryConstructorIfAbsent().replaced(newPrimaryConstructor)
+        ShortenReferences.DEFAULT.process(primaryConstructor.valueParameterList!!)
+
+        primaryConstructor.addAnnotation(fqNameAnnotation, whiteSpaceText = "" "")
+
+        element.replace(factory.createSuperTypeCallEntry(element.text + ""(context, attrs, defStyleAttr)""))
+    }
+
+    companion object Factory : KotlinSingleIntentionActionFactory() {
+
+        private val fqNameAnnotation = FqName(""kotlin.jvm.JvmOverloads"")
+
+        private val requireConstructorParameterTypes = listOf(","I think we may check only for a presence of the third one `""android.content.Context"", ""android.util.AttributeSet"", ""int""`, since we are using only it, if I understood correctly",I don't think we need these imports.
77,"@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.android.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.*
+import com.intellij.psi.util.PsiTypesUtil
+import org.jetbrains.android.facet.AndroidFacet
+import org.jetbrains.kotlin.asJava.toLightClass
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors.SUPERTYPE_NOT_INITIALIZED
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction
+import org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.DescriptorToSourceUtils
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+class KotlinAndroidViewConstructorFix(element: KtSuperTypeEntry) : KotlinQuickFixAction<KtSuperTypeEntry>(element) {
+
+    override fun getText() = ""Add Android View constructors using '@JvmOverloads'""
+    override fun getFamilyName() = text
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (AndroidFacet.getInstance(file) == null) return false
+        return super.isAvailable(project, editor, file)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+        val ktClass = element.containingClass() ?: return
+
+        val factory = KtPsiFactory(element)
+
+        val newPrimaryConstructor = factory.createDeclarationByPattern<KtClass>(
+                ""class A constructor(\n $0, $1, $2\n)"",
+                factory.createParameter(""context: android.content.Context""),
+                factory.createParameter(""attrs: android.util.AttributeSet? = null""),
+                factory.createParameter(""defStyleAttr: Int = 0"")
+        ).primaryConstructor!!
+
+        val primaryConstructor = ktClass.createPrimaryConstructorIfAbsent().replaced(newPrimaryConstructor)
+        ShortenReferences.DEFAULT.process(primaryConstructor.valueParameterList!!)
+
+        primaryConstructor.addAnnotation(fqNameAnnotation, whiteSpaceText = "" "")
+
+        element.replace(factory.createSuperTypeCallEntry(element.text + ""(context, attrs, defStyleAttr)""))
+    }
+
+    companion object Factory : KotlinSingleIntentionActionFactory() {
+
+        private val fqNameAnnotation = FqName(""kotlin.jvm.JvmOverloads"")
+
+        private val requireConstructorParameterTypes = listOf(
+                listOf(""android.content.Context""),
+                listOf(""android.content.Context"", ""android.util.AttributeSet""),
+                listOf(""android.content.Context"", ""android.util.AttributeSet"", ""int"")
+        )
+
+        override fun createAction(diagnostic: Diagnostic): IntentionAction? {
+            val superTypeEntry = SUPERTYPE_NOT_INITIALIZED.cast(diagnostic).psiElement
+
+            val ktClass = superTypeEntry.containingClass() ?: return null
+            if (ktClass.primaryConstructor != null) return null
+
+            val context = superTypeEntry.analyze()
+            val type = superTypeEntry.typeReference?.let { context[BindingContext.TYPE, it] } ?: return null
+
+            if (!type.isAndroidView() && type.supertypes().none { it.isAndroidView() }) return null
+
+            var declaration = type.getDeclaration()
+
+            if (declaration is KtClass) {
+                declaration = declaration.toLightClass()","I think it could be implemented without light classes, they are pretty heavy and should be avoided if possible 
Try to get everything you need from descriptor
```Kotlin
val classDescriptor = type.constructor.declarationDescriptor as? ClassDescriptor ?: return null
val constructorParameters = classDescriptor.constructors.forEach {
    it.valueParameters... // some checking stuff
}
```",I don't think we need these imports.
78,"@@ -0,0 +1,13 @@","What is this file? Is it for manual testing?
",Why is this needed?
79,"@@ -0,0 +1,132 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.jvm.compiler
+
+import com.intellij.openapi.Disposable
+import org.jetbrains.kotlin.cli.jvm.compiler.EnvironmentConfigFiles
+import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
+import org.jetbrains.kotlin.config.JVMConfigurationKeys
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.renderer.*
+import org.jetbrains.kotlin.resolve.lazy.JvmResolveUtil
+import org.jetbrains.kotlin.test.ConfigurationKind
+import org.jetbrains.kotlin.test.KotlinTestUtils
+import org.jetbrains.kotlin.test.TestCaseWithTmpdir
+import org.jetbrains.kotlin.test.TestJdkKind
+import org.junit.Assert
+
+import java.io.File
+import java.io.IOException
+import java.lang.annotation.Retention
+
+import org.jetbrains.kotlin.test.KotlinTestUtils.*
+import org.jetbrains.kotlin.test.util.RecursiveDescriptorComparator.validateAndCompareDescriptorWithFile
+
+abstract class AbstractCompileJavaAgainstKotlinTest : TestCaseWithTmpdir() {
+
+    @Throws(IOException::class)
+    protected fun doTest(ktFilePath: String) {
+        Assert.assertTrue(ktFilePath.endsWith("".kt""))
+        val ktFile = File(ktFilePath)
+        val javaFile = File(ktFilePath.replaceFirst(""\\.kt$"".toRegex(), "".java""))
+
+        val javaErrorFile = File(ktFilePath.replaceFirst(""\\.kt$"".toRegex(), "".javaerr.txt""))
+
+        val out = File(tmpdir, ""out"")
+
+        val useJavac = this::class.java.name.contains(""WithJavac"")",This is too hacky. We normally use a bunch of protected methods to inject custom behavior in abstract test class,We don't use wildcard imports.
80,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())","Ditto, replace with `Name.identifier`",Please add the copyright header to this file.
81,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract","Note that there's a corner case of enums with abstract members, which are considered abstract in Java but do not require (and even prohibit) the `abstract` keyword. Please add a test and ensure that it works",Please add the copyright header to this file.
82,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic",Also please add a test on a nested enum (enum is never inner in Java),Please add the copyright header to this file.
83,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic","Not sure if `isInterface` returns true for annotations, please check and call `isAnnotation` if needed (a test would be nice in any case)",Please add the copyright header to this file.
84,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = if (outerClass?.isInterface ?: false) PUBLIC else tree.modifiers.visibility",Also test annotations in addition to interfaces here,Please add the copyright header to this file.
85,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = if (outerClass?.isInterface ?: false) PUBLIC else tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { TreeBasedTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes",There's also an implicit supertype `java.lang.annotation.Annotation` for all annotations,Please add the copyright header to this file.
86,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = if (outerClass?.isInterface ?: false) PUBLIC else tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { TreeBasedTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCTypeApply -> TreeBasedClassifierTypeWithTypeArgument(this, TreePath(treePath, this), javac)
+                this is JCTree.JCExpression -> TreeBasedClassifierTypeWithoutTypeArgument(this, TreePath(treePath, this), javac)
+                else -> null
+            }
+
+            if (isEnum) {
+                (javac.findClass(FqName(""java.lang.Enum"")) as? SymbolBasedClass<*>)
+                        ?.let { SymbolBasedType.create(it.element.asType(), javac) as? JavaClassifierType }
+                        ?.let { add(it) }
+            }
+
+            tree.implementing?.map { it.mapToJavaClassifierType() }?.filterNotNull()?.let(this::addAll)",`map` + `filterNotNull` = `mapNotNull`,Please add the copyright header to this file.
87,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = if (outerClass?.isInterface ?: false) PUBLIC else tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { TreeBasedTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCTypeApply -> TreeBasedClassifierTypeWithTypeArgument(this, TreePath(treePath, this), javac)
+                this is JCTree.JCExpression -> TreeBasedClassifierTypeWithoutTypeArgument(this, TreePath(treePath, this), javac)
+                else -> null
+            }
+
+            if (isEnum) {
+                (javac.findClass(FqName(""java.lang.Enum"")) as? SymbolBasedClass<*>)
+                        ?.let { SymbolBasedType.create(it.element.asType(), javac) as? JavaClassifierType }
+                        ?.let { add(it) }
+            }
+
+            tree.implementing?.map { it.mapToJavaClassifierType() }?.filterNotNull()?.let(this::addAll)
+            tree.extending?.let { it.mapToJavaClassifierType()?.let(this::add) }
+
+            if (isEmpty()) {
+                javac.JAVA_LANG_OBJECT?.let { add(SymbolBasedClassifierType(it.element.asType(), javac)) }
+            }
+        }
+
+    val innerClasses by lazy {",Please also call `.associateBy { it.name }` to make this a map from name to class. This will allow `innerClassNames` and `findInnerClass` to work in O(1),Please add the copyright header to this file.
88,"@@ -0,0 +1,134 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.tree.TreeInfo
+import org.jetbrains.kotlin.descriptors.Visibilities.PUBLIC
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClassifierType
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedType
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedClass<out T : JCTree.JCClassDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaClass {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.simpleName.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.find { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = (outerClass?.isInterface ?: false) || tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility
+        get() = if (outerClass?.isInterface ?: false) PUBLIC else tree.modifiers.visibility
+
+    override val typeParameters
+        get() = tree.typeParameters.map { TreeBasedTypeParameter(it, TreePath(treePath, it), javac) }
+
+    override val fqName = treePath.reversed()
+            .joinToString(separator = ""."") {
+                (it as? JCTree.JCCompilationUnit)?.packageName?.toString()
+                ?: (it as JCTree.JCClassDecl).name
+            }
+            .let(::FqName)
+
+    override val supertypes
+        get() = arrayListOf<JavaClassifierType>().apply {
+            fun JCTree.mapToJavaClassifierType() = when {
+                this is JCTree.JCTypeApply -> TreeBasedClassifierTypeWithTypeArgument(this, TreePath(treePath, this), javac)
+                this is JCTree.JCExpression -> TreeBasedClassifierTypeWithoutTypeArgument(this, TreePath(treePath, this), javac)
+                else -> null
+            }
+
+            if (isEnum) {
+                (javac.findClass(FqName(""java.lang.Enum"")) as? SymbolBasedClass<*>)
+                        ?.let { SymbolBasedType.create(it.element.asType(), javac) as? JavaClassifierType }
+                        ?.let { add(it) }
+            }
+
+            tree.implementing?.map { it.mapToJavaClassifierType() }?.filterNotNull()?.let(this::addAll)
+            tree.extending?.let { it.mapToJavaClassifierType()?.let(this::add) }
+
+            if (isEmpty()) {
+                javac.JAVA_LANG_OBJECT?.let { add(SymbolBasedClassifierType(it.element.asType(), javac)) }
+            }
+        }
+
+    val innerClasses by lazy {
+        tree.members
+                .filterIsInstance(JCTree.JCClassDecl::class.java)
+                .map { TreeBasedClass(it, TreePath(treePath, it), javac) }
+    }
+
+    override val outerClass by lazy {
+        (treePath.parentPath.leaf as? JCTree.JCClassDecl)?.let { TreeBasedClass(it, treePath.parentPath, javac) }
+    }
+
+    override val isInterface
+        get() = tree.modifiers.flags and Flags.INTERFACE.toLong() != 0L
+
+    override val isAnnotationType
+        get() = tree.modifiers.flags and Flags.ANNOTATION.toLong() != 0L
+
+    override val isEnum
+        get() = tree.modifiers.flags and Flags.ENUM.toLong() != 0L
+
+    override val lightClassOriginKind = null",`get() = null`,Please add the copyright header to this file.
89,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }","Five constructors for non-API constructor seems to be too much. Maybe provide default values manually on call sites?
",Please don't use wildcard imports.
90,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;","Use ArrayList instead of array. This won't take much extra memory, but will simplify code.
",Please don't use wildcard imports.
91,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {","I don't understand what this method does.
",Please don't use wildcard imports.
92,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options","What does mean ""applied""?
",Please don't use wildcard imports.
93,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];","Use list, and `Collections.reverse()` afterwards.
",Please don't use wildcard imports.
94,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {","We already have class called `TypeSubstitution` in Kotlin codebase, so, this name is too confusing.
",Please don't use wildcard imports.
95,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+","Make popup look the same as for Java, see screenshot:
![Screen Shot 2013-04-24 at 18 17 37](https://f.cloud.github.com/assets/145855/430367/d8c2a7be-ae66-11e2-8886-ee07159d98d6.png)
",Please don't use wildcard imports.
96,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);","Why not use TypeCandidate instances as list elements? This would make it possible to avoid having String  TypeCandidate map.
",Please don't use wildcard imports.
97,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();","Why not check `getSelectedValue()` for null, if we access it anyway?
",Please don't use wildcard imports.
98,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {","`doInvoke` is not a good name, because it doesn't explain how it differs from simple `invoke`. Rename it to `addFunctionToSelectedOwner` or something like that.
",Please don't use wildcard imports.
99,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);","It's class declaration, not type declaration. Please rename.
",Please don't use wildcard imports.
100,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {","Checking for null is redundant when checking for `instanceof`.
",Please don't use wildcard imports.
101,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();","This code relies on implementation details. What if actual type of `ownerClassDescriptor` is `LazyClassDescriptor`? Replace it with `receiverType.getMemberScope()`
",Please don't use wildcard imports.
102,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {","`project` parameter is redundant, see above.
",Please don't use wildcard imports.
103,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);","Return immediately to avoid reassignment.
",Please don't use wildcard imports.
104,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);","Return immediately to avoid reassignment.
",Please don't use wildcard imports.
105,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {","Don't use such names, please. Even if parameter is not used.
",Please don't use wildcard imports.
106,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {","I don't understand what does this method do, but I feel that it can be replaced with using already existing `TypeSubstitutor` mechanism. Please check it.
",Please don't use wildcard imports.
107,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {
+        switch (variance) {
+            case INVARIANT:
+                // for invariant, can replace only when they're equal
+                if (type.equals(substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case IN_VARIANCE:
+                // for covariant (e.g. function parameter), can replace type with any of its supertypes","You seem to mix up ""co"" and ""contra"" prefixes.
",Please don't use wildcard imports.
108,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {
+        switch (variance) {
+            case INVARIANT:
+                // for invariant, can replace only when they're equal
+                if (type.equals(substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case IN_VARIANCE:
+                // for covariant (e.g. function parameter), can replace type with any of its supertypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(type, substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case OUT_VARIANCE:
+                // for contravariant (e.g. function return value), can replace type with any of its subtypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(substitution.getForType(), type)) {
+                    return substitution.getByType();
+                }
+                break;
+        }
+
+        List<TypeProjection> newArguments = new ArrayList<TypeProjection>();
+        List<TypeParameterDescriptor> typeParameters = type.getConstructor().getParameters();
+        int i = 0;
+        for (TypeProjection projection : type.getArguments()) {
+            TypeParameterDescriptor typeParameter = typeParameters.get(i);
+            JetType newArgument = substituteType(projection.getType(), substitution, typeParameter.getVariance());
+            newArguments.add(new TypeProjection(Variance.INVARIANT, newArgument));
+            i++;
+        }
+        return new JetTypeImpl(type.getAnnotations(), type.getConstructor(),
+                               type.isNullable(), newArguments, type.getMemberScope());
+    }
+
+    private static boolean containsType(JetType outer, JetType inner) {
+        if (outer.equals(inner)) {
+            return true;
+        }
+
+        for (TypeProjection projection : outer.getArguments()) {
+            if (containsType(projection.getType(), inner)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @NotNull
+    private static String renderDescriptor(
+            @NotNull DeclarationDescriptor declarationDescriptor,
+            @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap,
+            boolean fq
+    ) {
+        if (declarationDescriptor instanceof TypeParameterDescriptor) {
+            String replacement = typeParameterNameMap.get(declarationDescriptor);
+            return replacement == null ? declarationDescriptor.getName().getName() : replacement;
+        } else {
+            return fq ? DescriptorUtils.getFQName(declarationDescriptor).getFqName() : declarationDescriptor.getName().getName();
+        }
+    }
+
+    @NotNull
+    private static String renderDescriptor(@NotNull DeclarationDescriptor declarationDescriptor, boolean fq) {
+        return renderDescriptor(declarationDescriptor, Collections.<TypeParameterDescriptor, String>emptyMap(), fq);
+    }
+
+    private static String renderType(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap, boolean fq) {
+        List<TypeProjection> projections = type.getArguments();
+        DeclarationDescriptor declarationDescriptor = type.getConstructor().getDeclarationDescriptor();
+        assert declarationDescriptor != null;
+        if (projections.isEmpty()) {
+            return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq);
+        }
+
+        List<String> arguments = new ArrayList<String>();
+        for (TypeProjection projection : projections) {
+            arguments.add(renderType(projection.getType(), typeParameterNameMap, fq));
+        }
+        return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq) + ""<"" + StringUtil.join(arguments, "", "") + "">"";
+    }
+
+    @NotNull
+    private static String renderTypeShort(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, false);
+    }
+
+    @NotNull
+    private static String renderTypeLong(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, true);
+    }
+
+    @NotNull
+    private static TypeParameterDescriptor[] getTypeParameterNamesNotInScope(
+            @NotNull Collection<? extends TypeParameterDescriptor> typeParameters,
+            @NotNull JetScope scope
+    ) {
+        List<TypeParameterDescriptor> typeParameterNames = new ArrayList<TypeParameterDescriptor>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            ClassifierDescriptor classifier = scope.getClassifier(typeParameter.getName());
+            if (classifier == null || !classifier.equals(typeParameter)) {
+                typeParameterNames.add(typeParameter);
+            }
+        }
+        return typeParameterNames.toArray(new TypeParameterDescriptor[typeParameterNames.size()]);
+    }
+
+    @NotNull
+    private static Set<TypeParameterDescriptor> getTypeParametersInType(@NotNull JetType type) {
+        Set<TypeParameterDescriptor> typeParameters = new LinkedHashSet<TypeParameterDescriptor>();
+        List<TypeProjection> arguments = type.getArguments();
+        if (arguments.isEmpty()) {
+            ClassifierDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();
+            if (descriptor instanceof TypeParameterDescriptor) {
+                typeParameters.add((TypeParameterDescriptor) descriptor);
+            }
+        } else {
+            for (TypeProjection projection : arguments) {
+                typeParameters.addAll(getTypeParametersInType(projection.getType()));
+            }
+        }
+        return typeParameters;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames) {","I think, it's better to merge this and next method (with `@Nullable` scope)
Add comment, that for Foo name from parameter it returns itself, if it is available, and Foo1, Foo2, .. if it's not.
",Please don't use wildcard imports.
109,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {
+        switch (variance) {
+            case INVARIANT:
+                // for invariant, can replace only when they're equal
+                if (type.equals(substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case IN_VARIANCE:
+                // for covariant (e.g. function parameter), can replace type with any of its supertypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(type, substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case OUT_VARIANCE:
+                // for contravariant (e.g. function return value), can replace type with any of its subtypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(substitution.getForType(), type)) {
+                    return substitution.getByType();
+                }
+                break;
+        }
+
+        List<TypeProjection> newArguments = new ArrayList<TypeProjection>();
+        List<TypeParameterDescriptor> typeParameters = type.getConstructor().getParameters();
+        int i = 0;
+        for (TypeProjection projection : type.getArguments()) {
+            TypeParameterDescriptor typeParameter = typeParameters.get(i);
+            JetType newArgument = substituteType(projection.getType(), substitution, typeParameter.getVariance());
+            newArguments.add(new TypeProjection(Variance.INVARIANT, newArgument));
+            i++;
+        }
+        return new JetTypeImpl(type.getAnnotations(), type.getConstructor(),
+                               type.isNullable(), newArguments, type.getMemberScope());
+    }
+
+    private static boolean containsType(JetType outer, JetType inner) {
+        if (outer.equals(inner)) {
+            return true;
+        }
+
+        for (TypeProjection projection : outer.getArguments()) {
+            if (containsType(projection.getType(), inner)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @NotNull
+    private static String renderDescriptor(
+            @NotNull DeclarationDescriptor declarationDescriptor,
+            @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap,
+            boolean fq
+    ) {
+        if (declarationDescriptor instanceof TypeParameterDescriptor) {
+            String replacement = typeParameterNameMap.get(declarationDescriptor);
+            return replacement == null ? declarationDescriptor.getName().getName() : replacement;
+        } else {
+            return fq ? DescriptorUtils.getFQName(declarationDescriptor).getFqName() : declarationDescriptor.getName().getName();
+        }
+    }
+
+    @NotNull
+    private static String renderDescriptor(@NotNull DeclarationDescriptor declarationDescriptor, boolean fq) {
+        return renderDescriptor(declarationDescriptor, Collections.<TypeParameterDescriptor, String>emptyMap(), fq);
+    }
+
+    private static String renderType(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap, boolean fq) {
+        List<TypeProjection> projections = type.getArguments();
+        DeclarationDescriptor declarationDescriptor = type.getConstructor().getDeclarationDescriptor();
+        assert declarationDescriptor != null;
+        if (projections.isEmpty()) {
+            return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq);
+        }
+
+        List<String> arguments = new ArrayList<String>();
+        for (TypeProjection projection : projections) {
+            arguments.add(renderType(projection.getType(), typeParameterNameMap, fq));
+        }
+        return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq) + ""<"" + StringUtil.join(arguments, "", "") + "">"";
+    }
+
+    @NotNull
+    private static String renderTypeShort(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, false);
+    }
+
+    @NotNull
+    private static String renderTypeLong(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, true);
+    }
+
+    @NotNull
+    private static TypeParameterDescriptor[] getTypeParameterNamesNotInScope(
+            @NotNull Collection<? extends TypeParameterDescriptor> typeParameters,
+            @NotNull JetScope scope
+    ) {
+        List<TypeParameterDescriptor> typeParameterNames = new ArrayList<TypeParameterDescriptor>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            ClassifierDescriptor classifier = scope.getClassifier(typeParameter.getName());
+            if (classifier == null || !classifier.equals(typeParameter)) {
+                typeParameterNames.add(typeParameter);
+            }
+        }
+        return typeParameterNames.toArray(new TypeParameterDescriptor[typeParameterNames.size()]);
+    }
+
+    @NotNull
+    private static Set<TypeParameterDescriptor> getTypeParametersInType(@NotNull JetType type) {
+        Set<TypeParameterDescriptor> typeParameters = new LinkedHashSet<TypeParameterDescriptor>();
+        List<TypeProjection> arguments = type.getArguments();
+        if (arguments.isEmpty()) {
+            ClassifierDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();
+            if (descriptor instanceof TypeParameterDescriptor) {
+                typeParameters.add((TypeParameterDescriptor) descriptor);
+            }
+        } else {
+            for (TypeProjection projection : arguments) {
+                typeParameters.addAll(getTypeParametersInType(projection.getType()));
+            }
+        }
+        return typeParameters;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames) {
+        if (existingNames.contains(name)) {
+            int j = 1;
+            while (existingNames.contains(name + j)) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames, @NotNull JetScope scope) {
+        if (existingNames.contains(name) || scope.getClassifier(Name.identifier(name)) != null) {
+            int j = 1;
+            while (existingNames.contains(name + j) || scope.getClassifier(Name.identifier(name + j)) != null) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static JetType[] guessTypeForExpression(@NotNull JetExpression expr, @NotNull BindingContext context) {","If this method returns several types, maybe it should be named `guessTypes...`?

The method is very complex.
- Reassigning local variables is usually a bad style, because it makes code harder to comprehend and refactor.
- Combination of reassignments and deep if-else-if is even worse.
  I offer extracting method guessTypesForDeclaration and use it immediately instead of assigning to declaration. This will allow removing reassigned variable and make each `if` end with `return`, and `else`s will be unnecessary.
",Please don't use wildcard imports.
110,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {
+        switch (variance) {
+            case INVARIANT:
+                // for invariant, can replace only when they're equal
+                if (type.equals(substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case IN_VARIANCE:
+                // for covariant (e.g. function parameter), can replace type with any of its supertypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(type, substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case OUT_VARIANCE:
+                // for contravariant (e.g. function return value), can replace type with any of its subtypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(substitution.getForType(), type)) {
+                    return substitution.getByType();
+                }
+                break;
+        }
+
+        List<TypeProjection> newArguments = new ArrayList<TypeProjection>();
+        List<TypeParameterDescriptor> typeParameters = type.getConstructor().getParameters();
+        int i = 0;
+        for (TypeProjection projection : type.getArguments()) {
+            TypeParameterDescriptor typeParameter = typeParameters.get(i);
+            JetType newArgument = substituteType(projection.getType(), substitution, typeParameter.getVariance());
+            newArguments.add(new TypeProjection(Variance.INVARIANT, newArgument));
+            i++;
+        }
+        return new JetTypeImpl(type.getAnnotations(), type.getConstructor(),
+                               type.isNullable(), newArguments, type.getMemberScope());
+    }
+
+    private static boolean containsType(JetType outer, JetType inner) {
+        if (outer.equals(inner)) {
+            return true;
+        }
+
+        for (TypeProjection projection : outer.getArguments()) {
+            if (containsType(projection.getType(), inner)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @NotNull
+    private static String renderDescriptor(
+            @NotNull DeclarationDescriptor declarationDescriptor,
+            @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap,
+            boolean fq
+    ) {
+        if (declarationDescriptor instanceof TypeParameterDescriptor) {
+            String replacement = typeParameterNameMap.get(declarationDescriptor);
+            return replacement == null ? declarationDescriptor.getName().getName() : replacement;
+        } else {
+            return fq ? DescriptorUtils.getFQName(declarationDescriptor).getFqName() : declarationDescriptor.getName().getName();
+        }
+    }
+
+    @NotNull
+    private static String renderDescriptor(@NotNull DeclarationDescriptor declarationDescriptor, boolean fq) {
+        return renderDescriptor(declarationDescriptor, Collections.<TypeParameterDescriptor, String>emptyMap(), fq);
+    }
+
+    private static String renderType(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap, boolean fq) {
+        List<TypeProjection> projections = type.getArguments();
+        DeclarationDescriptor declarationDescriptor = type.getConstructor().getDeclarationDescriptor();
+        assert declarationDescriptor != null;
+        if (projections.isEmpty()) {
+            return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq);
+        }
+
+        List<String> arguments = new ArrayList<String>();
+        for (TypeProjection projection : projections) {
+            arguments.add(renderType(projection.getType(), typeParameterNameMap, fq));
+        }
+        return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq) + ""<"" + StringUtil.join(arguments, "", "") + "">"";
+    }
+
+    @NotNull
+    private static String renderTypeShort(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, false);
+    }
+
+    @NotNull
+    private static String renderTypeLong(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, true);
+    }
+
+    @NotNull
+    private static TypeParameterDescriptor[] getTypeParameterNamesNotInScope(
+            @NotNull Collection<? extends TypeParameterDescriptor> typeParameters,
+            @NotNull JetScope scope
+    ) {
+        List<TypeParameterDescriptor> typeParameterNames = new ArrayList<TypeParameterDescriptor>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            ClassifierDescriptor classifier = scope.getClassifier(typeParameter.getName());
+            if (classifier == null || !classifier.equals(typeParameter)) {
+                typeParameterNames.add(typeParameter);
+            }
+        }
+        return typeParameterNames.toArray(new TypeParameterDescriptor[typeParameterNames.size()]);
+    }
+
+    @NotNull
+    private static Set<TypeParameterDescriptor> getTypeParametersInType(@NotNull JetType type) {
+        Set<TypeParameterDescriptor> typeParameters = new LinkedHashSet<TypeParameterDescriptor>();
+        List<TypeProjection> arguments = type.getArguments();
+        if (arguments.isEmpty()) {
+            ClassifierDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();
+            if (descriptor instanceof TypeParameterDescriptor) {
+                typeParameters.add((TypeParameterDescriptor) descriptor);
+            }
+        } else {
+            for (TypeProjection projection : arguments) {
+                typeParameters.addAll(getTypeParametersInType(projection.getType()));
+            }
+        }
+        return typeParameters;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames) {
+        if (existingNames.contains(name)) {
+            int j = 1;
+            while (existingNames.contains(name + j)) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames, @NotNull JetScope scope) {
+        if (existingNames.contains(name) || scope.getClassifier(Name.identifier(name)) != null) {
+            int j = 1;
+            while (existingNames.contains(name + j) || scope.getClassifier(Name.identifier(name + j)) != null) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static JetType[] guessTypeForExpression(@NotNull JetExpression expr, @NotNull BindingContext context) {
+        JetType type = context.get(BindingContext.EXPRESSION_TYPE, expr);
+        JetNamedDeclaration declaration = null;
+
+        // if we know the actual type of the expression
+        if (type != null) {
+            return new JetType[] {type};
+        }
+
+        // expression has an expected type
+        else if ((type = context.get(BindingContext.EXPECTED_EXPRESSION_TYPE, expr)) != null) {
+            return new JetType[] {type};
+        }
+
+        // expression itself is a type assertion
+        else if (expr instanceof JetTypeConstraint) { // expression itself is a type assertion
+            JetTypeConstraint constraint = (JetTypeConstraint) expr;
+            return new JetType[] {context.get(BindingContext.TYPE, constraint.getBoundTypeReference())};
+        }
+
+        // expression is on the left side of a type assertion
+        else if (expr.getParent() instanceof JetTypeConstraint) {
+            JetTypeConstraint constraint = (JetTypeConstraint) expr.getParent();
+            return new JetType[] {context.get(BindingContext.TYPE, constraint.getBoundTypeReference())};
+        }
+
+        // expression is on the lhs of a multi-declaration
+        else if (expr instanceof JetMultiDeclarationEntry) {
+            JetMultiDeclarationEntry entry = (JetMultiDeclarationEntry) expr;
+            JetTypeReference typeRef = entry.getTypeRef();
+            if (typeRef != null) { // and has a specified type
+                return new JetType[] {context.get(BindingContext.TYPE, typeRef)};","Why not just guess by declaration immediately, without checking `BindingContext.TYPE`? Wouldn't it be enough?
",Please don't use wildcard imports.
111,"@@ -0,0 +1,1391 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.lookup.LookupElement;
+import com.intellij.codeInsight.lookup.LookupElementBuilder;
+import com.intellij.codeInsight.template.*;
+import com.intellij.codeInsight.template.impl.TemplateImpl;
+import com.intellij.codeInsight.template.impl.Variable;
+import com.intellij.ide.fileTemplates.FileTemplate;
+import com.intellij.ide.fileTemplates.FileTemplateManager;
+import com.intellij.ide.util.PsiElementListCellRenderer;
+import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.CommandProcessor;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.progress.ProcessCanceledException;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.ui.popup.PopupChooserBuilder;
+import com.intellij.openapi.util.TextRange;
+import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.psi.search.SearchScope;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.psi.SearchUtils;
+import com.intellij.ui.components.JBList;
+import com.intellij.util.ArrayUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NonNls;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.descriptors.impl.MutableClassDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.BindingContextUtils;
+import org.jetbrains.jet.lang.resolve.DescriptorUtils;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.resolve.scopes.JetScope;
+import org.jetbrains.jet.lang.types.*;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.codeInsight.ReferenceToClassesShortening;
+import org.jetbrains.jet.plugin.presentation.JetLightClassListCellRenderer;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+import org.jetbrains.jet.plugin.refactoring.JetNameSuggester;
+import org.jetbrains.jet.plugin.refactoring.JetNameValidator;
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import javax.swing.*;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CreateMethodFromUsageFix extends CreateFromUsageFixBase {
+    private static final String TYPE_PARAMETER_LIST_VARIABLE_NAME = ""typeParameterList"";
+    private static final String TEMPLATE_FROM_USAGE_METHOD_BODY = ""New Kotlin Method Body.kt"";
+    private static final Pattern COMPONENT_FUNCTION_PATTERN = Pattern.compile(""^component(\\d+)$"");
+
+    /**
+     * Represents a single choice for a type (e.g. parameter type or return type).
+     */
+    private static class TypeCandidate {
+        private final JetType type;
+        private final TypeParameterDescriptor[] typeParameters;
+        private String renderedType;
+        private String[] typeParameterNames;
+
+        public TypeCandidate(@NotNull JetType type) {
+            this.type = type;
+            Set<TypeParameterDescriptor> typeParametersInType = getTypeParametersInType(type);
+            typeParameters = typeParametersInType.toArray(new TypeParameterDescriptor[typeParametersInType.size()]);
+            renderedType = renderTypeShort(type, Collections.<TypeParameterDescriptor, String>emptyMap());
+        }
+
+        public TypeCandidate(@NotNull JetType type, @NotNull JetScope scope) {
+            this.type = type;
+            typeParameters = getTypeParameterNamesNotInScope(getTypeParametersInType(type), scope);
+        }
+
+        public void render(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            renderedType = renderTypeShort(type, typeParameterNameMap);
+            typeParameterNames = new String[typeParameters.length];
+            int i = 0;
+            for (TypeParameterDescriptor typeParameter : typeParameters) {
+                typeParameterNames[i] = typeParameterNameMap.get(typeParameter);
+                i++;
+            }
+        }
+
+        @NotNull JetType getType() {
+            return type;
+        }
+
+        @NotNull
+        public String getRenderedType() {
+            assert renderedType != null : ""call render() first"";
+            return renderedType;
+        }
+
+        @NotNull
+        public String[] getTypeParameterNames() {
+            assert typeParameterNames != null : ""call render() first"";
+            return typeParameterNames;
+        }
+
+        @NotNull
+        public TypeParameterDescriptor[] getTypeParameters() {
+            return typeParameters;
+        }
+    }
+
+    /**
+     * Represents a concrete type or a set of types yet to be inferred from an expression.
+     */
+    private static class TypeOrExpressionThereof {
+        private final JetExpression expressionOfType;
+        private final JetType type;
+        private final Variance variance;
+        private TypeCandidate[] typeCandidates;
+        private String[] cachedNameCandidatesFromExpression;
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType) {
+            this(expressionOfType, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetExpression expressionOfType, Variance variance) {
+            this(expressionOfType, null, variance);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type) {
+            this(type, Variance.IN_VARIANCE);
+        }
+
+        public TypeOrExpressionThereof(@NotNull JetType type, Variance variance) {
+            this(null, type, variance);
+        }
+
+        private TypeOrExpressionThereof(@Nullable JetExpression expressionOfType, @Nullable JetType type, Variance variance) {
+            this.expressionOfType = expressionOfType;
+            this.type = type;
+            this.variance = variance;
+        }
+
+        public boolean isType() {
+            return this.type != null;
+        }
+
+        @NotNull
+        public JetType getType() {
+            assert this.type != null;
+            return this.type;
+        }
+
+        @NotNull
+        private List<JetType> getPossibleTypes(BindingContext context) {
+            List<JetType> types = new ArrayList<JetType>();
+            if (isType()) {
+                assert type != null : ""!isType() means type == null && expressionOfType != null"";
+                types.add(type);
+                if (variance == Variance.IN_VARIANCE) {
+                    types.addAll(TypeUtils.getAllSupertypes(type));
+                }
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                for (JetType type : guessTypeForExpression(expressionOfType, context)) {
+                    types.add(type);
+                    if (variance == Variance.IN_VARIANCE) {
+                        types.addAll(TypeUtils.getAllSupertypes(type));
+                    }
+                }
+            }
+            return types;
+        }
+
+        public void computeTypeCandidates(@NotNull BindingContext context) {
+            Collection<JetType> types = getPossibleTypes(context);
+
+            typeCandidates = new TypeCandidate[types.size()];
+            int i = 0;
+            for (JetType type : types) {
+                typeCandidates[i] = new TypeCandidate(type);
+                i++;
+            }
+        }
+
+        public void computeTypeCandidates(
+                @NotNull BindingContext context,
+                @NotNull TypeSubstitution[] substitutions,
+                @NotNull JetScope scope
+        ) {
+            List<JetType> types = getPossibleTypes(context);
+            Collections.reverse(types); // reverse and reverse back later, so that things added below are added at the front
+
+            Set<JetType> newTypes = new LinkedHashSet<JetType>(types);
+            for (TypeSubstitution substitution : substitutions) { // each substitution can be applied or not, so we offer all options
+                List<JetType> toAdd = new ArrayList<JetType>();
+                List<JetType> toRemove = new ArrayList<JetType>();
+                for (JetType type : newTypes) {
+                    toAdd.add(substituteType(type, substitution, variance));
+                    // substitution.byType are type arguments, but they cannot already occur in the type before substitution
+                    if (containsType(type, substitution.getByType())) {
+                        toRemove.add(type);
+                    }
+                }
+                newTypes.addAll(toAdd);
+                newTypes.removeAll(toRemove);
+            }
+
+            if (newTypes.isEmpty()) {
+                newTypes.add(KotlinBuiltIns.getInstance().getAnyType());
+            }
+
+            typeCandidates = new TypeCandidate[newTypes.size()];
+            int i = typeCandidates.length - 1; // reverse order (see explanation above)
+            for (JetType type : newTypes) {
+                typeCandidates[i] = new TypeCandidate(type, scope);
+                i--;
+            }
+        }
+
+        @NotNull
+        public TypeCandidate[] getTypeCandidates() {
+            assert typeCandidates != null : ""call computeTypeCandidates() first"";
+            return typeCandidates;
+        }
+
+        public void renderTypeCandidates(@NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+            for (TypeCandidate candidate : typeCandidates) {
+                candidate.render(typeParameterNameMap);
+            }
+        }
+
+        @NotNull
+        public String[] getPossibleNamesFromExpression() {
+            if (cachedNameCandidatesFromExpression != null) return cachedNameCandidatesFromExpression;
+            if (isType()) {
+                cachedNameCandidatesFromExpression = ArrayUtil.EMPTY_STRING_ARRAY;
+            } else {
+                assert expressionOfType != null : ""!isType() means type == null && expressionOfType != null"";
+                JetNameValidator dummyValidator = new DummyJetNameValidator(expressionOfType.getProject());
+                cachedNameCandidatesFromExpression = JetNameSuggester.suggestNamesForExpression(expressionOfType, dummyValidator);
+            }
+            return cachedNameCandidatesFromExpression;
+        }
+    }
+
+    /**
+     * Encapsulates information about a method parameter that is going to be created.
+     */
+    private static class Parameter {
+        private final String preferredName;
+        private final TypeOrExpressionThereof type;
+
+        public Parameter(@Nullable(""no preferred name"") String preferredName, TypeOrExpressionThereof type) {
+            this.preferredName = preferredName;
+            this.type = type;
+        }
+
+        public String getPreferredName() {
+            return preferredName;
+        }
+
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+    }
+
+    /**
+     * Special <code>Expression</code> for parameter names based on its type.
+     */
+    private static class ParameterNameExpression extends Expression {
+        private final String[] names;
+        private final Map<String, String[]> parameterTypeToNamesMap;
+
+        public ParameterNameExpression(@NotNull String[] names, @NotNull Map<String, String[]> parameterTypeToNamesMap) {
+            for (String name : names) {
+                assert name != null && !name.isEmpty();
+            }
+            this.names = names;
+            this.parameterTypeToNamesMap = parameterTypeToNamesMap;
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            Set<String> names = new LinkedHashSet<String>();
+            Collections.addAll(names, this.names);
+
+            // find the parameter list
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) return new LookupElement[0];
+            JetParameterList parameterList = func.getValueParameterList();
+            assert parameterList != null;
+
+            // add names based on selected type
+            JetParameter parameter = PsiTreeUtil.getParentOfType(elementAt, JetParameter.class);
+            if (parameter != null) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] suggestedNamesBasedOnType = parameterTypeToNamesMap.get(parameterTypeRef.getText());
+                    if (suggestedNamesBasedOnType != null) {
+                        Collections.addAll(names, suggestedNamesBasedOnType);
+                    }
+                }
+            }
+
+            // remember other parameter names for later use
+            Set<String> parameterNames = new HashSet<String>();
+            for (JetParameter jetParameter : parameterList.getParameters()) {
+                if (jetParameter == parameter || jetParameter.getName() == null) continue;
+                parameterNames.add(jetParameter.getName());
+            }
+
+            // add fallback parameter name
+            if (names.isEmpty()) {
+                names.add(""arg"");
+            }
+
+            // ensure there are no conflicts
+            List<LookupElement> lookupElements = new ArrayList<LookupElement>();
+            for (String name : names) {
+                name = getNextAvailableName(name, parameterNames);
+                lookupElements.add(LookupElementBuilder.create(name));
+            }
+
+            // create and return
+            return lookupElements.toArray(new LookupElement[lookupElements.size()]);
+        }
+    }
+
+    /**
+     * An <code>Expression</code> for type references.
+     */
+    private static class TypeExpression extends Expression {
+        private final TypeOrExpressionThereof type;
+        private @NotNull LookupElement[] cachedLookupElements;
+
+        public TypeExpression(@NotNull TypeOrExpressionThereof type) {
+            this.type = type;
+            TypeCandidate[] candidates = type.getTypeCandidates();
+            cachedLookupElements = new LookupElement[candidates.length];
+            for (int i = 0; i < candidates.length; i++) {
+                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());
+            }
+        }
+
+        @Nullable
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            LookupElement[] lookupItems = calculateLookupItems(context);
+            if (lookupItems.length == 0) return new TextResult("""");
+
+            return new TextResult(lookupItems[0].getLookupString());
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return cachedLookupElements;
+        }
+
+        @NotNull
+        public TypeOrExpressionThereof getType() {
+            return type;
+        }
+
+        @Nullable(""can't be found"")
+        public JetType getTypeFromSelection(@NotNull String selection) {
+            TypeCandidate[] options = type.getTypeCandidates();
+            for (TypeCandidate option : options) {
+                if (option.getRenderedType().equals(selection)) {
+                    return option.getType();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * A sort-of dummy <code>Expression</code> for parameter lists, to allow us to update the parameter list as the user makes selections.
+     */
+    private static class TypeParameterListExpression extends Expression {
+        private final String[] typeParameterNamesFromReceiverType;
+        private final Map<String, String[]> parameterTypeToTypeParameterNamesMap;
+
+        public TypeParameterListExpression(
+                @NotNull String[] typeParameterNamesFromReceiverType,
+                @NotNull Map<String, String[]> typeParametersMap
+        ) {
+            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;
+            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;
+        }
+
+        @NotNull
+        @Override
+        public Result calculateResult(ExpressionContext context) {
+            Project project = context.getProject();
+            int offset = context.getStartOffset();
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            Editor editor = context.getEditor();
+            assert editor != null;
+            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
+            assert file != null && file instanceof JetFile;
+            PsiElement elementAt = file.findElementAt(offset);
+            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);
+            if (func == null) {
+                return new TextResult("""");
+            }
+            List<JetParameter> parameters = func.getValueParameters();
+
+            Set<String> typeParameterNames = new LinkedHashSet<String>();
+            Collections.addAll(typeParameterNames, typeParameterNamesFromReceiverType);
+            for (JetParameter parameter : parameters) {
+                JetTypeReference parameterTypeRef = parameter.getTypeReference();
+                if (parameterTypeRef != null) {
+                    String[] typeParameterNamesFromParameter = parameterTypeToTypeParameterNamesMap.get(parameterTypeRef.getText());
+                    if (typeParameterNamesFromParameter != null) {
+                        Collections.addAll(typeParameterNames, typeParameterNamesFromParameter);
+                    }
+                }
+            }
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                String[] typeParameterNamesFromReturnType = parameterTypeToTypeParameterNamesMap.get(returnTypeRef.getText());
+                if (typeParameterNamesFromReturnType != null) {
+                    Collections.addAll(typeParameterNames, typeParameterNamesFromReturnType);
+                }
+            }
+
+            return typeParameterNames.isEmpty()
+                    ? new TextResult("""")
+                    : new TextResult("" <"" + StringUtil.join(typeParameterNames, "", "") + "">"");
+        }
+
+        @Nullable
+        @Override
+        public Result calculateQuickResult(ExpressionContext context) {
+            return calculateResult(context);
+        }
+
+        @NotNull
+        @Override
+        public LookupElement[] calculateLookupItems(ExpressionContext context) {
+            return new LookupElement[0]; // do not offer the user any choices
+        }
+    }
+
+    /**
+     * A <code>JetNameValidator</code> that always succeeds.
+     */
+    private static class DummyJetNameValidator implements JetNameValidator {
+        private final Project project;
+
+        public DummyJetNameValidator(Project project) {
+            this.project = project;
+        }
+
+        @Nullable
+        @Override
+        public String validateName(String name) {
+            return name;
+        }
+
+        @Override
+        public Project getProject() {
+            return project;
+        }
+    }
+
+    /**
+     * Encapsulates a single type substitution of a <code>JetType</code> by another <code>JetType</code>.
+     */
+    private static class TypeSubstitution {
+        private final JetType forType;
+        private final JetType byType;
+
+        private TypeSubstitution(JetType forType, JetType byType) {
+            this.forType = forType;
+            this.byType = byType;
+        }
+
+        private JetType getForType() {
+            return forType;
+        }
+
+        private JetType getByType() {
+            return byType;
+        }
+    }
+
+    private final String methodName;
+    private final TypeOrExpressionThereof ownerType;
+    private final TypeOrExpressionThereof returnType;
+    private final List<Parameter> parameters;
+
+    private boolean isUnit;
+    private boolean isExtension;
+    private JetFile currentFile;
+    private JetFile containingFile;
+    private Editor currentFileEditor;
+    private Editor containingFileEditor;
+    private BindingContext currentFileContext;
+    private JetClass ownerClass;
+    private ClassDescriptor ownerClassDescriptor;
+    private TypeCandidate selectedReceiverType;
+    private Map<TypeParameterDescriptor, String> typeParameterNameMap;
+
+    public CreateMethodFromUsageFix(@NotNull PsiElement element, @NotNull TypeOrExpressionThereof ownerType, @NotNull String methodName,
+            @NotNull TypeOrExpressionThereof returnType, @NotNull List<Parameter> parameters) {
+        super(element);
+        this.methodName = methodName;
+        this.ownerType = ownerType;
+        this.returnType = returnType;
+        this.parameters = parameters;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.method.from.usage"", methodName);
+    }
+
+    @Override
+    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        assert file != null && file instanceof JetFile;
+        currentFile = (JetFile) file;
+        currentFileEditor = editor;
+        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();
+
+        ownerType.computeTypeCandidates(currentFileContext);
+        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();
+        assert ownerTypeCandidates.length > 0;
+        if (ownerTypeCandidates.length == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
+            selectedReceiverType = ownerTypeCandidates[0];
+            doInvoke(project);
+        } else {
+            // class selection
+            List<String> options = new ArrayList<String>();
+            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();
+            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {
+                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();
+                if (possibleClassDescriptor != null) {
+                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());
+                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();
+                    String namespace = renderDescriptor(namespaceDescriptor, true);
+                    String option = className + "" ("" + namespace + "")"";
+                    options.add(option);
+                    optionToTypeMap.put(option, ownerTypeCandidate);
+                }
+            }
+
+            final JList list = new JBList(options);
+            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();
+            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+            list.setCellRenderer(renderer);
+            PopupChooserBuilder builder = new PopupChooserBuilder(list);
+            renderer.installSpeedSearch(builder);
+
+            Runnable runnable = new Runnable() {
+                @Override
+                public void run() {
+                    int index = list.getSelectedIndex();
+                    if (index < 0) return;
+                    String option = (String) list.getSelectedValue();
+                    selectedReceiverType = optionToTypeMap.get(option);
+                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {
+                        @Override
+                        public void run() {
+                            doInvoke(project);
+                        }
+                    }, getText(), null);
+                }
+            };
+
+            builder.setTitle(JetBundle.message(""choose.target.class.or.trait.title""))
+                   .setItemChoosenCallback(runnable)
+                   .createPopup()
+                   .showInBestPositionFor(currentFileEditor);
+        }
+    }
+
+    private void doInvoke(@NotNull final Project project) {
+        // gather relevant information
+        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();
+        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;
+        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;
+        JetType receiverType = ownerClassDescriptor.getDefaultType();
+        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);
+        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {
+            ownerClass = (JetClass) typeDeclaration;
+            isExtension = !ownerClass.isWritable();
+        } else {
+            isExtension = true;
+        }
+        isUnit = returnType.isType() && isUnit(returnType.getType());
+
+        JetScope scope;
+        if (isExtension) {
+            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, currentFile);
+            assert namespaceDescriptor != null;
+            scope = namespaceDescriptor.getMemberScope();
+        } else {
+            assert ownerClassDescriptor instanceof MutableClassDescriptor;
+            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();
+        }
+
+        // figure out type substitutions for type parameters
+        List<TypeProjection> classTypeParameters = receiverType.getArguments();
+        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();
+        assert ownerTypeArguments.size() == classTypeParameters.size();
+        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];
+        for (int i = 0; i < substitutions.length; i++) {
+            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());
+        }
+        for (Parameter parameter : parameters) {
+            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+        if (!isUnit) {
+            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);
+        }
+
+        // now that we have done substitutions, we can throw it away
+        selectedReceiverType = new TypeCandidate(receiverType, scope);
+
+        // figure out type parameter renames to avoid conflicts
+        typeParameterNameMap = getTypeParameterRenames(scope);
+        for (Parameter parameter : parameters) {
+            parameter.getType().renderTypeCandidates(typeParameterNameMap);
+        }
+        if (!isUnit) {
+            returnType.renderTypeCandidates(typeParameterNameMap);
+        }
+        selectedReceiverType.render(typeParameterNameMap);
+
+        ApplicationManager.getApplication().runWriteAction(new Runnable() {
+            @Override
+            public void run() {
+                JetNamedFunction func = createFunctionSkeleton(project);
+                buildAndRunTemplate(project, func);
+            }
+        });
+    }
+
+    private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {
+        JetNamedFunction func;
+        String[] parameterStrings = new String[parameters.size()];
+        for (int i = 0; i < parameterStrings.length; i++) {
+            parameterStrings[i] = ""p"" + i + "": Any"";
+        }
+        String parametersString = StringUtil.join(parameterStrings,"", "");
+        String returnTypeString = isUnit ? """" : "": Any"";
+        if (isExtension) { // create as extension function
+            String ownerTypeString = selectedReceiverType.getRenderedType();
+            String methodText = String.format(""fun %s.%s(%s)%s { }"", ownerTypeString, methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            containingFile = currentFile;
+            containingFileEditor = currentFileEditor;
+            func = (JetNamedFunction) currentFile.add(func);
+        } else { // create as method
+            String methodText = String.format(""fun %s(%s)%s { }"", methodName, parametersString, returnTypeString);
+            func = JetPsiFactory.createFunction(project, methodText);
+            PsiFile classContainingFile = ownerClass.getContainingFile();
+            assert classContainingFile instanceof JetFile;
+            containingFile = (JetFile) classContainingFile;
+
+            VirtualFile virtualFile = containingFile.getVirtualFile();
+            assert virtualFile != null;
+            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+            fileEditorManager.openFile(virtualFile, true);
+            containingFileEditor = fileEditorManager.getSelectedTextEditor();
+
+            JetClassBody classBody = ownerClass.getBody();
+            if (classBody == null) {
+                classBody = (JetClassBody) ownerClass.add(JetPsiFactory.createEmptyClassBody(project));
+                ownerClass.addBefore(JetPsiFactory.createWhiteSpace(project), classBody);
+            }
+            PsiElement rBrace = classBody.getRBrace();
+            assert rBrace != null;
+            func = (JetNamedFunction) classBody.addBefore(func, rBrace);
+        }
+
+        return func;
+    }
+
+    private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {
+        JetParameterList parameterList = func.getValueParameterList();
+        assert parameterList != null;
+
+        // build templates
+        PsiDocumentManager.getInstance(project).commitAllDocuments();
+        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());
+
+        CaretModel caretModel = containingFileEditor.getCaretModel();
+        caretModel.moveToOffset(containingFile.getNode().getStartOffset());
+
+        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);
+        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);
+        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);
+
+        // add a segment for the parameter list
+        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we
+        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type
+        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to
+        // it.
+        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);
+
+        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it
+        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();
+        ArrayList<Variable> variables = template.getVariables();
+        for (int i = 0; i < parameters.size(); i++) {
+            Collections.swap(variables, i * 2, i * 2 + 1);
+        }
+
+        // fix up the template to include the expression for the type parameter list
+        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));
+
+        // run the template
+        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {
+            @Override
+            public void templateFinished(Template _, boolean brokenOff) {
+                // file templates
+                int offset = template.getSegmentOffset(0);
+                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);
+                assert func != null;
+                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();
+
+                ApplicationManager.getApplication().runWriteAction(new Runnable() {
+                    @Override
+                    public void run() {
+                        // file templates
+                        setupFunctionBody(project, func);
+
+                        // change short type names to fully qualified ones (to be shortened below)
+                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);
+                    }
+                });
+
+                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);
+            }
+        });
+    }
+
+    private Map<TypeParameterDescriptor, String> getTypeParameterRenames(JetScope scope) {
+        TypeParameterDescriptor[] receiverTypeParametersNotInScope = selectedReceiverType.getTypeParameters();
+        Set<TypeParameterDescriptor> allTypeParametersNotInScope = new LinkedHashSet<TypeParameterDescriptor>();
+        allTypeParametersNotInScope.addAll(Arrays.asList(receiverTypeParametersNotInScope));
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(parameterTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        if (!isUnit) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                allTypeParametersNotInScope.addAll(Arrays.asList(returnTypeCandidate.getTypeParameters()));
+            }
+        }
+
+        List<TypeParameterDescriptor> typeParameters = new ArrayList<TypeParameterDescriptor>(allTypeParametersNotInScope);
+        List<String> typeParameterNames = new ArrayList<String>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            typeParameterNames.add(getNextAvailableName(typeParameter.getName().getName(), typeParameterNames, scope));
+        }
+        assert typeParameters.size() == typeParameterNames.size();
+        Map<TypeParameterDescriptor, String> typeParameterNameMap = new HashMap<TypeParameterDescriptor, String>();
+        for (int i = 0; i < typeParameters.size(); i++) {
+            typeParameterNameMap.put(typeParameters.get(i), typeParameterNames.get(i));
+        }
+
+        return typeParameterNameMap;
+    }
+
+    private void setupTypeReferencesForShortening(
+            @NotNull Project project,
+            @NotNull JetNamedFunction func,
+            @NotNull List<JetTypeReference> typeRefsToShorten,
+            @NotNull TypeExpression[] parameterTypeExpressions,
+            @Nullable TypeExpression returnTypeExpression
+    ) {
+        if (isExtension) {
+            JetTypeReference receiverTypeRef =
+                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));
+            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());
+
+            receiverTypeRef = func.getReceiverTypeRef();
+            if (receiverTypeRef != null) {
+                typeRefsToShorten.add(receiverTypeRef);
+            }
+        }
+
+        if (!isUnit) {
+            assert returnTypeExpression != null;
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            if (returnTypeRef != null) {
+                JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());
+                if (returnType != null) { // user selected a given type
+                    replaceWithLongerName(project, returnTypeRef, returnType);
+                    returnTypeRef = func.getReturnTypeRef();
+                    assert returnTypeRef != null;
+                    typeRefsToShorten.add(returnTypeRef);
+                }
+            }
+        }
+
+        List<JetParameter> valueParameters = func.getValueParameters();
+        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();
+        assert valueParameters.size() == parameterTypeExpressions.length;
+        for (int i = 0; i < valueParameters.size(); i++) {
+            JetParameter parameter = valueParameters.get(i);
+            JetTypeReference parameterTypeRef = parameter.getTypeReference();
+            if (parameterTypeRef != null) {
+                JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());
+                if (parameterType != null) {
+                    replaceWithLongerName(project, parameterTypeRef, parameterType);
+                    parameterIndicesToShorten.add(i);
+                }
+            }
+        }
+        valueParameters = func.getValueParameters();
+        for (int i : parameterIndicesToShorten) {
+            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();
+            if (parameterTypeRef != null) {
+                typeRefsToShorten.add(parameterTypeRef);
+            }
+        }
+    }
+
+    private void setupFunctionBody(@NotNull Project project, @NotNull JetNamedFunction func) {
+        FileTemplate fileTemplate = FileTemplateManager.getInstance().getCodeTemplate(TEMPLATE_FROM_USAGE_METHOD_BODY);
+        Properties properties = new Properties();
+        if (isUnit) {
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, ""Unit"");
+        } else {
+            JetTypeReference returnTypeRef = func.getReturnTypeRef();
+            assert returnTypeRef != null;
+            properties.setProperty(FileTemplate.ATTRIBUTE_RETURN_TYPE, returnTypeRef.getText());
+        }
+        properties.setProperty(FileTemplate.ATTRIBUTE_CLASS_NAME, DescriptorUtils.getFQName(ownerClassDescriptor).getFqName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_SIMPLE_CLASS_NAME, ownerClassDescriptor.getName().getName());
+        properties.setProperty(FileTemplate.ATTRIBUTE_METHOD_NAME, methodName);
+
+        @NonNls String bodyText;
+        try {
+            bodyText = fileTemplate.getText(properties);
+        } catch (ProcessCanceledException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IncorrectOperationException(""Failed to parse file template"", e);
+        }
+        JetExpression newBodyExpression = JetPsiFactory.createFunctionBody(project, bodyText);
+        JetExpression oldBodyExpression = func.getBodyExpression();
+        assert oldBodyExpression != null;
+        oldBodyExpression.replace(newBodyExpression);
+    }
+
+    @NotNull
+    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        assert returnTypeRef != null;
+        TypeExpression returnTypeExpression = new TypeExpression(returnType);
+        builder.replaceElement(returnTypeRef, returnTypeExpression);
+        return returnTypeExpression;
+    }
+
+    @NotNull
+    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {
+        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();
+        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();
+
+        for (Parameter parameter : parameters) {
+            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();
+            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {
+                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        JetTypeReference returnTypeRef = func.getReturnTypeRef();
+        if (returnTypeRef != null) {
+            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();
+            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {
+                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());
+            }
+        }
+
+        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after ""fun"")
+        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);
+    }
+
+    private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,
+            @NotNull JetParameterList parameterList) {
+        List<JetParameter> jetParameters = parameterList.getParameters();
+        assert jetParameters.size() == parameters.size();
+        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];
+        JetNameValidator dummyValidator = new DummyJetNameValidator(project);
+        for (int i = 0; i < parameters.size(); i++) {
+            Parameter parameter = parameters.get(i);
+            JetParameter jetParameter = jetParameters.get(i);
+
+            // add parameter type to the template
+            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());
+            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();
+            assert parameterTypeRef != null;
+            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);
+
+            // add parameter name to the template
+            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();
+            String preferredName = parameter.getPreferredName();
+            String[] possibleNames;
+            if (preferredName != null) {
+                possibleNames = new String[possibleNamesFromExpression.length + 1];
+                possibleNames[0] = preferredName;
+                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);
+            } else {
+                possibleNames = possibleNamesFromExpression;
+            }
+
+            // figure out suggested names for each type option
+            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();
+            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {
+                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);
+                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);
+            }
+
+            // add expression to builder
+            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);
+            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();
+            assert parameterNameIdentifier != null;
+            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);
+        }
+        return parameterTypeExpressions;
+    }
+
+    private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {
+        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));
+        typeRef.replace(fullyQualifiedReceiverTypeRef);
+    }
+
+    @NotNull
+    private static JetType substituteType(@NotNull JetType type, @NotNull TypeSubstitution substitution, @NotNull Variance variance) {
+        switch (variance) {
+            case INVARIANT:
+                // for invariant, can replace only when they're equal
+                if (type.equals(substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case IN_VARIANCE:
+                // for covariant (e.g. function parameter), can replace type with any of its supertypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(type, substitution.getForType())) {
+                    return substitution.getByType();
+                }
+                break;
+            case OUT_VARIANCE:
+                // for contravariant (e.g. function return value), can replace type with any of its subtypes
+                if (JetTypeChecker.INSTANCE.isSubtypeOf(substitution.getForType(), type)) {
+                    return substitution.getByType();
+                }
+                break;
+        }
+
+        List<TypeProjection> newArguments = new ArrayList<TypeProjection>();
+        List<TypeParameterDescriptor> typeParameters = type.getConstructor().getParameters();
+        int i = 0;
+        for (TypeProjection projection : type.getArguments()) {
+            TypeParameterDescriptor typeParameter = typeParameters.get(i);
+            JetType newArgument = substituteType(projection.getType(), substitution, typeParameter.getVariance());
+            newArguments.add(new TypeProjection(Variance.INVARIANT, newArgument));
+            i++;
+        }
+        return new JetTypeImpl(type.getAnnotations(), type.getConstructor(),
+                               type.isNullable(), newArguments, type.getMemberScope());
+    }
+
+    private static boolean containsType(JetType outer, JetType inner) {
+        if (outer.equals(inner)) {
+            return true;
+        }
+
+        for (TypeProjection projection : outer.getArguments()) {
+            if (containsType(projection.getType(), inner)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @NotNull
+    private static String renderDescriptor(
+            @NotNull DeclarationDescriptor declarationDescriptor,
+            @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap,
+            boolean fq
+    ) {
+        if (declarationDescriptor instanceof TypeParameterDescriptor) {
+            String replacement = typeParameterNameMap.get(declarationDescriptor);
+            return replacement == null ? declarationDescriptor.getName().getName() : replacement;
+        } else {
+            return fq ? DescriptorUtils.getFQName(declarationDescriptor).getFqName() : declarationDescriptor.getName().getName();
+        }
+    }
+
+    @NotNull
+    private static String renderDescriptor(@NotNull DeclarationDescriptor declarationDescriptor, boolean fq) {
+        return renderDescriptor(declarationDescriptor, Collections.<TypeParameterDescriptor, String>emptyMap(), fq);
+    }
+
+    private static String renderType(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap, boolean fq) {
+        List<TypeProjection> projections = type.getArguments();
+        DeclarationDescriptor declarationDescriptor = type.getConstructor().getDeclarationDescriptor();
+        assert declarationDescriptor != null;
+        if (projections.isEmpty()) {
+            return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq);
+        }
+
+        List<String> arguments = new ArrayList<String>();
+        for (TypeProjection projection : projections) {
+            arguments.add(renderType(projection.getType(), typeParameterNameMap, fq));
+        }
+        return renderDescriptor(declarationDescriptor, typeParameterNameMap, fq) + ""<"" + StringUtil.join(arguments, "", "") + "">"";
+    }
+
+    @NotNull
+    private static String renderTypeShort(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, false);
+    }
+
+    @NotNull
+    private static String renderTypeLong(@NotNull JetType type, @NotNull Map<TypeParameterDescriptor, String> typeParameterNameMap) {
+        return renderType(type, typeParameterNameMap, true);
+    }
+
+    @NotNull
+    private static TypeParameterDescriptor[] getTypeParameterNamesNotInScope(
+            @NotNull Collection<? extends TypeParameterDescriptor> typeParameters,
+            @NotNull JetScope scope
+    ) {
+        List<TypeParameterDescriptor> typeParameterNames = new ArrayList<TypeParameterDescriptor>();
+        for (TypeParameterDescriptor typeParameter : typeParameters) {
+            ClassifierDescriptor classifier = scope.getClassifier(typeParameter.getName());
+            if (classifier == null || !classifier.equals(typeParameter)) {
+                typeParameterNames.add(typeParameter);
+            }
+        }
+        return typeParameterNames.toArray(new TypeParameterDescriptor[typeParameterNames.size()]);
+    }
+
+    @NotNull
+    private static Set<TypeParameterDescriptor> getTypeParametersInType(@NotNull JetType type) {
+        Set<TypeParameterDescriptor> typeParameters = new LinkedHashSet<TypeParameterDescriptor>();
+        List<TypeProjection> arguments = type.getArguments();
+        if (arguments.isEmpty()) {
+            ClassifierDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();
+            if (descriptor instanceof TypeParameterDescriptor) {
+                typeParameters.add((TypeParameterDescriptor) descriptor);
+            }
+        } else {
+            for (TypeProjection projection : arguments) {
+                typeParameters.addAll(getTypeParametersInType(projection.getType()));
+            }
+        }
+        return typeParameters;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames) {
+        if (existingNames.contains(name)) {
+            int j = 1;
+            while (existingNames.contains(name + j)) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static String getNextAvailableName(@NotNull String name, @NotNull Collection<String> existingNames, @NotNull JetScope scope) {
+        if (existingNames.contains(name) || scope.getClassifier(Name.identifier(name)) != null) {
+            int j = 1;
+            while (existingNames.contains(name + j) || scope.getClassifier(Name.identifier(name + j)) != null) j++;
+            name += j;
+        }
+        return name;
+    }
+
+    @NotNull
+    private static JetType[] guessTypeForExpression(@NotNull JetExpression expr, @NotNull BindingContext context) {
+        JetType type = context.get(BindingContext.EXPRESSION_TYPE, expr);
+        JetNamedDeclaration declaration = null;
+
+        // if we know the actual type of the expression
+        if (type != null) {
+            return new JetType[] {type};
+        }
+
+        // expression has an expected type
+        else if ((type = context.get(BindingContext.EXPECTED_EXPRESSION_TYPE, expr)) != null) {
+            return new JetType[] {type};
+        }
+
+        // expression itself is a type assertion
+        else if (expr instanceof JetTypeConstraint) { // expression itself is a type assertion
+            JetTypeConstraint constraint = (JetTypeConstraint) expr;
+            return new JetType[] {context.get(BindingContext.TYPE, constraint.getBoundTypeReference())};
+        }
+
+        // expression is on the left side of a type assertion
+        else if (expr.getParent() instanceof JetTypeConstraint) {
+            JetTypeConstraint constraint = (JetTypeConstraint) expr.getParent();
+            return new JetType[] {context.get(BindingContext.TYPE, constraint.getBoundTypeReference())};
+        }
+
+        // expression is on the lhs of a multi-declaration
+        else if (expr instanceof JetMultiDeclarationEntry) {
+            JetMultiDeclarationEntry entry = (JetMultiDeclarationEntry) expr;
+            JetTypeReference typeRef = entry.getTypeRef();
+            if (typeRef != null) { // and has a specified type
+                return new JetType[] {context.get(BindingContext.TYPE, typeRef)};
+            }
+            declaration = entry; // otherwise fall through and guess
+        }
+
+        // expression is a parameter (e.g. declared in a for-loop)
+        else if (expr instanceof JetParameter) {
+            JetParameter parameter = (JetParameter) expr;
+            JetTypeReference typeRef = parameter.getTypeReference();
+            if (typeRef != null) { // and has a specified type
+                return new JetType[] {context.get(BindingContext.TYPE, typeRef)};
+            }
+            declaration = parameter; // otherwise fall through and guess
+        }
+
+        // the expression is the RHS of a variable assignment with a specified type
+        else if (expr.getParent() instanceof JetVariableDeclaration) {
+            JetVariableDeclaration variable = (JetVariableDeclaration) expr.getParent();
+            JetTypeReference typeRef = variable.getTypeRef();
+            if (typeRef != null) { // and has a specified type
+                return new JetType[] {context.get(BindingContext.TYPE, typeRef)};
+            }
+            declaration = variable; // otherwise fall through and guess, based on LHS
+        }
+
+        // guess based on declaration
+        SearchScope scope = expr.getContainingFile().getUseScope();
+        Set<JetType> expectedTypes = new HashSet<JetType>();
+        if (declaration != null) {
+            for (PsiReference ref : SearchUtils.findAllReferences(declaration, scope)) {
+                if (ref instanceof JetSimpleNameReference) {
+                    JetSimpleNameReference simpleNameRef = (JetSimpleNameReference) ref;
+                    JetType expectedType = context.get(BindingContext.EXPECTED_EXPRESSION_TYPE, simpleNameRef.getExpression());
+                    if (expectedType != null) {
+                        expectedTypes.add(expectedType);
+                    }
+                }
+            }
+        }
+        if (expectedTypes.isEmpty()) {
+            return new JetType[0];
+        }
+        type = TypeUtils.intersect(JetTypeChecker.INSTANCE, expectedTypes);
+        if (type != null) {
+            return new JetType[] {type};
+        } else { // intersection doesn't exist; let user make an imperfect choice
+            return expectedTypes.toArray(new JetType[expectedTypes.size()]);
+        }
+    }
+
+    private static boolean isUnit(@NotNull JetType type) {","Method is trivial and used once. It's redundant.
",Please don't use wildcard imports.
112,"@@ -0,0 +1,147 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.codeInsight.intention.JvmCommonIntentionActionsFactory
+import com.intellij.codeInspection.LocalQuickFixAndIntentionActionOnPsiElement
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import com.intellij.psi.PsiModifier
+import com.intellij.psi.PsiType
+import org.jetbrains.kotlin.asJava.elements.KtLightElement
+import org.jetbrains.kotlin.builtins.DefaultBuiltIns
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.idea.core.insertMembersAfter
+import org.jetbrains.kotlin.idea.quickfix.AddModifierFix
+import org.jetbrains.kotlin.idea.quickfix.RemoveModifierFix
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.platform.JavaToKotlinClassMap
+import org.jetbrains.kotlin.psi.KtClassOrObject
+import org.jetbrains.kotlin.psi.KtElement
+import org.jetbrains.kotlin.psi.KtModifierListOwner
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.uast.UClass
+import org.jetbrains.uast.UDeclaration
+import org.jetbrains.uast.UElement
+
+
+class KotlinCommonIntentionActionsFactory : JvmCommonIntentionActionsFactory() {
+    override fun createChangeModifierAction(declaration: UDeclaration, modifier: String, shouldPresent: Boolean): IntentionAction? {
+        val kModifierOwner = declaration.asKtElement<KtModifierListOwner>()
+                             ?: throw IllegalArgumentException(""$declaration is expected to contain KtLightElement with KtModifierListOwner"")
+
+        val (kToken, shouldPresentMapped) = if (PsiModifier.FINAL == modifier)
+            KtTokens.OPEN_KEYWORD to !shouldPresent
+        else
+            javaPsiModifiersMapping[modifier] to shouldPresent
+
+        if (kToken == null) return null
+        return if (shouldPresentMapped)
+            AddModifierFix.createIfApplicable(kModifierOwner, kToken)
+        else
+            RemoveModifierFix(kModifierOwner, kToken, false)
+    }
+
+    private inline fun <reified T : KtElement> UElement.asKtElement(): T? =
+            (psi as? KtLightElement<*, *>?)?.kotlinOrigin as? T
+
+    companion object {
+        val javaPsiModifiersMapping = mapOf(
+                PsiModifier.PRIVATE to KtTokens.PRIVATE_KEYWORD,
+                PsiModifier.PUBLIC to KtTokens.PUBLIC_KEYWORD,
+                PsiModifier.PROTECTED to KtTokens.PUBLIC_KEYWORD,
+                PsiModifier.ABSTRACT to KtTokens.ABSTRACT_KEYWORD
+        )
+
+        val javaVisibilityMapping: Map<String, String> = mapOf(
+                PsiModifier.PRIVATE to Visibilities.PRIVATE.displayName,
+                PsiModifier.PUBLIC to """",
+                PsiModifier.PROTECTED to Visibilities.PROTECTED.displayName,
+                PsiModifier.PACKAGE_LOCAL to Visibilities.INTERNAL.displayName
+        ).withDefault { Visibilities.DEFAULT_VISIBILITY.displayName }
+    }
+
+    override fun createAddMethodAction(uClass: UClass, methodName: String, visibilityModifier: String, returnType: PsiType, vararg parameters: PsiType): IntentionAction? {
+        val returnTypeString: String = typeString(returnType).let {
+            when {
+                it.isEmpty() -> """"
+                else -> "": $it""
+            }
+        }
+        val paramsStr = parameters.mapIndexed { index, psiType -> ""arg${index + 1}: ${typeString(psiType)}"" }.joinToString()
+        return object : LocalQuickFixAndIntentionActionOnPsiElement(uClass) {
+            override fun getFamilyName(): String = ""Add method""
+
+            private val text = ""Add method '$methodName' to '${uClass.name}'""
+
+            override fun getText(): String = text
+
+            override fun invoke(project: Project, file: PsiFile, editor: Editor?, startElement: PsiElement, endElement: PsiElement) {
+                val visibilityStr = javaVisibilityMapping.getValue(visibilityModifier)
+                val psiFactory = KtPsiFactory(uClass)
+                val function = psiFactory.createFunction(""$visibilityStr fun $methodName($paramsStr)$returnTypeString{}"")",You should use `KtPsiFactory.CallableBuilder` instead of building the text manually.,I don't think we need these imports.
113,"@@ -0,0 +1,15 @@
+// ""Replace with safe (?.) call"" ""false""
+// ACTION: Add non-null asserted (!!) call
+// ACTION: Convert to expression body
+// ACTION: Replace with safe (this?.) call
+// ACTION: Wrap with '?.let { ... }' call
+// ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type A?
+
+class A {
+    fun foo() {
+    }
+}
+
+fun A?.bar() {
+    <caret>foo()
+}","Why does this test have so strange name? I see no `invoke` here, either safe or unsafe",I don't think this is the right erro
114,"@@ -0,0 +1,15 @@
+// WITH_RUNTIME
+
+fun contains(set: Set<Any>, x: Int): Boolean = when {
+    set.size == 0 -> false
+    else -> x in set as Set<Int>
+}
+
+fun box(): String {
+    val set = setOf(1)
+    if (contains(set, 1)) {
+        return ""OK""
+    }
+
+    return ""Fail""
+}","This test in not related to Range#contains, but at some point I had implementation which passed all tests (without this one), but ant build was failed.
",This should be `setOf(1)`.
115,"@@ -0,0 +1,15 @@
+class TestingUse {
+    fun test(sum: Int.(a: Int) -> Int, b: Int): Int {
+        return b.sum(b)
+    }
+    fun test2(sum: (a: Int, b: Int) -> Int, c: Int): Int {","Basically you've used the same test data file in all tests on `makeTypeExplicitInLambda`, altering the calling function in each case. This is not a good idea, because once one of such tests fails, the investigating person might think that the fact that there are several functions in this file is relevant to the test case, while in reality it's not.

Please try to make your tests as minimal as possible, i.e. only include relevant data in each test.
",Why is this a<msg>I don't think it s
116,"@@ -0,0 +1,15 @@
+data class Foo(val a: String) {
+    fun copy(i: Int) {}
+}
+
+class Foo2() {
+    fun copy(i: Int) {}
+}
+","I'd add an example that clearly shows all should be named, like this:
```
data class SomeName(a: Int, b: Int, c: String)
f.copy(2, c = """")
```",I think this should be `<msg>`<msg>`
117,"@@ -0,0 +1,150 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.config.LanguageFeature
+import org.jetbrains.kotlin.config.LanguageVersionSettings
+import org.jetbrains.kotlin.descriptors.ModuleDescriptor
+import org.jetbrains.kotlin.effectsystem.effects.ESCalls
+import org.jetbrains.kotlin.effectsystem.effects.ESReturns
+import org.jetbrains.kotlin.effectsystem.factories.UNKNOWN_CONSTANT
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.resolving.FunctorResolver
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.visitors.Reducer
+import org.jetbrains.kotlin.effectsystem.visitors.SchemaBuilder
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
+
+class EffectSystem(val languageVersionSettings: LanguageVersionSettings) {
+    private val functorResolver = FunctorResolver()
+
+    fun getResultDataFlowInfo(
+            resolvedCall: ResolvedCall<*>,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+
+        // Prevent launch of effect system machinery on pointless cases (constants/enums/constructors/etc.)
+        val callExpression = resolvedCall.call.callElement as? KtCallExpression ?: return DataFlowInfo.EMPTY
+        if (callExpression is KtDeclaration) return DataFlowInfo.EMPTY
+
+        val resultContextInfo = getContextInfoWhen(ESReturns(UNKNOWN_CONSTANT), callExpression, bindingTrace, moduleDescriptor)
+
+        return resultContextInfo.toDataFlowInfo(languageVersionSettings)
+    }
+
+    fun recordDefiniteInvocations(resolvedCall: ResolvedCall<*>, bindingTrace: BindingTrace, moduleDescriptor: ModuleDescriptor) {",In this function we have some strange combination of `getResultDataFlowInfo` and `checkAndRecordDefiniteInvocations`. I think some refactoring is needed here.,I don't think we need these imports.
118,"@@ -0,0 +1,150 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.config.LanguageFeature
+import org.jetbrains.kotlin.config.LanguageVersionSettings
+import org.jetbrains.kotlin.descriptors.ModuleDescriptor
+import org.jetbrains.kotlin.effectsystem.effects.ESCalls
+import org.jetbrains.kotlin.effectsystem.effects.ESReturns
+import org.jetbrains.kotlin.effectsystem.factories.UNKNOWN_CONSTANT
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.resolving.FunctorResolver
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.visitors.Reducer
+import org.jetbrains.kotlin.effectsystem.visitors.SchemaBuilder
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
+
+class EffectSystem(val languageVersionSettings: LanguageVersionSettings) {
+    private val functorResolver = FunctorResolver()
+
+    fun getResultDataFlowInfo(
+            resolvedCall: ResolvedCall<*>,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+
+        // Prevent launch of effect system machinery on pointless cases (constants/enums/constructors/etc.)
+        val callExpression = resolvedCall.call.callElement as? KtCallExpression ?: return DataFlowInfo.EMPTY
+        if (callExpression is KtDeclaration) return DataFlowInfo.EMPTY
+
+        val resultContextInfo = getContextInfoWhen(ESReturns(UNKNOWN_CONSTANT), callExpression, bindingTrace, moduleDescriptor)
+
+        return resultContextInfo.toDataFlowInfo(languageVersionSettings)
+    }
+
+    fun recordDefiniteInvocations(resolvedCall: ResolvedCall<*>, bindingTrace: BindingTrace, moduleDescriptor: ModuleDescriptor) {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.CalledInPlaceEffect)) return
+
+        // Prevent launch of effect system machinery on pointless cases (constants/enums/constructors/etc.)
+        val callExpression = resolvedCall.call.callElement as? KtCallExpression ?: return
+        if (callExpression is KtDeclaration) return
+
+        val resultingContextInfo = getContextInfoWhen(ESReturns(UNKNOWN_CONSTANT), callExpression, bindingTrace, moduleDescriptor)
+        for (effect in resultingContextInfo.firedEffects) {
+            val callsEffect = effect as? ESCalls ?: continue
+            val id = callsEffect.callable.id as DataFlowValueID
+
+            // Could be also IdentifierInfo.Variable when call passes non-anonymous lambda for callable parameter
+            val lambdaExpr = (id.dfv.identifierInfo as? DataFlowValueFactory.ExpressionIdentifierInfo)?.expression ?: continue
+            assert(lambdaExpr is KtLambdaExpression) { ""Unexpected argument of Calls-effect: expected KtLambdaExpression, got $lambdaExpr"" }
+
+            bindingTrace.record(BindingContext.LAMBDA_INVOCATIONS, lambdaExpr as KtLambdaExpression, callsEffect.kind)
+        }
+    }
+
+    fun getConditionalInfoForThenBranch(
+            condition: KtExpression?,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+        if (condition == null) return DataFlowInfo.EMPTY
+
+        return getContextInfoWhen(ESReturns(true.lift()), condition, bindingTrace, moduleDescriptor)
+                .toDataFlowInfo(languageVersionSettings)
+    }
+
+    fun getConditionalInfoForElseBranch(
+            condition: KtExpression?,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+        if (condition == null) return DataFlowInfo.EMPTY
+
+        return getContextInfoWhen(ESReturns(false.lift()), condition, bindingTrace, moduleDescriptor)
+                .toDataFlowInfo(languageVersionSettings)
+    }
+
+    private fun getContextInfoWhen(
+            observedEffect: ESEffect,
+            expression: KtExpression,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): MutableContextInfo {
+        val schema = getSchema(expression, bindingTrace, moduleDescriptor) ?: return MutableContextInfo.EMPTY
+
+        val extractedContextInfo = InfoCollector(observedEffect).collectFromSchema(schema)
+
+        return extractedContextInfo
+    }
+
+    private fun getSchema(expression: KtExpression, bindingTrace: BindingTrace, moduleDescriptor: ModuleDescriptor): EffectSchema? {
+        if (bindingTrace[BindingContext.EXPRESSION_EFFECTS, expression] == null) {
+            val evaluatedSchema = evaluateSchema(expression, bindingTrace.bindingContext, moduleDescriptor) ?: return null
+            bindingTrace.record(BindingContext.EXPRESSION_EFFECTS, expression, evaluatedSchema)
+        }
+
+        return bindingTrace[BindingContext.EXPRESSION_EFFECTS, expression]",I'd try to avoid repeated access to `bindingTrace` here.,I don't think we need these imports.
119,"@@ -0,0 +1,150 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.config.LanguageFeature
+import org.jetbrains.kotlin.config.LanguageVersionSettings
+import org.jetbrains.kotlin.descriptors.ModuleDescriptor
+import org.jetbrains.kotlin.effectsystem.effects.ESCalls
+import org.jetbrains.kotlin.effectsystem.effects.ESReturns
+import org.jetbrains.kotlin.effectsystem.factories.UNKNOWN_CONSTANT
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.resolving.FunctorResolver
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.visitors.Reducer
+import org.jetbrains.kotlin.effectsystem.visitors.SchemaBuilder
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
+
+class EffectSystem(val languageVersionSettings: LanguageVersionSettings) {
+    private val functorResolver = FunctorResolver()
+
+    fun getResultDataFlowInfo(
+            resolvedCall: ResolvedCall<*>,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+
+        // Prevent launch of effect system machinery on pointless cases (constants/enums/constructors/etc.)
+        val callExpression = resolvedCall.call.callElement as? KtCallExpression ?: return DataFlowInfo.EMPTY
+        if (callExpression is KtDeclaration) return DataFlowInfo.EMPTY
+
+        val resultContextInfo = getContextInfoWhen(ESReturns(UNKNOWN_CONSTANT), callExpression, bindingTrace, moduleDescriptor)
+
+        return resultContextInfo.toDataFlowInfo(languageVersionSettings)
+    }
+
+    fun recordDefiniteInvocations(resolvedCall: ResolvedCall<*>, bindingTrace: BindingTrace, moduleDescriptor: ModuleDescriptor) {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.CalledInPlaceEffect)) return
+
+        // Prevent launch of effect system machinery on pointless cases (constants/enums/constructors/etc.)
+        val callExpression = resolvedCall.call.callElement as? KtCallExpression ?: return
+        if (callExpression is KtDeclaration) return
+
+        val resultingContextInfo = getContextInfoWhen(ESReturns(UNKNOWN_CONSTANT), callExpression, bindingTrace, moduleDescriptor)
+        for (effect in resultingContextInfo.firedEffects) {
+            val callsEffect = effect as? ESCalls ?: continue
+            val id = callsEffect.callable.id as DataFlowValueID
+
+            // Could be also IdentifierInfo.Variable when call passes non-anonymous lambda for callable parameter
+            val lambdaExpr = (id.dfv.identifierInfo as? DataFlowValueFactory.ExpressionIdentifierInfo)?.expression ?: continue
+            assert(lambdaExpr is KtLambdaExpression) { ""Unexpected argument of Calls-effect: expected KtLambdaExpression, got $lambdaExpr"" }
+
+            bindingTrace.record(BindingContext.LAMBDA_INVOCATIONS, lambdaExpr as KtLambdaExpression, callsEffect.kind)
+        }
+    }
+
+    fun getConditionalInfoForThenBranch(
+            condition: KtExpression?,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+        if (condition == null) return DataFlowInfo.EMPTY
+
+        return getContextInfoWhen(ESReturns(true.lift()), condition, bindingTrace, moduleDescriptor)
+                .toDataFlowInfo(languageVersionSettings)
+    }
+
+    fun getConditionalInfoForElseBranch(
+            condition: KtExpression?,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): DataFlowInfo {
+        if (!languageVersionSettings.supportsFeature(LanguageFeature.ContractEffects)) return DataFlowInfo.EMPTY
+        if (condition == null) return DataFlowInfo.EMPTY
+
+        return getContextInfoWhen(ESReturns(false.lift()), condition, bindingTrace, moduleDescriptor)
+                .toDataFlowInfo(languageVersionSettings)
+    }
+
+    private fun getContextInfoWhen(
+            observedEffect: ESEffect,
+            expression: KtExpression,
+            bindingTrace: BindingTrace,
+            moduleDescriptor: ModuleDescriptor
+    ): MutableContextInfo {
+        val schema = getSchema(expression, bindingTrace, moduleDescriptor) ?: return MutableContextInfo.EMPTY
+
+        val extractedContextInfo = InfoCollector(observedEffect).collectFromSchema(schema)
+
+        return extractedContextInfo
+    }
+
+    private fun getSchema(expression: KtExpression, bindingTrace: BindingTrace, moduleDescriptor: ModuleDescriptor): EffectSchema? {
+        if (bindingTrace[BindingContext.EXPRESSION_EFFECTS, expression] == null) {
+            val evaluatedSchema = evaluateSchema(expression, bindingTrace.bindingContext, moduleDescriptor) ?: return null
+            bindingTrace.record(BindingContext.EXPRESSION_EFFECTS, expression, evaluatedSchema)
+        }
+
+        return bindingTrace[BindingContext.EXPRESSION_EFFECTS, expression]
+    }
+
+    private fun evaluateSchema(expression: KtExpression, bindingContext: BindingContext, moduleDescriptor: ModuleDescriptor): EffectSchema? {
+        val ctBuilder = CallTreeBuilder(bindingContext, moduleDescriptor, functorResolver)
+        val callTree = expression.accept(ctBuilder, Unit)
+
+        val esBuilder = SchemaBuilder()
+        val schema = callTree.accept(esBuilder) ?: return null
+
+        val reducedSchema = Reducer().reduceSchema(schema)
+
+        return reducedSchema
+    }
+
+    private fun checkAndRecordDefiniteInvocations(bindingTrace: BindingTrace, contextInfo: MutableContextInfo) {",BTW this guy is not in use now,I don't think we need these imports.
120,"@@ -0,0 +1,16 @@
+fun testIsNullOrBlank(x: String?) {","This test has no annotation of some language feature on. Looks strange. I'd check all new tests, and most probably all of them should have some annotation. Otherwise backward compatibility can be broken",nit: space after `<msg><msg>`<msg>`<
121,"@@ -0,0 +1,160 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.descriptors.Visibility
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+
+abstract class ClassifierType<out T : JCTree>(tree: T,",May be it should be `sealed`,I don't think we need this file.
122,"@@ -0,0 +1,160 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.descriptors.Visibility
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+
+abstract class ClassifierType<out T : JCTree>(tree: T,
+                                              treePath: TreePath,
+                                              javac: Javac) : JCType<T>(tree, treePath, javac), JavaClassifierType {
+    override val classifier by lazy { getClassifier(treePath, javac) }
+
+    override val canonicalText
+        get() = (classifier as? JavaClass)?.fqName?.asString() ?: treePath.leaf.toString()
+
+    override val presentableText
+        get() = canonicalText
+
+    private val typeParameter by lazy {
+        treePath.filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+                .flatMap {
+                    when (it) {
+                        is JCTree.JCClassDecl -> it.typarams
+                        is JCTree.JCMethodDecl -> it.typarams
+                        else -> emptyList<JCTypeParameter<*>>()",May be throw an exception here? We should not achieve this point,I don't think we need to override `c
123,"@@ -0,0 +1,160 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.descriptors.Visibility
+import org.jetbrains.kotlin.load.java.structure.*
+import org.jetbrains.kotlin.name.FqName
+
+abstract class ClassifierType<out T : JCTree>(tree: T,
+                                              treePath: TreePath,
+                                              javac: Javac) : JCType<T>(tree, treePath, javac), JavaClassifierType {
+    override val classifier by lazy { getClassifier(treePath, javac) }
+
+    override val canonicalText
+        get() = (classifier as? JavaClass)?.fqName?.asString() ?: treePath.leaf.toString()
+
+    override val presentableText
+        get() = canonicalText
+
+    private val typeParameter by lazy {
+        treePath.filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+                .flatMap {
+                    when (it) {
+                        is JCTree.JCClassDecl -> it.typarams
+                        is JCTree.JCMethodDecl -> it.typarams
+                        else -> emptyList<JCTypeParameter<*>>()
+                    }
+                }
+                .find { it.toString().substringBefore("" "") == treePath.leaf.toString() }
+    }
+
+}
+
+class JCClassifierType<out T : JCTree.JCExpression>(tree: T,
+                                                    treePath: TreePath,
+                                                    javac: Javac) : ClassifierType<T>(tree, treePath, javac) {
+
+    override val typeArguments: List<JavaType>
+        get() = emptyList()
+
+    override val isRaw: Boolean
+        get() = (classifier as? JavaClass)?.typeParameters?.isNotEmpty() ?: false
+
+}
+
+class JCClassifierTypeWithTypeArgument<out T : JCTree.JCTypeApply>(tree: T,
+                                                                   treePath: TreePath,
+                                                                   javac: Javac) : ClassifierType<T>(tree, treePath, javac) {
+
+    override val typeArguments: List<JavaType>
+        get() = tree.arguments.map { create(it, treePath, javac) }
+
+    override val isRaw: Boolean
+        get() = false
+
+}
+
+private fun getClassifier(treePath: TreePath, javac: Javac) = treePath.resolve(javac).let {
+    it.second
+    ?: stubs[it.first]
+    ?: typeParameter(treePath, javac)
+    ?: createStubClassifier(it.first)
+}
+
+private fun typeParameter(treePath: TreePath, javac: Javac) = treePath
+        .filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+        .flatMap {
+            when (it) {
+                is JCTree.JCClassDecl -> it.typarams
+                is JCTree.JCMethodDecl -> it.typarams
+                else -> emptyList<JCTree.JCTypeParameter>()
+            }
+        }
+        .find { it.toString().substringBefore("" "") == treePath.leaf.toString() }
+        ?.let { JCTypeParameter(it,
+                                javac.getTreePath(it, treePath.compilationUnit),
+                                javac)
+        }
+
+private val stubs = hashMapOf<FqName, JavaClass>()","Is it true we have some stub cache here? If yes, consider creating some class / object and integrate both `stubs` and `createStubClassifier` inside. I do not like mutable global properties, even private.",I don't think we need to override `c
124,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and targeting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |","Is it ok that it called the same as other Java constant? Can it mislead?
",I don't think we need the `\<same>` 
125,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and targeting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+","What about a file as target?
",I don't think we need the `\<same>` 
126,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting","Typo: trageting -> targeting
",I think this should be `# Annotation
127,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+
+Putting an annotation on an element that is not allowed by the specified target is a compile-time error.
+No targets specified means that all targets are accepted.
+
+> NOTE: Java has the following [targets](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html):
+
+
+**TODO** Open question: what about traits/classes/objects?  
+**TODO** local variables are just like properties, but local  
+
+> Possbile platform-specific targets","Typo: Possbile -> Possible 
",I don't think we need the `\<same>` 
128,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+
+Putting an annotation on an element that is not allowed by the specified target is a compile-time error.
+No targets specified means that all targets are accepted.
+
+> NOTE: Java has the following [targets](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html):
+
+
+**TODO** Open question: what about traits/classes/objects?  
+**TODO** local variables are just like properties, but local  
+
+> Possbile platform-specific targets
+* SINGLETON_FIELD for objects
+* PROPERTY_FIELD
+* (?) DEFAULT_FUNCTION
+* (?) LAMBDA_METHOD
+* PACKAGE_FACADE
+* PACKAGE_PART
+
+### Mapping onto Java
+
+Kotlin has more possible targets than Java, so there's an issue of mapping back and forth. The table above give a correspondence.","give -> gives
",I don't think we need the `\<same>` here.
129,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+
+Putting an annotation on an element that is not allowed by the specified target is a compile-time error.
+No targets specified means that all targets are accepted.
+
+> NOTE: Java has the following [targets](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html):
+
+
+**TODO** Open question: what about traits/classes/objects?  
+**TODO** local variables are just like properties, but local  
+
+> Possbile platform-specific targets
+* SINGLETON_FIELD for objects
+* PROPERTY_FIELD
+* (?) DEFAULT_FUNCTION
+* (?) LAMBDA_METHOD
+* PACKAGE_FACADE
+* PACKAGE_PART
+
+### Mapping onto Java
+
+Kotlin has more possible targets than Java, so there's an issue of mapping back and forth. The table above give a correspondence.
+
+When we compile a Kotlin class to Java, we write a `@java.lang.annotation.Target` annotation that reflects the targets. For targets having no correspondent ones in Java (e.g. `EXPRESSION`) nothing is written to `j.l.a.Target`. If the set of Java targets is empy, `j.l.a.Target` is not written to the class file. 
+
+In addition to `java.lang.annotation.Target`, a Kotlin-specific annotation `kotlin.target` is written containing all the Kotlin targets listed:
+
+``` kotlin
+package kotlin
+
+enum class AnnotationTarget {
+    PACKAGE
+    ...
+}
+
+target(ANNOTATION_CLASS)
+annotation(RUNTIME) class target(vararg targets: AnnotationTarget)
+```
+
+When loading an annotation, we only read `kotlin.target`. When `kotlin.target` is missing, on the JVM, we read `j.l.a.Target` and map its values to Kotlin ones according to the table above. This implies that we can load pure Java annotations that know nothing about Kotlin, and that an annotation written in Java can be targeted, e.g. for Kotlin expressions, because one can simply manually specify `kotlin.target` for it.
+
+### Syntax
+
+It makes sense to use `kotlin.target` explicitly in Kotlin code:
+
+``` kotlin
+target(EXPRESSION, TYPE)
+annotation class MyAnn
+```
+
+> An alternative would be to make target a aproperty of `kotlin.annotation`, but then we'd","aproperty -> property
",I don't think we need the `\<same>` here.
130,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+
+Putting an annotation on an element that is not allowed by the specified target is a compile-time error.
+No targets specified means that all targets are accepted.
+
+> NOTE: Java has the following [targets](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html):
+
+
+**TODO** Open question: what about traits/classes/objects?  
+**TODO** local variables are just like properties, but local  
+
+> Possbile platform-specific targets
+* SINGLETON_FIELD for objects
+* PROPERTY_FIELD
+* (?) DEFAULT_FUNCTION
+* (?) LAMBDA_METHOD
+* PACKAGE_FACADE
+* PACKAGE_PART
+
+### Mapping onto Java
+
+Kotlin has more possible targets than Java, so there's an issue of mapping back and forth. The table above give a correspondence.
+
+When we compile a Kotlin class to Java, we write a `@java.lang.annotation.Target` annotation that reflects the targets. For targets having no correspondent ones in Java (e.g. `EXPRESSION`) nothing is written to `j.l.a.Target`. If the set of Java targets is empy, `j.l.a.Target` is not written to the class file. 
+
+In addition to `java.lang.annotation.Target`, a Kotlin-specific annotation `kotlin.target` is written containing all the Kotlin targets listed:
+
+``` kotlin
+package kotlin
+
+enum class AnnotationTarget {
+    PACKAGE
+    ...
+}
+
+target(ANNOTATION_CLASS)
+annotation(RUNTIME) class target(vararg targets: AnnotationTarget)
+```
+
+When loading an annotation, we only read `kotlin.target`. When `kotlin.target` is missing, on the JVM, we read `j.l.a.Target` and map its values to Kotlin ones according to the table above. This implies that we can load pure Java annotations that know nothing about Kotlin, and that an annotation written in Java can be targeted, e.g. for Kotlin expressions, because one can simply manually specify `kotlin.target` for it.
+
+### Syntax
+
+It makes sense to use `kotlin.target` explicitly in Kotlin code:
+
+``` kotlin
+target(EXPRESSION, TYPE)
+annotation class MyAnn
+```
+
+> An alternative would be to make target a aproperty of `kotlin.annotation`, but then we'd
+* lose the advantage of varargs, because there are more optional parameters
+* be non-uniform with Java, thus making it harder to figure how to make a Java annotation Kotlin-friendly
+
+## Retention
+
+> NOTE: Retention is a Java-specific concern, more or less. CLR retains all attributes at runtime, and JS too
+
+It makes a lot of sense to make `RUNTIME` the default retention.
+
+Since `RetentionPolicy.CLASS` is not a good fit for Kotlin that has functions outside any class, it's better to have `BINARY` instead. Also, we could have use `java.lang.annotation.RetentionPolicy` anyways, since it's platform-specific. Thus, we need to have our own enum:
+","could have use -> could not use (?)
",I don't think we need the `\<same>` here.
131,"@@ -0,0 +1,169 @@
+# Annotation Options
+
+Goals:
+* Support annotation options, such as retention policy and trageting
+
+See [related discussion about Scala](http://lampwww.epfl.ch/~mihaylov/attributes.html).
+
+## Discussion
+
+For each option of annotations there's a general dichotomy of how it can be specified in code.
+
+Option 0: Separate annotations
+
+``` kotlin
+retention(SOURCE)
+target(CLASSIFIER, FIELD)
+annotation class example
+```
+
+Option 1: Make `annotation` into an annotation, and use its properties
+
+``` kotlin
+annotation(
+    retention = SOURCE, 
+    targets = array(CLASSIFIER, FIELD)
+) 
+class example
+```
+
+A variation of this is
+
+``` kotlin
+annotation(target(CLASSIFIER, FIELD), retention = SOURCE) class example
+```
+
+Annotations can be parameters to other annotations.
+
+Having option as separate annotation is what Java has and seems more extensible, although it actually isn't (adding new parameters to one annotation is no better or worse than adding new annotation recognized by the compiler).
+
+Having those as parameters is more discoverable, but has some syntactic shortcomings: no varargs can be used.
+
+## Targeting
+
+To check applicability, we can use the following constants:
+
+| Kotlin constant | Java constant | 
+|-----------------|---------------|
+| PACKAGE | \<same> |
+| CLASSIFIER | TYPE |
+| ANNOTATION_CLASS | ANNOTATION_TYPE |
+| TYPE_PARAMETER | \<same>
+| PROPERTY | \<no analog> |
+| FIELD | \<same>
+| LOCAL_VARIABLE | \<same> |
+| VALUE_PARAMETER | PARAMETER |
+| CONSTRUCTOR | \<same> |
+| FUNCITON | METHOD |
+| PROPERTY_GETTER | METHOD |
+| PROPERTY_SETTER | METHOD |
+| TYPE | TYPE_USE |
+| EXPRESSION | \<no analog> |
+
+Putting an annotation on an element that is not allowed by the specified target is a compile-time error.
+No targets specified means that all targets are accepted.
+
+> NOTE: Java has the following [targets](https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html):
+
+
+**TODO** Open question: what about traits/classes/objects?  
+**TODO** local variables are just like properties, but local  
+
+> Possbile platform-specific targets
+* SINGLETON_FIELD for objects
+* PROPERTY_FIELD
+* (?) DEFAULT_FUNCTION
+* (?) LAMBDA_METHOD
+* PACKAGE_FACADE
+* PACKAGE_PART
+
+### Mapping onto Java
+
+Kotlin has more possible targets than Java, so there's an issue of mapping back and forth. The table above give a correspondence.
+
+When we compile a Kotlin class to Java, we write a `@java.lang.annotation.Target` annotation that reflects the targets. For targets having no correspondent ones in Java (e.g. `EXPRESSION`) nothing is written to `j.l.a.Target`. If the set of Java targets is empy, `j.l.a.Target` is not written to the class file. 
+
+In addition to `java.lang.annotation.Target`, a Kotlin-specific annotation `kotlin.target` is written containing all the Kotlin targets listed:
+
+``` kotlin
+package kotlin
+
+enum class AnnotationTarget {
+    PACKAGE
+    ...
+}
+
+target(ANNOTATION_CLASS)
+annotation(RUNTIME) class target(vararg targets: AnnotationTarget)
+```
+
+When loading an annotation, we only read `kotlin.target`. When `kotlin.target` is missing, on the JVM, we read `j.l.a.Target` and map its values to Kotlin ones according to the table above. This implies that we can load pure Java annotations that know nothing about Kotlin, and that an annotation written in Java can be targeted, e.g. for Kotlin expressions, because one can simply manually specify `kotlin.target` for it.
+
+### Syntax
+
+It makes sense to use `kotlin.target` explicitly in Kotlin code:
+
+``` kotlin
+target(EXPRESSION, TYPE)
+annotation class MyAnn
+```
+
+> An alternative would be to make target a aproperty of `kotlin.annotation`, but then we'd
+* lose the advantage of varargs, because there are more optional parameters
+* be non-uniform with Java, thus making it harder to figure how to make a Java annotation Kotlin-friendly
+
+## Retention
+
+> NOTE: Retention is a Java-specific concern, more or less. CLR retains all attributes at runtime, and JS too
+
+It makes a lot of sense to make `RUNTIME` the default retention.
+
+Since `RetentionPolicy.CLASS` is not a good fit for Kotlin that has functions outside any class, it's better to have `BINARY` instead. Also, we could have use `java.lang.annotation.RetentionPolicy` anyways, since it's platform-specific. Thus, we need to have our own enum:
+
+``` kotlin
+package kotlin
+
+enum class AnnotationRetention {
+    SOURCE
+    BINARY
+    RUNTIME
+}
+```
+
+> Now, we could map `java.lang.annotation.Retention` and `RetentionPolicy` to `kotlin.retention` and `kotlin.AnnotationRetention`, and then map `CLASS` to `BINARY`, but that is a little too much
+
+Then, it makes sense to make `retention` a property of `kotlin.annotation`:
+
+``` kotlin
+target(TYPE)
+annotation(SOURCE) class MyAnn
+```
+
+The following checks must be performed at compile time:
+* `EXPRESSION`-targeted annotations can only have retention `SOURCE`
+
+## Repeatable
+
+> Java has `Repeatable` as an annotation, but we cannot map a Kotlin type to it, because it is only present since JDK 8, and cannot be written to class files with version lower than 8.
+
+We make `repeatable` a boolean property of `kotlin.annotation`, with default value `false` (as in Java and C#).
+
+If a non-repeatable annotation is used multiple times on the same element, it is a compile-time error.
+
+If a repeatable annotation is used multiple times on the same element, but the target byte code version is lower than Java 8, it is a compile-time error.
+
+## Inherited and Documented
+
+These two options have ratehr unclear value, and we do not supprt them in Kotlin. One can use platform-specific annotations to express them.
+
+## Appendix. Definition of kotlin.annotation
+
+``` kotlin
+package kotlin
+
+target(CLASSIFIER)","Should it be `ANNOTATION_CLASS`?
",I don't think we need the `\<same>` here.
132,"@@ -0,0 +1,17 @@
+// !DIAGNOSTICS: -UNUSED_PARAMETER
+class C {
+    <!OVERLOADS_PRIVATE!>[kotlin.jvm.overloads] private fun foo(s: String = ""OK"")<!> {
+    }
+}
+
+fun foo() {
+    class D {
+        <!OVERLOADS_PRIVATE!>[kotlin.jvm.overloads] fun foo(s: String = ""OK"")<!> {
+        }
+    }
+
+    val <!UNUSED_VARIABLE!>x<!> = object {
+        <!OVERLOADS_PRIVATE!>[kotlin.jvm.overloads] fun foo(s: String = ""OK"")<!> {
+    }
+    }
+}","Please also add an `internal` member with `overloads` here, to ensure the warning is not reported on it
",I think we can remove `<!UNUSED_VARIABLE!
133,"@@ -0,0 +1,17 @@
+package test
+open class Foo() {
+open fun execute() : Unit {
+}
+}
+open class Bar() {
+var fooNotNull : Foo = Foo()
+var fooNullable : Foo? = null
+}
+open class Test() {
+public open fun test(barNotNull : Bar, barNullable : Bar?) : Unit {
+barNotNull.fooNotNull.execute()
+barNotNull.fooNullable?.execute()
+barNullable?.fooNotNull?.execute()
+barNullable?.fooNullable?.execute()
+}
+}
\ No newline at end of file","Please fix code formatting in this test
",Why do we need this?
134,"@@ -0,0 +1,181 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.tree.Tree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaClassifier
+import org.jetbrains.kotlin.name.FqName
+
+class TreePathResolverCache(private val javac: JavacWrapper) {
+
+    private val cache = hashMapOf<Tree, JavaClassifier?>()
+
+    fun resolve(treePath: TreePath): JavaClassifier? = with(treePath) {
+        if (cache.containsKey(leaf)) return cache[leaf]
+
+        return tryToGetClassifier().apply { cache[leaf] = this }
+    }
+
+    private fun TreePath.tryToGetClassifier(): JavaClassifier? {
+        val name = leaf.toString().substringBefore(""<"").substringAfter(""@"")
+        val nameParts = name.split(""."")
+
+        with(compilationUnit as JCTree.JCCompilationUnit) {
+            tryToResolveInner(name, javac, nameParts)?.let { return it }
+            tryToResolvePackageClass(name, javac, nameParts)?.let { return it }
+            tryToResolveByFqName(name, javac)?.let { return it }
+            tryToResolveSingleTypeImport(name, javac, nameParts)?.let { return it }
+            tryToResolveTypeImportOnDemand(name, javac, nameParts)?.let { return it }
+            tryToResolveInJavaLang(name, javac)?.let { return it }
+        }
+
+        return tryToResolveTypeParameter(javac)
+    }
+
+    private fun TreePath.tryToResolveInner(name: String,
+                                           javac: JavacWrapper,
+                                           nameParts: List<String> = emptyList()): JavaClass? = findEnclosingClasses(javac)
+            ?.forEach {
+                it.findInner(name, javac, nameParts)?.let { return it }
+            }.let { return null }
+
+    private fun TreePath.findEnclosingClasses(javac: JavacWrapper) = filterIsInstance<JCTree.JCClassDecl>()
+            .filter { it.extending != leaf && !it.implementing.contains(leaf) }
+            .reversed()
+            .joinToString(separator = ""."", prefix = ""${compilationUnit.packageName}."") { it.simpleName }
+            .let { javac.findClass(FqName(it)) }
+            ?.let {
+                arrayListOf(it).apply {
+                    var enclosingClass = it.outerClass
+                    while (enclosingClass != null) {
+                        add(enclosingClass)
+                        enclosingClass = enclosingClass.outerClass
+                    }
+                }
+            }
+
+    private fun JCTree.JCCompilationUnit.tryToResolveSingleTypeImport(name: String,
+                                                                      javac: JavacWrapper,
+                                                                      nameParts: List<String> = emptyList()): JavaClass? {
+        nameParts.size
+                .takeIf { it > 1 }
+                ?.let {
+                    imports.filter { it.qualifiedIdentifier.toString().endsWith("".${nameParts.first()}"") }
+                            .forEach { find(FqName(""${it.qualifiedIdentifier}""), javac, nameParts)?.let { return it } }
+                            .let { return null }
+                }
+
+        return imports
+                .find { it.qualifiedIdentifier.toString().endsWith("".$name"") }
+                ?.let {
+                    FqName(it.qualifiedIdentifier.toString())
+                            .let { javac.findClass(it) ?: javac.getKotlinClassifier(it) }
+                }
+    }
+
+    private fun JCTree.JCCompilationUnit.tryToResolvePackageClass(name: String,
+                                                                  javac: JavacWrapper,
+                                                                  nameParts: List<String> = emptyList()): JavaClass? {
+        return nameParts.size
+                .takeIf { it > 1 }
+                ?.let {
+                    find(FqName(""$packageName.${nameParts.first()}""), javac, nameParts)
+                } ?: javac.findClass(FqName(""$packageName.$name"")) ?: javac.getKotlinClassifier(FqName(""$packageName.$name""))
+    }
+
+    private fun JCTree.JCCompilationUnit.tryToResolveTypeImportOnDemand(name: String,
+                                                                        javac: JavacWrapper,
+                                                                        nameParts: List<String> = emptyList()): JavaClass? {
+        with(imports.filter { it.qualifiedIdentifier.toString().endsWith(""*"") }) {
+            nameParts.size
+                    .takeIf { it > 1 }
+                    ?.let {
+                        forEach { pack ->
+                            find(FqName(""${pack.qualifiedIdentifier.toString().substringBefore(""*"")}${nameParts.first()}""), javac, nameParts)
+                                    ?.let { return it }
+                        }.let { return null }
+                    }
+
+            forEach {
+                val fqName = ""${it.qualifiedIdentifier.toString().substringBefore(""*"")}$name"".let(::FqName)
+                (javac.findClass(fqName) ?: javac.getKotlinClassifier(fqName))?.let { return it }
+            }.let { return null }
+        }
+    }
+
+    private fun TreePath.tryToResolveTypeParameter(javac: JavacWrapper) =
+            filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }",This `filter` is not needed,I think it would be better to use `tryToR
135,"@@ -0,0 +1,183 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+
+
+fun<C, V, P: KProperty1<C,V>> C.propToParams(p: P, conv: ((v: V) -> String) = { it.toString() } ) =
+        listOf(""--daemon-"" + p.name, conv(p.get(this)))
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C, val prop: P, val parse: (s: String) -> V) {
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+fun Iterable<String>.propParseFilter(parsers: List<PropParser<*,*,*>>) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    return filter { param ->
+        if (currentParser == null) {
+            currentParser = parsers.find { param.equals(""--daemon-"" + it.prop.name) }
+            if (currentParser != null) {
+                if (currentParser is BoolPropParser<*,*>) {
+                    currentParser!!.apply("""")
+                    currentParser = null
+                }
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+public interface CmdlineParams : Serializable {
+    public val asParams: Iterable<String>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.propParseFilter(vararg cs: CmdlineParams) : Iterable<String> =
+    propParseFilter(cs.flatMap { it.parsers })
+
+
+public data class DaemonLaunchingOptions(
+        public var jvmParams: List<String> = listOf()
+) : CmdlineParams {
+
+    override val asParams: Iterable<String>
+        get() =
+            propToParams(::jvmParams, { it.joinToString(""##"") }) // TODO: consider some other options rather than using potentially dangerous delimiter
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::jvmParams, { it.split(""##"")})) // TODO: see appropriate comment in asParams
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val asParams: Iterable<String>
+        get() =
+            propToParams(::port) +
+            propToParams(::autoshutdownMemoryThreshold) +
+            propToParams(::autoshutdownIdleSeconds) +
+            propToParams(::startEcho)
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {
+    val stream = DigestInputStream(file.inputStream(), md)
+    val buf = ByteArray(1024)
+    while (stream.read(buf) == buf.size()) {}","It is not guaranteed that the `read` operation reads the same amount of bytes as buffer can contain and it even may read zero bytes even if the file pointer is not at the end 
",I think it would be better to use `C.prop
136,"@@ -0,0 +1,183 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+
+
+fun<C, V, P: KProperty1<C,V>> C.propToParams(p: P, conv: ((v: V) -> String) = { it.toString() } ) =
+        listOf(""--daemon-"" + p.name, conv(p.get(this)))
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C, val prop: P, val parse: (s: String) -> V) {
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+fun Iterable<String>.propParseFilter(parsers: List<PropParser<*,*,*>>) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    return filter { param ->
+        if (currentParser == null) {
+            currentParser = parsers.find { param.equals(""--daemon-"" + it.prop.name) }
+            if (currentParser != null) {
+                if (currentParser is BoolPropParser<*,*>) {
+                    currentParser!!.apply("""")
+                    currentParser = null
+                }
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+public interface CmdlineParams : Serializable {
+    public val asParams: Iterable<String>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.propParseFilter(vararg cs: CmdlineParams) : Iterable<String> =
+    propParseFilter(cs.flatMap { it.parsers })
+
+
+public data class DaemonLaunchingOptions(
+        public var jvmParams: List<String> = listOf()
+) : CmdlineParams {
+
+    override val asParams: Iterable<String>
+        get() =
+            propToParams(::jvmParams, { it.joinToString(""##"") }) // TODO: consider some other options rather than using potentially dangerous delimiter
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::jvmParams, { it.split(""##"")})) // TODO: see appropriate comment in asParams
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val asParams: Iterable<String>
+        get() =
+            propToParams(::port) +
+            propToParams(::autoshutdownMemoryThreshold) +
+            propToParams(::autoshutdownIdleSeconds) +
+            propToParams(::startEcho)
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {
+    val stream = DigestInputStream(file.inputStream(), md)
+    val buf = ByteArray(1024)
+    while (stream.read(buf) == buf.size()) {}
+    stream.close()","shouldn't we use [`use` function](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html) here:

```
DigestInputStream(file.inputStream(), md).use { stream ->
    // do stuff
}
```
",I think it would be better to use `C.prop
137,"@@ -0,0 +1,185 @@
+/*
+* Copyright 2010-2014 JetBrains s.r.o.
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetPostfixExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetElement
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.psiUtil.getQualifiedElementSelector
+
+public class OperatorToFunctionIntention : JetSelfTargetingIntention<JetExpression>(""operator.to.function"", javaClass()) {
+    fun isApplicablePrefix(element: JetPrefixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.PLUSPLUS, JetTokens.MINUSMINUS, JetTokens.EXCL -> true
+            else -> false
+        }
+    }
+
+    fun isApplicablePostfix(element: JetPostfixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUSPLUS, JetTokens.MINUSMINUS -> true
+            else -> false
+        }
+    }
+
+    fun isApplicableBinary(element: JetBinaryExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.MUL, JetTokens.DIV, JetTokens.PERC, JetTokens.RANGE, JetTokens.IN_KEYWORD, JetTokens.NOT_IN, JetTokens.PLUSEQ, JetTokens.MINUSEQ, JetTokens.MULTEQ, JetTokens.DIVEQ, JetTokens.PERCEQ, JetTokens.EQEQ, JetTokens.EXCLEQ, JetTokens.GT, JetTokens.LT, JetTokens.GTEQ, JetTokens.LTEQ -> true
+            JetTokens.EQ -> element.getLeft() is JetArrayAccessExpression
+            else -> false
+        }
+    }
+
+    fun isApplicableArrayAccess(element: JetArrayAccessExpression): Boolean {
+        return true
+    }
+
+    fun isApplicableCall(element: JetCallExpression): Boolean {
+        return element.getParent() !is JetDotQualifiedExpression && element.getValueArgumentList() != null
+    }
+
+    override fun isApplicableTo(element: JetExpression): Boolean {
+        return when (element) {
+            is JetPrefixExpression -> isApplicablePrefix(element)
+            // is JetPostfixExpression -> isApplicablePostfix(element)
+            is JetBinaryExpression -> isApplicableBinary(element)
+            is JetArrayAccessExpression -> isApplicableArrayAccess(element)
+            is JetCallExpression -> isApplicableCall(element)
+            else -> false
+        }
+    }
+
+
+    fun convertPrefix(element: JetPrefixExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val base = element.getBaseExpression()!!.getText()
+
+        val call = when (op) {
+            JetTokens.PLUS -> ""plus()""
+            JetTokens.MINUS -> ""minus()""
+            JetTokens.PLUSPLUS -> ""inc()""
+            JetTokens.MINUSMINUS -> ""dec()""
+            JetTokens.EXCL -> ""not()""
+            else -> return
+        }
+
+        val transformation = ""$base.$call""
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+        element.replace(transformed)
+    }
+
+    fun convertBinary(element: JetBinaryExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val left = element.getLeft()!!
+        val right = element.getRight()!!
+        val leftText = left.getText()
+        val rightText = right.getText()
+
+        if (op == JetTokens.EQ) {
+            if (left is JetArrayAccessExpression) {
+                convertArrayAccess(left as JetArrayAccessExpression)
+            }
+            return
+        }
+
+        val transformation = when (op) {
+            JetTokens.PLUS -> ""$leftText.plus($rightText)""
+            JetTokens.MINUS -> ""$leftText.minus($rightText)""
+            JetTokens.MUL -> ""$leftText.times($rightText)""
+            JetTokens.DIV -> ""$leftText.div($rightText)""
+            JetTokens.PERC -> ""$leftText.mod($rightText)""
+            JetTokens.RANGE -> ""$leftText.rangeTo($rightText)""
+            JetTokens.IN_KEYWORD -> ""$rightText.contains($leftText)""
+            JetTokens.NOT_IN -> ""!$rightText.contains($leftText)""
+            JetTokens.PLUSEQ -> ""$leftText.plusAssign($rightText)""
+            JetTokens.MINUSEQ -> ""$leftText.minusAssign($rightText)""
+            JetTokens.MULTEQ -> ""$leftText.timesAssign($rightText)""
+            JetTokens.DIVEQ -> ""$leftText.divAssign($rightText)""
+            JetTokens.PERCEQ -> ""$leftText.modAssign($rightText)""
+            JetTokens.EQEQ -> ""$leftText?.equals($rightText) ?: $rightText.identityEquals(null)""
+            JetTokens.EXCLEQ -> ""!($leftText?.equals($rightText) ?: $rightText.identityEquals(null))""
+            JetTokens.GT -> ""$leftText.compareTo($rightText) > 0""
+            JetTokens.LT -> ""$leftText.compareTo($rightText) < 0""
+            JetTokens.GTEQ -> ""$leftText.compareTo($rightText) >= 0""
+            JetTokens.LTEQ -> ""$leftText.compareTo($rightText) <= 0""
+            else -> return
+        }
+
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+
+        val newCalleeExpression = left
+        val context = AnalyzerFacadeWithCache.getContextForElement(newCalleeExpression)
+        val functionCandidates = context[BindingContext.AMBIGUOUS_REFERENCE_TARGET, newCalleeExpression]","`functionCandidates` is always null for me here. I think it has to do with me using a the `PsiElement` `left` rather than a `JetElement`. I can't seem to figure out what it is, though. Is there a way to create a `JetElement` from a string?
",I don't think we need the `isApplicablePr
138,"@@ -0,0 +1,192 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.service
+
+import org.jetbrains.kotlin.cli.common.CLICompiler
+import org.jetbrains.kotlin.cli.jvm.K2JVMCompiler
+import org.jetbrains.kotlin.config.Services
+import org.jetbrains.kotlin.incremental.components.LookupTracker
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.rmi.*
+import org.jetbrains.kotlin.rmi.service.RemoteIncrementalCacheClient
+import org.jetbrains.kotlin.rmi.service.RemoteOutputStreamClient
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.io.PrintStream
+import java.net.URLClassLoader
+import java.rmi.registry.Registry
+import java.rmi.server.UnicastRemoteObject
+import java.util.*
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import java.util.jar.Manifest
+import java.util.logging.Logger
+import kotlin.concurrent.read
+import kotlin.concurrent.write
+
+
+class CompileServiceImpl<Compiler: CLICompiler<*>>(
+        val registry: Registry,
+        val compiler: Compiler,
+        val selfCompilerId: CompilerId,
+        val daemonOptions: DaemonOptions
+) : CompileService, UnicastRemoteObject() {
+
+    val log by lazy { Logger.getLogger(""compiler"") }
+
+    private val rwlock = ReentrantReadWriteLock()
+    private var alive = false
+
+    // TODO: consider matching compilerId coming from outside with actual one
+//    private val selfCompilerId by lazy {
+//        CompilerId(
+//                compilerClasspath = System.getProperty(""java.class.path"")
+//                                            ?.split(File.pathSeparator)
+//                                            ?.map { File(it) }
+//                                            ?.filter { it.exists() }
+//                                            ?.map { it.absolutePath }
+//                                    ?: listOf(),
+//                compilerVersion = loadKotlinVersionFromResource()
+//        )
+//    }
+
+    init {
+        // assuming logically synchronized
+        try {
+            // cleanup for the case of incorrect restart
+            UnicastRemoteObject.unexportObject(this, false)
+        }
+        catch (e: java.rmi.NoSuchObjectException) {
+            // ignoring if object already exported
+        }
+
+        val stub = UnicastRemoteObject.exportObject(this, 0) as CompileService
+        // TODO: use version-specific name
+        registry.rebind (COMPILER_SERVICE_RMI_NAME, stub);
+        alive = true
+    }
+
+    public class IncrementalCompilationComponentsImpl(val idToCache: Map<String, CompileService.RemoteIncrementalCache>): IncrementalCompilationComponents {
+        // perf: cheap object, but still the pattern may be costly if there are too many calls to cache with the same id (which seems not to be the case now)
+        override fun getIncrementalCache(moduleId: String): IncrementalCache = RemoteIncrementalCacheClient(idToCache[moduleId]!!)
+        override fun getLookupTracker(): LookupTracker = LookupTracker.DO_NOTHING
+    }
+
+    private fun createCompileServices(incrementalCaches: Map<String, CompileService.RemoteIncrementalCache>): Services =
+        Services.Builder()
+                .register(javaClass<IncrementalCompilationComponents>(), IncrementalCompilationComponentsImpl(incrementalCaches))
+//                .register(javaClass<CompilationCanceledStatus>(), object: CompilationCanceledStatus {
+//                    override fun checkCanceled(): Unit = if (context.getCancelStatus().isCanceled()) throw CompilationCanceledException()
+//                })
+                .build()
+
+
+    fun usedMemory(): Long {
+        System.gc()
+        val rt = Runtime.getRuntime()
+        return (rt.totalMemory() - rt.freeMemory())","I think you can get more accurate information using the MemoryMXBean class.
",I don't think we need this import.
139,"@@ -0,0 +1,194 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.builtins.DefaultBuiltIns
+import org.jetbrains.kotlin.descriptors.ModuleDescriptor
+import org.jetbrains.kotlin.effectsystem.factories.createConstant
+import org.jetbrains.kotlin.effectsystem.functors.*
+import org.jetbrains.kotlin.effectsystem.resolving.FunctorResolver
+import org.jetbrains.kotlin.effectsystem.structure.ESFunctor
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.structure.UNIT_ID
+import org.jetbrains.kotlin.effectsystem.structure.calltree.*
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.model.ExpressionValueArgument
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
+import org.jetbrains.kotlin.resolve.constants.CompileTimeConstant
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.utils.addToStdlib.cast
+import org.jetbrains.kotlin.utils.ifEmpty
+
+/**
+ * Visits Psi-tree and builds Call Tree
+ */
+class CallTreeBuilder(
+        private val bindingContext: BindingContext,
+        private val moduleDescriptor: ModuleDescriptor,
+        private val functorResolver: FunctorResolver
+) : KtVisitor<CTNode, Unit>() {
+
+    override fun visitKtElement(element: KtElement, data: Unit): CTNode = UNKNOWN_CALL
+
+    override fun visitConstantExpression(expression: KtConstantExpression, data: Unit): CTNode {
+        val bindingContext = bindingContext
+
+        val type: KotlinType = bindingContext.getType(expression) ?: return UNKNOWN_CALL
+
+        val compileTimeConstant: CompileTimeConstant<*>
+                = bindingContext.get(BindingContext.COMPILE_TIME_VALUE, expression) ?: return UNKNOWN_CALL
+        val value: Any? = compileTimeConstant.getValue(type)
+        return CTConstant(ValueIdsFactory.idForConstant(value), type, value)
+    }
+
+    override fun visitSimpleNameExpression(expression: KtSimpleNameExpression, data: Unit): CTNode {
+        // TODO: make proper resolving
+        if (expression.text == ""Unit"") return CTConstant(UNIT_ID, DefaultBuiltIns.Instance.unitType, Unit)
+        return tryCreateVariable(expression)
+    }
+
+    override fun visitParenthesizedExpression(expression: KtParenthesizedExpression, data: Unit): CTNode {
+        val deparenthesized = KtPsiUtil.safeDeparenthesize(expression)
+        return if (deparenthesized == expression) UNKNOWN_CALL else deparenthesized.accept(this, data)
+    }
+
+    override fun visitUnaryExpression(expression: KtUnaryExpression, data: Unit): CTCall {
+        tryGetCachedCall(expression)?.let { return it }
+
+        val argNode = expression.baseExpression?.accept(this, data) ?: return UNKNOWN_CALL
+        return when (expression.operationToken) {
+            KtTokens.EXCL -> CTCall(NotFunctor(), listOf(argNode))
+            else -> return UNKNOWN_CALL
+        }
+    }
+
+    override fun visitDotQualifiedExpression(expression: KtDotQualifiedExpression, data: Unit): CTCall {
+        tryGetCachedCall(expression)?.let { return it }
+
+        val receiver = expression.receiverExpression.accept(this, data)
+
+        val resolvedCall = expression.selectorExpression.getResolvedCall(bindingContext) ?: return UNKNOWN_CALL
+        val argNodes = resolvedCall.valueArgumentsByIndex?.map {
+            (it as? ExpressionValueArgument)?.valueArgument?.getArgumentExpression()?.accept(this, data) ?: return UNKNOWN_CALL
+        } ?: return UNKNOWN_CALL
+
+        val functor = functorResolver.resolveFunctor(resolvedCall) ?: return UNKNOWN_CALL
+        return CTCall(functor, listOf(receiver) + argNodes)
+    }
+
+    override fun visitThisExpression(expression: KtThisExpression, data: Unit?): CTNode {
+        val dfv = expression.createDataFlowValue() ?: return UNKNOWN_CALL // Could be possible for unavailable/incorrect this
+        return CTVariable(ValueIdsFactory.dfvBased(dfv), dfv.type)
+    }
+
+    override fun visitClassLiteralExpression(expression: KtClassLiteralExpression, data: Unit?): CTNode = tryCreateVariable(expression)
+
+    override fun visitLabeledExpression(expression: KtLabeledExpression, data: Unit): CTNode = expression.baseExpression?.accept(this, data) ?: UNKNOWN_CALL
+
+    override fun visitBinaryExpression(expression: KtBinaryExpression, data: Unit): CTCall {
+        tryGetCachedCall(expression)?.let { return it }
+
+        val leftNode = expression.left?.accept(this, data) ?: return UNKNOWN_CALL
+        val rightNode = expression.right?.accept(this, data) ?: return UNKNOWN_CALL
+
+        val functor = when (expression.operationToken) {
+            KtTokens.EQEQ, KtTokens.EQEQEQ -> {",Not quite sure should reference comparison be here.,I don't think we need this import.
140,"@@ -0,0 +1,2 @@
+// ""Change type argument list to <*>"" ""true""
+fun isStringList(list : Any?) = list is (List<<caret>String>)","At first, I've added the parentheses because this way it's more readable to me. But as I was trying to implement the quickfix I realised that it would be possible to make mistake in this case: change ""(List<String>)"" to ""List<*>"". That's why I left the parentheses in one test case.
",
141,"@@ -0,0 +1,202 @@
+# @-based Syntax For Annotations
+
+Goals:
+* Spare `[...]` in expression position for future use
+* Support targeting for annotations (`field`, `getter` etc)
+* Preserve affected/clashing functionality (`@labels`)
+* Support `open` and other modifiers on local classes
+
+## Examples
+
+Annotation:
+``` kotlin
+@AnnotationName(args)
+class Foo
+```
+
+Targeted annotation:
+``` kotlin
+class C(@field:Foo val x: Int, @field,parameter:Bar val y: Int)
+```
+
+another option (like in Scala):
+``` kotlin
+class C(@(Foo@field) val x: Int, @(Bar@(field,parameter)) val y: Int)
+```
+
+yet another option (requires allowing annotation arrays at least in source-retained annotations):
+
+``` kotlin
+class C(@field(@Foo) val x: Int, @field(@Bar) @parameter(@Bar) val y: Int)
+```
+
+Labels:
+``` kotlin
+loop@ // declaring a label
+for (x in foo) {
+    if (x > 0) continue@loop // using a label
+}
+```
+
+## Syntactic Disambiguation
+
+How can we avoid confusion between `continue@loop` and
+
+``` kotlin
+if (foo) continue
+@ann val x = 1
+```
+
+or `return@label (x + 1) + 5` and `return @ann(x + 1) +5`
+
+Rules:
+* no newline allowed between `continue`/`break`/`this`/`super`/`return` and `@label`
+* only one label allowed after these keywords, everything after the first label is an annotation
+* for `return` we prefer `return@label` to `return @ann expr`, so one should say `return (@ann expr)`
+
+## Targeting 
+
+Possible targets are
+* `field`
+* `get`
+* `set`
+* `property`
+* `parameter` - for constructor parameters that are also properties
+
+Reasonable defaults would probably be:
+* `field` if there's a backing field
+* `get` otherwise","Maybe it's worth to mention default target for constructor parameters? Will it be `parameter` for simple parameters and for fields? 
",`@field` and `@parameter` should be `@fie
142,"@@ -0,0 +1,202 @@
+# @-based Syntax For Annotations
+
+Goals:
+* Spare `[...]` in expression position for future use
+* Support targeting for annotations (`field`, `getter` etc)
+* Preserve affected/clashing functionality (`@labels`)
+* Support `open` and other modifiers on local classes
+
+## Examples
+
+Annotation:
+``` kotlin
+@AnnotationName(args)
+class Foo
+```
+
+Targeted annotation:
+``` kotlin
+class C(@field:Foo val x: Int, @field,parameter:Bar val y: Int)
+```
+
+another option (like in Scala):
+``` kotlin
+class C(@(Foo@field) val x: Int, @(Bar@(field,parameter)) val y: Int)
+```
+
+yet another option (requires allowing annotation arrays at least in source-retained annotations):
+
+``` kotlin
+class C(@field(@Foo) val x: Int, @field(@Bar) @parameter(@Bar) val y: Int)
+```
+
+Labels:
+``` kotlin
+loop@ // declaring a label
+for (x in foo) {
+    if (x > 0) continue@loop // using a label
+}
+```
+
+## Syntactic Disambiguation
+
+How can we avoid confusion between `continue@loop` and
+
+``` kotlin
+if (foo) continue
+@ann val x = 1
+```
+
+or `return@label (x + 1) + 5` and `return @ann(x + 1) +5`
+
+Rules:
+* no newline allowed between `continue`/`break`/`this`/`super`/`return` and `@label`
+* only one label allowed after these keywords, everything after the first label is an annotation
+* for `return` we prefer `return@label` to `return @ann expr`, so one should say `return (@ann expr)`
+
+## Targeting 
+
+Possible targets are
+* `field`
+* `get`
+* `set`
+* `property`
+* `parameter` - for constructor parameters that are also properties
+
+Reasonable defaults would probably be:
+* `field` if there's a backing field
+* `get` otherwise
+
+Otherwise, determined by the settings of the annotation itself (applicable to fields only -> goes to a field)","Shall we really allow omitting the non-default target in code? It's a clear message with quick-fix for a code writter and possible source of misunderstanding for a reader that can't be resolved without navigating to annotation declaration. And annotation target settings modification can lead to unexpected tools failures without any compiler messages on rebuild.  
",`@field` and `@parameter` should be `@fie
143,"@@ -0,0 +1,202 @@
+# @-based Syntax For Annotations
+
+Goals:
+* Spare `[...]` in expression position for future use
+* Support targeting for annotations (`field`, `getter` etc)
+* Preserve affected/clashing functionality (`@labels`)
+* Support `open` and other modifiers on local classes
+
+## Examples
+
+Annotation:
+``` kotlin
+@AnnotationName(args)
+class Foo
+```
+
+Targeted annotation:
+``` kotlin
+class C(@field:Foo val x: Int, @field,parameter:Bar val y: Int)
+```
+
+another option (like in Scala):
+``` kotlin
+class C(@(Foo@field) val x: Int, @(Bar@(field,parameter)) val y: Int)
+```
+
+yet another option (requires allowing annotation arrays at least in source-retained annotations):
+
+``` kotlin
+class C(@field(@Foo) val x: Int, @field(@Bar) @parameter(@Bar) val y: Int)
+```
+
+Labels:
+``` kotlin
+loop@ // declaring a label
+for (x in foo) {
+    if (x > 0) continue@loop // using a label
+}
+```
+
+## Syntactic Disambiguation
+
+How can we avoid confusion between `continue@loop` and
+
+``` kotlin
+if (foo) continue
+@ann val x = 1
+```
+
+or `return@label (x + 1) + 5` and `return @ann(x + 1) +5`
+
+Rules:
+* no newline allowed between `continue`/`break`/`this`/`super`/`return` and `@label`
+* only one label allowed after these keywords, everything after the first label is an annotation
+* for `return` we prefer `return@label` to `return @ann expr`, so one should say `return (@ann expr)`
+
+## Targeting 
+
+Possible targets are
+* `field`
+* `get`
+* `set`
+* `property`
+* `parameter` - for constructor parameters that are also properties
+
+Reasonable defaults would probably be:
+* `field` if there's a backing field
+* `get` otherwise
+
+Otherwise, determined by the settings of the annotation itself (applicable to fields only -> goes to a field)
+
+### Possible Syntax for Targeting
+
+Special syntax:
+
+``` kotlin
+class C(@field:Ann(""arg"") var foo: Int)
+```
+
+This is a rather limited dedicated solution: it is unclear, for example, how you define a new target, also this syntax can not be used for anything else but targeting.
+
+Scala-like syntax:
+
+``` kotlin
+class C(@(Ann@field)(""arg"") var foo: Int)
+```
+
+Too many parentheses, but the mechanism is generic.
+
+Annotation-array-based syntax:
+
+``` kotlin
+class C(@field(@Ann1(""arg""), @Ann2) var foo: Int)
+```
+
+Downside: to put the same annotation on two targets, we'd need to duplicate it.
+
+For this, we need to allow annotation attributes of type `Array<Annotation>`:
+
+``` kotlin
+annotation class field(vararg val annotations: Annotation)
+```
+**NOTE**: This is only relatively easilty achievable for source-retained annotations, for class- or runtime-retained it's a lot more involved and relies on an undocumented features of JVM.","eastlty -> easily
",`@field` and `@parameter` should be `@fie
144,"@@ -0,0 +1,202 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.service
+
+import org.jetbrains.kotlin.cli.common.CLICompiler
+import org.jetbrains.kotlin.config.Services
+import org.jetbrains.kotlin.incremental.components.LookupTracker
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.rmi.*
+import org.jetbrains.kotlin.rmi.service.RemoteIncrementalCacheClient
+import org.jetbrains.kotlin.rmi.service.RemoteOutputStreamClient
+import java.io.IOException
+import java.io.PrintStream
+import java.lang.management.ManagementFactory
+import java.net.URLClassLoader
+import java.rmi.registry.Registry
+import java.rmi.server.UnicastRemoteObject
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import java.util.jar.Manifest
+import java.util.logging.Logger
+import kotlin.concurrent.read
+import kotlin.concurrent.write
+
+
+class CompileServiceImpl<Compiler: CLICompiler<*>>(
+        val registry: Registry,
+        val compiler: Compiler,
+        val selfCompilerId: CompilerId,
+        val daemonOptions: DaemonOptions
+) : CompileService, UnicastRemoteObject() {
+
+    val log by lazy { Logger.getLogger(""compiler"") }
+
+    private val rwlock = ReentrantReadWriteLock()
+    private var alive = false
+
+    // TODO: consider matching compilerId coming from outside with actual one
+//    private val selfCompilerId by lazy {
+//        CompilerId(
+//                compilerClasspath = System.getProperty(""java.class.path"")
+//                                            ?.split(File.pathSeparator)
+//                                            ?.map { File(it) }
+//                                            ?.filter { it.exists() }
+//                                            ?.map { it.absolutePath }
+//                                    ?: listOf(),
+//                compilerVersion = loadKotlinVersionFromResource()
+//        )
+//    }
+
+    init {
+        // assuming logically synchronized
+        try {
+            // cleanup for the case of incorrect restart
+            UnicastRemoteObject.unexportObject(this, false)
+        }
+        catch (e: java.rmi.NoSuchObjectException) {
+            // ignoring if object already exported
+        }
+
+        val stub = UnicastRemoteObject.exportObject(this, 0) as CompileService
+        // TODO: use version-specific name
+        registry.rebind (COMPILER_SERVICE_RMI_NAME, stub);
+        alive = true
+    }
+
+    public class IncrementalCompilationComponentsImpl(val idToCache: Map<String, CompileService.RemoteIncrementalCache>): IncrementalCompilationComponents {
+        // perf: cheap object, but still the pattern may be costly if there are too many calls to cache with the same id (which seems not to be the case now)
+        override fun getIncrementalCache(moduleId: String): IncrementalCache = RemoteIncrementalCacheClient(idToCache[moduleId]!!)
+        // TODO: add appropriate proxy into interaction when lookup tracker is needed
+        override fun getLookupTracker(): LookupTracker = LookupTracker.DO_NOTHING
+    }
+
+    private fun createCompileServices(incrementalCaches: Map<String, CompileService.RemoteIncrementalCache>): Services =
+        Services.Builder()
+                .register(IncrementalCompilationComponents::class.java, IncrementalCompilationComponentsImpl(incrementalCaches))
+                // TODO: add remote proxy for cancellation status tracking
+//                .register(javaClass<CompilationCanceledStatus>(), object: CompilationCanceledStatus {
+//                    override fun checkCanceled(): Unit = if (context.getCancelStatus().isCanceled()) throw CompilationCanceledException()
+//                })
+                .build()
+
+
+    fun usedMemory(): Long {
+        System.gc()
+        val rt = Runtime.getRuntime()
+        return (rt.totalMemory() - rt.freeMemory())
+    }
+
+    fun usedMemoryMX(): Long {
+        System.gc()
+        val memoryMXBean= ManagementFactory.getMemoryMXBean()
+        val memHeap=memoryMXBean.getHeapMemoryUsage()
+        return memHeap.used
+    }
+
+    // TODO: consider using version as a part of compiler ID or drop this function
+    private fun loadKotlinVersionFromResource(): String {
+        (javaClass.classLoader as? URLClassLoader)
+        ?.findResource(""META-INF/MANIFEST.MF"")
+        ?.let {
+            try {
+                return Manifest(it.openStream()).mainAttributes.getValue(""Implementation-Version"") ?: """"
+            }
+            catch (e: IOException) {}
+        }
+        return """"
+    }
+
+
+    fun<R> checkedCompile(args: Array<out String>, body: () -> R): R {
+        try {
+            if (args.none())
+                throw IllegalArgumentException(""Error: empty arguments list."")
+            log.info(""Starting compilation with args: "" + args.joinToString("" ""))
+            val startMemMX = usedMemoryMX() / 1024
+            val startMem = usedMemory() / 1024
+            val startTime = System.nanoTime()
+            val res = body()
+            val endTime = System.nanoTime()
+            val endMem = usedMemory() / 1024
+            val endMemMX = usedMemoryMX() / 1024
+            log.info(""Done with result "" + res.toString())
+            log.info(""Elapsed time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
+            log.info(""Used memory: $endMem kb (${""%+d"".format(endMem - startMem)} kb)"")
+            log.info(""Used memory (from MemoryMXBean): $endMemMX kb (${""%+d"".format(endMemMX - startMemMX)} kb)"")
+            return res
+        }
+        catch (e: Exception) {
+            log.info(""Error: $e"")
+            throw e
+        }
+    }
+
+    fun<R> ifAlive(body: () -> R): R = rwlock.read {
+        if (!alive) throw IllegalStateException(""Kotlin Compiler Service is not in alive state"")
+        else body()
+    }
+
+    fun<R> ifAliveExclusive(body: () -> R): R = rwlock.write {
+        if (!alive) throw IllegalStateException(""Kotlin Compiler Service is not in alive state"")
+        else body()
+    }
+
+    // sometimes used for debugging
+    fun<R> spy(msg: String, body: () -> R): R {
+        val res = body()
+        log.info(msg + "" = "" + res.toString())
+        return res
+    }
+
+    override fun getCompilerId(): CompilerId = ifAlive { selfCompilerId }
+
+    override fun getUsedMemory(): Long = ifAlive { usedMemory() }
+
+    override fun shutdown() {
+        ifAliveExclusive {
+            log.info(""Shutdown started"")
+            alive = false
+            UnicastRemoteObject.unexportObject(this, true)
+            log.info(""Shutdown complete"")
+        }
+    }
+
+    override fun remoteCompile(args: Array<out String>, errStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =
+        doCompile(args, errStream) { printStream ->
+            when (outputFormat) {
+                CompileService.OutputFormat.PLAIN -> compiler.exec(printStream, *args)
+                CompileService.OutputFormat.XML -> compiler.execAndOutputXml(printStream, Services.EMPTY, *args)
+            }.code
+        }
+
+    override fun remoteIncrementalCompile(args: Array<out String>, caches: Map<String, CompileService.RemoteIncrementalCache>, outputStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =
+        doCompile(args, outputStream) { printStream ->
+            when (outputFormat) {
+                CompileService.OutputFormat.PLAIN -> throw NotImplementedError(""Only XML output is supported in remote incremental compilation"")
+                CompileService.OutputFormat.XML -> compiler.execAndOutputXml(printStream, createCompileServices(caches), *args)
+            }.code
+        }
+
+    fun doCompile(args: Array<out String>, errStream: RemoteOutputStream, body: (PrintStream) -> Int): Int =","I'd write something like:

``` kotlin
    override fun remoteCompile(args: Array<out String>, errStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =
        doCompile(args, errStream, outputFormat) { compiler.exec(it, *args) }

    override fun remoteIncrementalCompile(args: Array<out String>, caches: Map<String, CompileService.RemoteIncrementalCache>, outputStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =
        doCompile(args, outputStream, outputFormat) { throw NotImplementedError(""Only XML output is supported in remote incremental compilation"") }

    fun doCompile(args: Array<out String>, errStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat, compileWithPlainOut: (PrintStream) -> ExitCode): Int =
            ifAlive {
                checkedCompile(args) {
                    val remoteStreamClient = RemoteOutputStreamClient(errStream)
                    val printStream = PrintStream(remoteStreamClient)
                    when (outputFormat) {
                        CompileService.OutputFormat.PLAIN -> compileWithPlainOut(printStream)
                        CompileService.OutputFormat.XML -> compiler.execAndOutputXml(printStream, Services.EMPTY, *args)
                    }.code
                }
            }
```
",I don't think we need `val` here.
145,"@@ -0,0 +1,203 @@
+/*","As far as I understand these functions are copies of functions at KotlinBuilder. Why not to reuse them at KotlinBuilder? I mean, these functions are in build common, so their originals from KotlinBuilder can be removed.
",Why is this needed?
146,"@@ -0,0 +1,204 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen
+
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
+import org.jetbrains.kotlin.codegen.context.CodegenContext
+import org.jetbrains.kotlin.codegen.state.GenerationState
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.JetClass
+import org.jetbrains.kotlin.psi.JetClassOrObject
+import org.jetbrains.kotlin.psi.JetElement
+import org.jetbrains.kotlin.psi.JetNamedFunction
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.org.objectweb.asm.Opcodes
+import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
+
+/**
+ * Generates Java overloads for functions and constructors that have the default
+ * parameter values substituted.
+ */
+public class DefaultParameterValueSubstitutor(val state: GenerationState) {
+    /**
+     * If all of the parameters of the specified constructor declare default values,
+     * generates a no-argument constructor that passes default values for all arguments.
+     */
+    fun generateDefaultConstructorIfNeeded(constructorDescriptor: ConstructorDescriptor,
+                                           classBuilder: ClassBuilder,
+                                           context: CodegenContext<*>,
+                                           classOrObject: JetClassOrObject) {
+        if (!isEmptyConstructorNeeded(constructorDescriptor, classOrObject)) {
+            return
+        }
+
+        generateOverloadWithSubstitutedParameters(constructorDescriptor, constructorDescriptor, classBuilder, classOrObject,
+                                                  context,
+                                                  constructorDescriptor.countDefaultParameters())
+    }
+
+    /**
+     * If the function is annotated with [kotlin.jvm.overloads], generates Java methods that
+     * have the default parameter values substituted. If a method has N parameters and M of which
+     * have default values, M overloads are generated: the first one takes N-1 parameters (all but
+     * the last one that takes a default value), the second takes N-2 parameters, and so on.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     */
+    fun generateOverloadsIfNeeded(function: JetNamedFunction,
+                                  functionDescriptor: FunctionDescriptor,
+                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                  owner: CodegenContext<*>,
+                                  classBuilder: ClassBuilder) {
+        val overloadsFqName = FqName.fromSegments(listOf(""kotlin"", ""jvm"", ""overloads""))","`FqName(""kotlin.jvm.overloads"")` would be more grep-friendly. Also I would make it a constant (either top-level or in the companion)
",I don't think we need this class.
147,"@@ -0,0 +1,204 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen
+
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
+import org.jetbrains.kotlin.codegen.context.CodegenContext
+import org.jetbrains.kotlin.codegen.state.GenerationState
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.JetClass
+import org.jetbrains.kotlin.psi.JetClassOrObject
+import org.jetbrains.kotlin.psi.JetElement
+import org.jetbrains.kotlin.psi.JetNamedFunction
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.org.objectweb.asm.Opcodes
+import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
+
+/**
+ * Generates Java overloads for functions and constructors that have the default
+ * parameter values substituted.
+ */
+public class DefaultParameterValueSubstitutor(val state: GenerationState) {
+    /**
+     * If all of the parameters of the specified constructor declare default values,
+     * generates a no-argument constructor that passes default values for all arguments.
+     */
+    fun generateDefaultConstructorIfNeeded(constructorDescriptor: ConstructorDescriptor,
+                                           classBuilder: ClassBuilder,
+                                           context: CodegenContext<*>,
+                                           classOrObject: JetClassOrObject) {
+        if (!isEmptyConstructorNeeded(constructorDescriptor, classOrObject)) {
+            return
+        }
+
+        generateOverloadWithSubstitutedParameters(constructorDescriptor, constructorDescriptor, classBuilder, classOrObject,
+                                                  context,
+                                                  constructorDescriptor.countDefaultParameters())
+    }
+
+    /**
+     * If the function is annotated with [kotlin.jvm.overloads], generates Java methods that
+     * have the default parameter values substituted. If a method has N parameters and M of which
+     * have default values, M overloads are generated: the first one takes N-1 parameters (all but
+     * the last one that takes a default value), the second takes N-2 parameters, and so on.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     */
+    fun generateOverloadsIfNeeded(function: JetNamedFunction,
+                                  functionDescriptor: FunctionDescriptor,
+                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                  owner: CodegenContext<*>,
+                                  classBuilder: ClassBuilder) {
+        val overloadsFqName = FqName.fromSegments(listOf(""kotlin"", ""jvm"", ""overloads""))
+        if (functionDescriptor.getAnnotations().findAnnotation(overloadsFqName) == null) return
+
+        val count = functionDescriptor.countDefaultParameters()
+        val context = owner.intoFunction(functionDescriptor)
+
+        for (i in 1..count) {
+            generateOverloadWithSubstitutedParameters(functionDescriptor, delegateFunctionDescriptor, classBuilder, function, context, i)
+        }
+    }
+
+    private fun FunctionDescriptor.countDefaultParameters() =
+        getValueParameters().count { it.hasDefaultValue() }
+
+    /**
+     * Generates an overload for [functionDescriptor] that substitutes default values for the last
+     * [substituteCount] parameters that have default values.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     * @param methodElement the PSI element for the method implementation (used in diagnostic messages only)
+     */
+    fun generateOverloadWithSubstitutedParameters(functionDescriptor: FunctionDescriptor,
+                                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                                  classBuilder: ClassBuilder,
+                                                  methodElement: JetElement?,
+                                                  context: CodegenContext<*>,
+                                                  substituteCount: Int) {
+        val isStatic = AsmUtil.isStaticMethod(context.getContextKind(), functionDescriptor)
+        val flags = AsmUtil.getVisibilityAccessFlag(functionDescriptor) or (if (isStatic) Opcodes.ACC_STATIC else 0)
+        val remainingParameters = getRemainingParameters(functionDescriptor.getOriginal(), substituteCount)
+        val signature = state.getTypeMapper().mapSignature(functionDescriptor, context.getContextKind(),","Please extract `state.getTypeMapper()` to a property
",I don't think we need this class.
148,"@@ -0,0 +1,204 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen
+
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
+import org.jetbrains.kotlin.codegen.context.CodegenContext
+import org.jetbrains.kotlin.codegen.state.GenerationState
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.JetClass
+import org.jetbrains.kotlin.psi.JetClassOrObject
+import org.jetbrains.kotlin.psi.JetElement
+import org.jetbrains.kotlin.psi.JetNamedFunction
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.org.objectweb.asm.Opcodes
+import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
+
+/**
+ * Generates Java overloads for functions and constructors that have the default
+ * parameter values substituted.
+ */
+public class DefaultParameterValueSubstitutor(val state: GenerationState) {
+    /**
+     * If all of the parameters of the specified constructor declare default values,
+     * generates a no-argument constructor that passes default values for all arguments.
+     */
+    fun generateDefaultConstructorIfNeeded(constructorDescriptor: ConstructorDescriptor,
+                                           classBuilder: ClassBuilder,
+                                           context: CodegenContext<*>,
+                                           classOrObject: JetClassOrObject) {
+        if (!isEmptyConstructorNeeded(constructorDescriptor, classOrObject)) {
+            return
+        }
+
+        generateOverloadWithSubstitutedParameters(constructorDescriptor, constructorDescriptor, classBuilder, classOrObject,
+                                                  context,
+                                                  constructorDescriptor.countDefaultParameters())
+    }
+
+    /**
+     * If the function is annotated with [kotlin.jvm.overloads], generates Java methods that
+     * have the default parameter values substituted. If a method has N parameters and M of which
+     * have default values, M overloads are generated: the first one takes N-1 parameters (all but
+     * the last one that takes a default value), the second takes N-2 parameters, and so on.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     */
+    fun generateOverloadsIfNeeded(function: JetNamedFunction,
+                                  functionDescriptor: FunctionDescriptor,
+                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                  owner: CodegenContext<*>,
+                                  classBuilder: ClassBuilder) {
+        val overloadsFqName = FqName.fromSegments(listOf(""kotlin"", ""jvm"", ""overloads""))
+        if (functionDescriptor.getAnnotations().findAnnotation(overloadsFqName) == null) return
+
+        val count = functionDescriptor.countDefaultParameters()
+        val context = owner.intoFunction(functionDescriptor)
+
+        for (i in 1..count) {
+            generateOverloadWithSubstitutedParameters(functionDescriptor, delegateFunctionDescriptor, classBuilder, function, context, i)
+        }
+    }
+
+    private fun FunctionDescriptor.countDefaultParameters() =
+        getValueParameters().count { it.hasDefaultValue() }
+
+    /**
+     * Generates an overload for [functionDescriptor] that substitutes default values for the last
+     * [substituteCount] parameters that have default values.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     * @param methodElement the PSI element for the method implementation (used in diagnostic messages only)
+     */
+    fun generateOverloadWithSubstitutedParameters(functionDescriptor: FunctionDescriptor,
+                                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                                  classBuilder: ClassBuilder,
+                                                  methodElement: JetElement?,
+                                                  context: CodegenContext<*>,
+                                                  substituteCount: Int) {
+        val isStatic = AsmUtil.isStaticMethod(context.getContextKind(), functionDescriptor)
+        val flags = AsmUtil.getVisibilityAccessFlag(functionDescriptor) or (if (isStatic) Opcodes.ACC_STATIC else 0)
+        val remainingParameters = getRemainingParameters(functionDescriptor.getOriginal(), substituteCount)
+        val signature = state.getTypeMapper().mapSignature(functionDescriptor, context.getContextKind(),
+                                                           remainingParameters)
+        val mv = classBuilder.newMethod(OtherOrigin(functionDescriptor), flags,
+                                        signature.getAsmMethod().getName(),
+                                        signature.getAsmMethod().getDescriptor(), null,
+                                        FunctionCodegen.getThrownExceptions(functionDescriptor, state.getTypeMapper()))
+
+        if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES) return
+
+        val frameMap = FrameMap()
+        val v = InstructionAdapter(mv)
+        mv.visitCode()
+
+        val methodOwner = state.getTypeMapper().mapToCallableMethod(delegateFunctionDescriptor, false, context).getOwner()
+        if (!isStatic) {
+            frameMap.enterTemp(AsmTypes.OBJECT_TYPE)
+            v.load(0, methodOwner) // Load this on stack","Maybe use the value returned by `enterTemp` instead of `0` for better readability
",I don't think we need this class.
149,"@@ -0,0 +1,204 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen
+
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
+import org.jetbrains.kotlin.codegen.context.CodegenContext
+import org.jetbrains.kotlin.codegen.state.GenerationState
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.JetClass
+import org.jetbrains.kotlin.psi.JetClassOrObject
+import org.jetbrains.kotlin.psi.JetElement
+import org.jetbrains.kotlin.psi.JetNamedFunction
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.org.objectweb.asm.Opcodes
+import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
+
+/**
+ * Generates Java overloads for functions and constructors that have the default
+ * parameter values substituted.
+ */
+public class DefaultParameterValueSubstitutor(val state: GenerationState) {
+    /**
+     * If all of the parameters of the specified constructor declare default values,
+     * generates a no-argument constructor that passes default values for all arguments.
+     */
+    fun generateDefaultConstructorIfNeeded(constructorDescriptor: ConstructorDescriptor,
+                                           classBuilder: ClassBuilder,
+                                           context: CodegenContext<*>,
+                                           classOrObject: JetClassOrObject) {
+        if (!isEmptyConstructorNeeded(constructorDescriptor, classOrObject)) {
+            return
+        }
+
+        generateOverloadWithSubstitutedParameters(constructorDescriptor, constructorDescriptor, classBuilder, classOrObject,
+                                                  context,
+                                                  constructorDescriptor.countDefaultParameters())
+    }
+
+    /**
+     * If the function is annotated with [kotlin.jvm.overloads], generates Java methods that
+     * have the default parameter values substituted. If a method has N parameters and M of which
+     * have default values, M overloads are generated: the first one takes N-1 parameters (all but
+     * the last one that takes a default value), the second takes N-2 parameters, and so on.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     */
+    fun generateOverloadsIfNeeded(function: JetNamedFunction,
+                                  functionDescriptor: FunctionDescriptor,
+                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                  owner: CodegenContext<*>,
+                                  classBuilder: ClassBuilder) {
+        val overloadsFqName = FqName.fromSegments(listOf(""kotlin"", ""jvm"", ""overloads""))
+        if (functionDescriptor.getAnnotations().findAnnotation(overloadsFqName) == null) return
+
+        val count = functionDescriptor.countDefaultParameters()
+        val context = owner.intoFunction(functionDescriptor)
+
+        for (i in 1..count) {
+            generateOverloadWithSubstitutedParameters(functionDescriptor, delegateFunctionDescriptor, classBuilder, function, context, i)
+        }
+    }
+
+    private fun FunctionDescriptor.countDefaultParameters() =
+        getValueParameters().count { it.hasDefaultValue() }
+
+    /**
+     * Generates an overload for [functionDescriptor] that substitutes default values for the last
+     * [substituteCount] parameters that have default values.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     * @param methodElement the PSI element for the method implementation (used in diagnostic messages only)
+     */
+    fun generateOverloadWithSubstitutedParameters(functionDescriptor: FunctionDescriptor,
+                                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                                  classBuilder: ClassBuilder,
+                                                  methodElement: JetElement?,
+                                                  context: CodegenContext<*>,
+                                                  substituteCount: Int) {
+        val isStatic = AsmUtil.isStaticMethod(context.getContextKind(), functionDescriptor)
+        val flags = AsmUtil.getVisibilityAccessFlag(functionDescriptor) or (if (isStatic) Opcodes.ACC_STATIC else 0)
+        val remainingParameters = getRemainingParameters(functionDescriptor.getOriginal(), substituteCount)
+        val signature = state.getTypeMapper().mapSignature(functionDescriptor, context.getContextKind(),
+                                                           remainingParameters)
+        val mv = classBuilder.newMethod(OtherOrigin(functionDescriptor), flags,
+                                        signature.getAsmMethod().getName(),
+                                        signature.getAsmMethod().getDescriptor(), null,
+                                        FunctionCodegen.getThrownExceptions(functionDescriptor, state.getTypeMapper()))
+
+        if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES) return
+
+        val frameMap = FrameMap()
+        val v = InstructionAdapter(mv)
+        mv.visitCode()
+
+        val methodOwner = state.getTypeMapper().mapToCallableMethod(delegateFunctionDescriptor, false, context).getOwner()
+        if (!isStatic) {
+            frameMap.enterTemp(AsmTypes.OBJECT_TYPE)
+            v.load(0, methodOwner) // Load this on stack
+        } else {","`else` should be on the next line :) Several times in this file
",I don't think we need this class.
150,"@@ -0,0 +1,204 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen
+
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding
+import org.jetbrains.kotlin.codegen.context.CodegenContext
+import org.jetbrains.kotlin.codegen.state.GenerationState
+import org.jetbrains.kotlin.descriptors.*
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.JetClass
+import org.jetbrains.kotlin.psi.JetClassOrObject
+import org.jetbrains.kotlin.psi.JetElement
+import org.jetbrains.kotlin.psi.JetNamedFunction
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.jvm.diagnostics.OtherOrigin
+import org.jetbrains.org.objectweb.asm.Opcodes
+import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter
+
+/**
+ * Generates Java overloads for functions and constructors that have the default
+ * parameter values substituted.
+ */
+public class DefaultParameterValueSubstitutor(val state: GenerationState) {
+    /**
+     * If all of the parameters of the specified constructor declare default values,
+     * generates a no-argument constructor that passes default values for all arguments.
+     */
+    fun generateDefaultConstructorIfNeeded(constructorDescriptor: ConstructorDescriptor,
+                                           classBuilder: ClassBuilder,
+                                           context: CodegenContext<*>,
+                                           classOrObject: JetClassOrObject) {
+        if (!isEmptyConstructorNeeded(constructorDescriptor, classOrObject)) {
+            return
+        }
+
+        generateOverloadWithSubstitutedParameters(constructorDescriptor, constructorDescriptor, classBuilder, classOrObject,
+                                                  context,
+                                                  constructorDescriptor.countDefaultParameters())
+    }
+
+    /**
+     * If the function is annotated with [kotlin.jvm.overloads], generates Java methods that
+     * have the default parameter values substituted. If a method has N parameters and M of which
+     * have default values, M overloads are generated: the first one takes N-1 parameters (all but
+     * the last one that takes a default value), the second takes N-2 parameters, and so on.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     */
+    fun generateOverloadsIfNeeded(function: JetNamedFunction,
+                                  functionDescriptor: FunctionDescriptor,
+                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                  owner: CodegenContext<*>,
+                                  classBuilder: ClassBuilder) {
+        val overloadsFqName = FqName.fromSegments(listOf(""kotlin"", ""jvm"", ""overloads""))
+        if (functionDescriptor.getAnnotations().findAnnotation(overloadsFqName) == null) return
+
+        val count = functionDescriptor.countDefaultParameters()
+        val context = owner.intoFunction(functionDescriptor)
+
+        for (i in 1..count) {
+            generateOverloadWithSubstitutedParameters(functionDescriptor, delegateFunctionDescriptor, classBuilder, function, context, i)
+        }
+    }
+
+    private fun FunctionDescriptor.countDefaultParameters() =
+        getValueParameters().count { it.hasDefaultValue() }
+
+    /**
+     * Generates an overload for [functionDescriptor] that substitutes default values for the last
+     * [substituteCount] parameters that have default values.
+     *
+     * @param functionDescriptor the method for which the overloads are generated
+     * @param delegateFunctionDescriptor the method descriptor for the implementation that we need to call
+     *     (same as [functionDescriptor] in all cases except for companion object methods annotated with [platformStatic],
+     *     where [functionDescriptor] is the static method in the main class and [delegateFunctionDescriptor] is the
+     *     implementation in the companion object class)
+     * @param methodElement the PSI element for the method implementation (used in diagnostic messages only)
+     */
+    fun generateOverloadWithSubstitutedParameters(functionDescriptor: FunctionDescriptor,
+                                                  delegateFunctionDescriptor: FunctionDescriptor,
+                                                  classBuilder: ClassBuilder,
+                                                  methodElement: JetElement?,
+                                                  context: CodegenContext<*>,
+                                                  substituteCount: Int) {
+        val isStatic = AsmUtil.isStaticMethod(context.getContextKind(), functionDescriptor)
+        val flags = AsmUtil.getVisibilityAccessFlag(functionDescriptor) or (if (isStatic) Opcodes.ACC_STATIC else 0)
+        val remainingParameters = getRemainingParameters(functionDescriptor.getOriginal(), substituteCount)
+        val signature = state.getTypeMapper().mapSignature(functionDescriptor, context.getContextKind(),
+                                                           remainingParameters)
+        val mv = classBuilder.newMethod(OtherOrigin(functionDescriptor), flags,
+                                        signature.getAsmMethod().getName(),
+                                        signature.getAsmMethod().getDescriptor(), null,
+                                        FunctionCodegen.getThrownExceptions(functionDescriptor, state.getTypeMapper()))
+
+        if (state.getClassBuilderMode() == ClassBuilderMode.LIGHT_CLASSES) return
+
+        val frameMap = FrameMap()
+        val v = InstructionAdapter(mv)
+        mv.visitCode()
+
+        val methodOwner = state.getTypeMapper().mapToCallableMethod(delegateFunctionDescriptor, false, context).getOwner()
+        if (!isStatic) {
+            frameMap.enterTemp(AsmTypes.OBJECT_TYPE)
+            v.load(0, methodOwner) // Load this on stack
+        } else {
+            val delegateOwner = delegateFunctionDescriptor.getContainingDeclaration()
+            if (delegateOwner is ClassDescriptor && delegateOwner.isCompanionObject()) {
+                val singletonValue = StackValue.singleton(delegateOwner, state.getTypeMapper())
+                singletonValue.put(singletonValue.type, v);
+            }
+        }
+
+        val receiver = functionDescriptor.getExtensionReceiverParameter()
+        if (receiver != null) {
+            val receiverType = state.getTypeMapper().mapType(receiver)
+            val receiverIndex = frameMap.enter(receiver, receiverType)
+            StackValue.local(receiverIndex, receiverType).put(receiverType, v)
+        }
+        remainingParameters.forEach {
+            frameMap.enter(it, state.getTypeMapper().mapType(it))
+        }
+
+        var mask = 0
+        val masks = arrayListOf<Int>()
+        for (parameterDescriptor in functionDescriptor.getValueParameters()) {
+            val paramType = state.getTypeMapper().mapType(parameterDescriptor.getType())
+            if (parameterDescriptor in remainingParameters) {
+                val index = frameMap.getIndex(parameterDescriptor)
+                val type = state.getTypeMapper().mapType(parameterDescriptor)","Already calculated a little earlier (`paramType`)
",I don't think we need this class.
151,"@@ -0,0 +1,205 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.jvm.compiler
+
+import com.intellij.testFramework.TestDataPath
+import org.jetbrains.kotlin.test.JUnit3RunnerWithInners
+import org.jetbrains.kotlin.test.KotlinTestUtils
+import org.jetbrains.kotlin.test.TestMetadata
+import org.junit.runner.RunWith
+
+@SuppressWarnings(""all"")
+@TestMetadata(""compiler/testData/compileKotlinAgainstJava"")
+@TestDataPath(""\$PROJECT_ROOT"")
+@RunWith(JUnit3RunnerWithInners::class)
+class CompileKotlinAgainstJavaTest : AbstractCompileJavaAgainstKotlinTest() {",`CompileKotlinAgainstJava` but `AbstractCompilerJavaAgainstKotlin`? Looks very strange,I don't think we need this annota
152,"@@ -0,0 +1,207 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.descriptors.DeclarationDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticFactory1;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class MapPlatformClassToKotlinFix extends JetIntentionAction<JetReferenceExpression> {
+    private static final String PRIMARY_USAGE = ""PrimaryUsage"";
+    private static final String OTHER_USAGE = ""OtherUsage"";
+
+    private final ClassDescriptor platformClass;
+    private final Collection<ClassDescriptor> possibleClasses;
+
+    public MapPlatformClassToKotlinFix(@NotNull JetReferenceExpression element, @NotNull ClassDescriptor platformClass,
+            @NotNull Collection<ClassDescriptor> possibleClasses) {
+        super(element);
+        this.platformClass = platformClass;
+        this.possibleClasses = possibleClasses;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+
+        String platformClassQualifiedName = DescriptorRenderer.TEXT.renderType(platformClass.getDefaultType());
+        return possibleClasses.size() == 1
+               ? JetBundle.message(""map.platform.class.to.kotlin"", platformClassQualifiedName,
+                                   DescriptorRenderer.TEXT.renderType(possibleClasses.iterator().next().getDefaultType()))
+               : JetBundle.message(""map.platform.class.to.kotlin.multiple"", platformClassQualifiedName);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""map.platform.class.to.kotlin.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {","This method is pretty long. Consider extracting methods for it. First candidate for extracting is code about live template in the end of the method.
",Please don't use wildcard imports
153,"@@ -0,0 +1,207 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.descriptors.DeclarationDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticFactory1;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class MapPlatformClassToKotlinFix extends JetIntentionAction<JetReferenceExpression> {
+    private static final String PRIMARY_USAGE = ""PrimaryUsage"";
+    private static final String OTHER_USAGE = ""OtherUsage"";
+
+    private final ClassDescriptor platformClass;
+    private final Collection<ClassDescriptor> possibleClasses;
+
+    public MapPlatformClassToKotlinFix(@NotNull JetReferenceExpression element, @NotNull ClassDescriptor platformClass,
+            @NotNull Collection<ClassDescriptor> possibleClasses) {
+        super(element);
+        this.platformClass = platformClass;
+        this.possibleClasses = possibleClasses;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+
+        String platformClassQualifiedName = DescriptorRenderer.TEXT.renderType(platformClass.getDefaultType());
+        return possibleClasses.size() == 1
+               ? JetBundle.message(""map.platform.class.to.kotlin"", platformClassQualifiedName,
+                                   DescriptorRenderer.TEXT.renderType(possibleClasses.iterator().next().getDefaultType()))
+               : JetBundle.message(""map.platform.class.to.kotlin.multiple"", platformClassQualifiedName);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""map.platform.class.to.kotlin.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        BindingContext context = KotlinCacheManager.getInstance(project).getDeclarationsFromProject().getBindingContext();
+        Collection<Diagnostic> diagnostics = context.getDiagnostics();
+        List<JetImportDirective> imports = new ArrayList<JetImportDirective>();
+        List<JetUserType> usages = new ArrayList<JetUserType>();
+
+        for (Diagnostic diagnostic : diagnostics) {
+            if (diagnostic.getFactory() != Errors.PLATFORM_CLASS_MAPPED_TO_KOTLIN) continue;
+            JetReferenceExpression refExpr = getImportOrUsageFromDiagnostic(diagnostic);
+            if (refExpr == null) continue;
+            DeclarationDescriptor descriptor = context.get(BindingContext.REFERENCE_TARGET, refExpr);
+            if (descriptor == null || !(descriptor.equals(platformClass))) continue;","Is this check necessary? Maybe remove it or replace with assert?
",Please don't use wildcard imports
154,"@@ -0,0 +1,207 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.descriptors.DeclarationDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticFactory1;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class MapPlatformClassToKotlinFix extends JetIntentionAction<JetReferenceExpression> {
+    private static final String PRIMARY_USAGE = ""PrimaryUsage"";
+    private static final String OTHER_USAGE = ""OtherUsage"";
+
+    private final ClassDescriptor platformClass;
+    private final Collection<ClassDescriptor> possibleClasses;
+
+    public MapPlatformClassToKotlinFix(@NotNull JetReferenceExpression element, @NotNull ClassDescriptor platformClass,
+            @NotNull Collection<ClassDescriptor> possibleClasses) {
+        super(element);
+        this.platformClass = platformClass;
+        this.possibleClasses = possibleClasses;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+
+        String platformClassQualifiedName = DescriptorRenderer.TEXT.renderType(platformClass.getDefaultType());
+        return possibleClasses.size() == 1
+               ? JetBundle.message(""map.platform.class.to.kotlin"", platformClassQualifiedName,
+                                   DescriptorRenderer.TEXT.renderType(possibleClasses.iterator().next().getDefaultType()))
+               : JetBundle.message(""map.platform.class.to.kotlin.multiple"", platformClassQualifiedName);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""map.platform.class.to.kotlin.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        BindingContext context = KotlinCacheManager.getInstance(project).getDeclarationsFromProject().getBindingContext();
+        Collection<Diagnostic> diagnostics = context.getDiagnostics();
+        List<JetImportDirective> imports = new ArrayList<JetImportDirective>();
+        List<JetUserType> usages = new ArrayList<JetUserType>();
+
+        for (Diagnostic diagnostic : diagnostics) {
+            if (diagnostic.getFactory() != Errors.PLATFORM_CLASS_MAPPED_TO_KOTLIN) continue;
+            JetReferenceExpression refExpr = getImportOrUsageFromDiagnostic(diagnostic);
+            if (refExpr == null) continue;
+            DeclarationDescriptor descriptor = context.get(BindingContext.REFERENCE_TARGET, refExpr);
+            if (descriptor == null || !(descriptor.equals(platformClass))) continue;
+            JetImportDirective imp = PsiTreeUtil.getParentOfType(refExpr, JetImportDirective.class);
+            if (imp == null) {
+                JetUserType type = PsiTreeUtil.getParentOfType(refExpr, JetUserType.class);
+                if (type == null) continue;
+                usages.add(type);
+            } else {
+                imports.add(imp);
+            }
+        }
+
+        ClassDescriptor replacementClass = possibleClasses.iterator().next();
+        String replacementClassName = replacementClass.getName().getName();
+        List<JetExpression> replacedExpressions = new ArrayList<JetExpression>();
+        for (JetImportDirective imp : imports) {
+            imp.delete();
+        }
+        for (JetUserType usage : usages) {
+            JetTypeArgumentList typeArguments = usage.getTypeArgumentList();
+            String typeArgumentsString = typeArguments == null ? """" : typeArguments.getText();
+            JetTypeReference replacementType = JetPsiFactory.createType(project, replacementClassName + typeArgumentsString);
+            JetTypeElement replacementTypeElement = replacementType.getTypeElement();
+            assert replacementTypeElement != null;
+            PsiElement replacedElement = usage.replace(replacementTypeElement);
+            PsiElement replacedExpression = replacedElement.getFirstChild();
+            assert replacedExpression instanceof JetSimpleNameExpression; // assumption: the Kotlin class requires no imports
+            replacedExpressions.add((JetExpression) replacedExpression);
+        }
+
+        if (replacedExpressions.size() == 0) { // if we didn't replace any usages, there's no reason to even give a choice","This condition is equivalent to usages.isEmpty(), which is more straightforward and can be checked before loop.
",Please don't use wildcard imports
155,"@@ -0,0 +1,207 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.ClassDescriptor;
+import org.jetbrains.jet.lang.descriptors.DeclarationDescriptor;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticFactory1;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.diagnostics.Errors;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManager;
+import org.jetbrains.jet.renderer.DescriptorRenderer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class MapPlatformClassToKotlinFix extends JetIntentionAction<JetReferenceExpression> {
+    private static final String PRIMARY_USAGE = ""PrimaryUsage"";
+    private static final String OTHER_USAGE = ""OtherUsage"";
+
+    private final ClassDescriptor platformClass;
+    private final Collection<ClassDescriptor> possibleClasses;
+
+    public MapPlatformClassToKotlinFix(@NotNull JetReferenceExpression element, @NotNull ClassDescriptor platformClass,
+            @NotNull Collection<ClassDescriptor> possibleClasses) {
+        super(element);
+        this.platformClass = platformClass;
+        this.possibleClasses = possibleClasses;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+
+        String platformClassQualifiedName = DescriptorRenderer.TEXT.renderType(platformClass.getDefaultType());
+        return possibleClasses.size() == 1
+               ? JetBundle.message(""map.platform.class.to.kotlin"", platformClassQualifiedName,
+                                   DescriptorRenderer.TEXT.renderType(possibleClasses.iterator().next().getDefaultType()))
+               : JetBundle.message(""map.platform.class.to.kotlin.multiple"", platformClassQualifiedName);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""map.platform.class.to.kotlin.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        BindingContext context = KotlinCacheManager.getInstance(project).getDeclarationsFromProject().getBindingContext();
+        Collection<Diagnostic> diagnostics = context.getDiagnostics();
+        List<JetImportDirective> imports = new ArrayList<JetImportDirective>();
+        List<JetUserType> usages = new ArrayList<JetUserType>();
+
+        for (Diagnostic diagnostic : diagnostics) {
+            if (diagnostic.getFactory() != Errors.PLATFORM_CLASS_MAPPED_TO_KOTLIN) continue;
+            JetReferenceExpression refExpr = getImportOrUsageFromDiagnostic(diagnostic);
+            if (refExpr == null) continue;
+            DeclarationDescriptor descriptor = context.get(BindingContext.REFERENCE_TARGET, refExpr);
+            if (descriptor == null || !(descriptor.equals(platformClass))) continue;
+            JetImportDirective imp = PsiTreeUtil.getParentOfType(refExpr, JetImportDirective.class);
+            if (imp == null) {
+                JetUserType type = PsiTreeUtil.getParentOfType(refExpr, JetUserType.class);
+                if (type == null) continue;
+                usages.add(type);
+            } else {
+                imports.add(imp);
+            }
+        }
+
+        ClassDescriptor replacementClass = possibleClasses.iterator().next();
+        String replacementClassName = replacementClass.getName().getName();
+        List<JetExpression> replacedExpressions = new ArrayList<JetExpression>();
+        for (JetImportDirective imp : imports) {
+            imp.delete();
+        }
+        for (JetUserType usage : usages) {
+            JetTypeArgumentList typeArguments = usage.getTypeArgumentList();
+            String typeArgumentsString = typeArguments == null ? """" : typeArguments.getText();
+            JetTypeReference replacementType = JetPsiFactory.createType(project, replacementClassName + typeArgumentsString);
+            JetTypeElement replacementTypeElement = replacementType.getTypeElement();
+            assert replacementTypeElement != null;
+            PsiElement replacedElement = usage.replace(replacementTypeElement);
+            PsiElement replacedExpression = replacedElement.getFirstChild();
+            assert replacedExpression instanceof JetSimpleNameExpression; // assumption: the Kotlin class requires no imports
+            replacedExpressions.add((JetExpression) replacedExpression);
+        }
+
+        if (replacedExpressions.size() == 0) { // if we didn't replace any usages, there's no reason to even give a choice
+            return;
+        }
+
+        if (possibleClasses.size() > 1) {
+            PsiDocumentManager.getInstance(project).commitAllDocuments();
+            PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(editor.getDocument());
+
+            PsiElement primaryReplacedExpression = replacedExpressions.iterator().next();
+
+            final CaretModel caretModel = editor.getCaretModel();
+            final int oldOffset = caretModel.getOffset();
+            caretModel.moveToOffset(file.getNode().getStartOffset());
+
+            LinkedHashSet<String> possibleTypes = new LinkedHashSet<String>();
+            for (ClassDescriptor klass : possibleClasses) {
+                possibleTypes.add(klass.getName().getName());
+            }
+
+            TemplateBuilderImpl builder = new TemplateBuilderImpl(file);
+            Expression expression = new MyLookupExpression(primaryReplacedExpression.getText(), possibleTypes, null, false,
+                                                           JetBundle.message(""map.platform.class.to.kotlin.advertisement""));
+
+            builder.replaceElement(primaryReplacedExpression, PRIMARY_USAGE, expression, true);
+            for (PsiElement replacedExpression : replacedExpressions) {
+                if (replacedExpression == primaryReplacedExpression) continue;
+                builder.replaceElement(replacedExpression, OTHER_USAGE, PRIMARY_USAGE, false);
+            }
+            TemplateManager.getInstance(project).startTemplate(editor, builder.buildInlineTemplate(), new TemplateEditingAdapter() {
+                @Override
+                public void templateFinished(Template template, boolean brokenOff) {
+                    caretModel.moveToOffset(oldOffset);
+                }
+            });
+        }
+    }
+
+    private static JetReferenceExpression getImportOrUsageFromDiagnostic(@NotNull Diagnostic diagnostic) {
+        JetImportDirective imp = QuickFixUtil.getParentElementOfType(diagnostic, JetImportDirective.class);
+        JetReferenceExpression typeExpr;
+        if (imp == null) {
+            JetUserType type = QuickFixUtil.getParentElementOfType(diagnostic, JetUserType.class);
+            if (type == null) return null;
+            typeExpr = type.getReferenceExpression();
+        } else {
+            JetExpression importRef = imp.getImportedReference();
+            if (importRef == null || !(importRef instanceof JetDotQualifiedExpression)) return null;
+            JetExpression refExpr = ((JetDotQualifiedExpression) importRef).getSelectorExpression();
+            if (refExpr == null || !(refExpr instanceof JetReferenceExpression)) return null;
+            typeExpr = (JetReferenceExpression) refExpr;
+        }
+        return typeExpr;
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                assert diagnostic.getFactory() instanceof DiagnosticFactory1;
+
+                JetReferenceExpression typeExpr = getImportOrUsageFromDiagnostic(diagnostic);
+                if (typeExpr == null) return null;
+
+                BindingContext context = KotlinCacheManager.getInstance(diagnostic.getPsiFile().getProject()).getDeclarationsFromProject().getBindingContext();
+                DeclarationDescriptor descriptor = context.get(BindingContext.REFERENCE_TARGET, typeExpr);
+                if (descriptor == null || !(descriptor instanceof ClassDescriptor)) return null;
+                ClassDescriptor platformClass = (ClassDescriptor) descriptor;
+
+                @SuppressWarnings(""unchecked"")
+                DiagnosticWithParameters1 parametrizedDiagnostic = (DiagnosticWithParameters1) diagnostic;","All the boilerplate starting from this line can be avoided by casting to DiagnosticWithParameters1<JetElement, Collection<ClassDescriptor>> instead of raw type.
",Please don't use wildcard imports
156,"@@ -0,0 +1,208 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.j2k
+
+import com.intellij.psi.CommonClassNames.*
+import com.intellij.psi.PsiField
+import org.jetbrains.kotlin.builtins.PrimitiveType
+import org.jetbrains.kotlin.j2k.ast.Expression
+import org.jetbrains.kotlin.j2k.ast.Identifier
+import org.jetbrains.kotlin.j2k.ast.QualifiedExpression
+
+enum class SpecialFiled(val qualifiedClassName: String?, val fieldName: String) {","SpecialField
",I don't think we need this.
157,"@@ -0,0 +1,208 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.j2k
+
+import com.intellij.psi.CommonClassNames.*
+import com.intellij.psi.PsiField
+import org.jetbrains.kotlin.builtins.PrimitiveType
+import org.jetbrains.kotlin.j2k.ast.Expression
+import org.jetbrains.kotlin.j2k.ast.Identifier
+import org.jetbrains.kotlin.j2k.ast.QualifiedExpression
+
+enum class SpecialFiled(val qualifiedClassName: String?, val fieldName: String) {
+
+    BYTE_MAX_VALUE(JAVA_LANG_BYTE, ""MAX_VALUE"") {","You should not hard-code all possible constants.
",I don't think we need this enum.
158,"@@ -0,0 +1,21 @@
+//method","You need to include the generated test class into your commit.
",
159,"@@ -0,0 +1,21 @@
+//method
+void foo() {","Please try to ensure that testdata files are valid Java code. This file does not compile ('status' is undefined, the types do not match, etc.)
",Please add a new line at the end 
160,"@@ -0,0 +1,21 @@
+//method
+void foo() {
+	switch (status) {
+	    case ""init"":
+	    case ""dial"":
+	    case ""transmit"":
+		return Color.BLACK;
+
+	    case ""ok"":
+		return 0xFF006600;
+
+	    case ""cancel"":
+		return 0xFF666666;
+
+	    case ""fail"":
+	    case ""busy"":
+	    case ""error"":","Please add a test for the case when 'default' is in the middle of the list of other cases (`case ""error"": default: case ""busy:""`) and make sure that this test passes.
",I don't think you need the `<msg>`<msg>`<msg>`<msg>`<msg>`<msg>`<msg>This is not a<msg>`<msg>`<msg>`<msg>This is not a<msg>`<msg>`method`
161,"@@ -0,0 +1,212 @@
+/*
+* Copyright 2010-2014 JetBrains s.r.o.
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetPostfixExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetElement
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.psiUtil.getQualifiedElementSelector
+import com.intellij.psi.util.PsiTreeUtil
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns
+import org.jetbrains.jet.lang.psi.JetFile
+
+public class OperatorToFunctionIntention : JetSelfTargetingIntention<JetExpression>(""operator.to.function"", javaClass()) {
+    fun isApplicablePrefix(element: JetPrefixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.PLUSPLUS, JetTokens.MINUSMINUS, JetTokens.EXCL -> true
+            else -> false
+        }
+    }
+
+    fun isApplicablePostfix(element: JetPostfixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUSPLUS, JetTokens.MINUSMINUS -> true
+            else -> false
+        }
+    }
+
+    fun isApplicableBinary(element: JetBinaryExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.MUL, JetTokens.DIV, JetTokens.PERC, JetTokens.RANGE, JetTokens.IN_KEYWORD, JetTokens.NOT_IN, JetTokens.PLUSEQ, JetTokens.MINUSEQ, JetTokens.MULTEQ, JetTokens.DIVEQ, JetTokens.PERCEQ, JetTokens.EQEQ, JetTokens.EXCLEQ, JetTokens.GT, JetTokens.LT, JetTokens.GTEQ, JetTokens.LTEQ -> true
+            JetTokens.EQ -> element.getLeft() is JetArrayAccessExpression
+            else -> false
+        }
+    }
+
+    fun isApplicableArrayAccess(element: JetArrayAccessExpression): Boolean {
+        return true
+    }
+
+    fun isApplicableCall(element: JetCallExpression): Boolean {
+        //element.getCalleeExpression()?.getClass()?.getMethods()?.forEach{println(""element has method "" + it.getName())}
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val calleeClass = context[BindingContext.CLASS, element.getCalleeExpression()]
+        //println(""calleeClass is "" + calleeClass?.getName())
+        //calleeClass.javaClass.getMethods().forEach { println(""element has method "" + it.getName()) }
+        return element.getParent() !is JetDotQualifiedExpression && element.getValueArgumentList() != null","Basically, we need to retrieve ResolvedCall corresponding to call of interest and check if resulting function is `invoke`.

```
val resolvedCall = AnalyzerFacadeWithCache.getContextForElement(element)[BindingContext.RESOLVED_CALL, element.getCalleeExpression()]
val descriptor = resolvedCall?.getResultingDescriptor()
if (descriptor is FunctionDescriptor && descriptor.getName().asString == ""invoke"") {
    // do whatever we need
}
```
",I don't think you need this import.
162,"@@ -0,0 +1,212 @@
+/*
+* Copyright 2010-2014 JetBrains s.r.o.
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetPostfixExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetElement
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.psiUtil.getQualifiedElementSelector
+import com.intellij.psi.util.PsiTreeUtil
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns
+import org.jetbrains.jet.lang.psi.JetFile
+
+public class OperatorToFunctionIntention : JetSelfTargetingIntention<JetExpression>(""operator.to.function"", javaClass()) {
+    fun isApplicablePrefix(element: JetPrefixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.PLUSPLUS, JetTokens.MINUSMINUS, JetTokens.EXCL -> true
+            else -> false
+        }
+    }
+
+    fun isApplicablePostfix(element: JetPostfixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUSPLUS, JetTokens.MINUSMINUS -> true
+            else -> false
+        }
+    }
+
+    fun isApplicableBinary(element: JetBinaryExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.MUL, JetTokens.DIV, JetTokens.PERC, JetTokens.RANGE, JetTokens.IN_KEYWORD, JetTokens.NOT_IN, JetTokens.PLUSEQ, JetTokens.MINUSEQ, JetTokens.MULTEQ, JetTokens.DIVEQ, JetTokens.PERCEQ, JetTokens.EQEQ, JetTokens.EXCLEQ, JetTokens.GT, JetTokens.LT, JetTokens.GTEQ, JetTokens.LTEQ -> true
+            JetTokens.EQ -> element.getLeft() is JetArrayAccessExpression
+            else -> false
+        }
+    }
+
+    fun isApplicableArrayAccess(element: JetArrayAccessExpression): Boolean {
+        return true
+    }
+
+    fun isApplicableCall(element: JetCallExpression): Boolean {
+        //element.getCalleeExpression()?.getClass()?.getMethods()?.forEach{println(""element has method "" + it.getName())}
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val calleeClass = context[BindingContext.CLASS, element.getCalleeExpression()]
+        //println(""calleeClass is "" + calleeClass?.getName())
+        //calleeClass.javaClass.getMethods().forEach { println(""element has method "" + it.getName()) }
+        return element.getParent() !is JetDotQualifiedExpression && element.getValueArgumentList() != null
+    }
+
+    override fun isApplicableTo(element: JetExpression): Boolean {
+        return when (element) {
+            is JetPrefixExpression -> isApplicablePrefix(element)
+            is JetPostfixExpression -> isApplicablePostfix(element)
+            is JetBinaryExpression -> isApplicableBinary(element)
+            is JetArrayAccessExpression -> isApplicableArrayAccess(element)
+            is JetCallExpression -> isApplicableCall(element)
+            else -> false
+        }
+    }
+
+
+    fun convertPrefix(element: JetPrefixExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val base = element.getBaseExpression()!!.getText()
+
+        val call = when (op) {
+            JetTokens.PLUS -> ""plus()""
+            JetTokens.MINUS -> ""minus()""
+            JetTokens.PLUSPLUS -> ""inc()""
+            JetTokens.MINUSMINUS -> ""dec()""
+            JetTokens.EXCL -> ""not()""
+            else -> return
+        }
+
+        val transformation = ""$base.$call""
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+        element.replace(transformed)
+    }
+
+    fun convertPostFix(element: JetPostfixExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val base = element.getBaseExpression()!!.getText()
+
+        val call = when (op) {
+            JetTokens.PLUSPLUS -> ""inc()""
+            JetTokens.MINUSMINUS -> ""dec()""
+            else -> return
+        }
+
+        val transformation = ""$base.$call""
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+        element.replace(transformed)
+    }
+
+    fun convertBinary(element: JetBinaryExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val left = element.getLeft()!!
+        val right = element.getRight()!!
+        val leftText = left.getText()
+        val rightText = right.getText()
+
+        if (op == JetTokens.EQ) {
+            if (left is JetArrayAccessExpression) {
+                convertArrayAccess(left as JetArrayAccessExpression)
+            }
+            return
+        }
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()","This function is not available anymore. Please, rebase against current master and use `AnalyzerFacadeWithCache.getContextForElement(element)` instead
",I don't think you need this import.
163,"@@ -0,0 +1,212 @@
+/*
+* Copyright 2010-2014 JetBrains s.r.o.
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetPostfixExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetElement
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.psiUtil.getQualifiedElementSelector
+import com.intellij.psi.util.PsiTreeUtil
+import org.jetbrains.jet.lang.types.lang.KotlinBuiltIns
+import org.jetbrains.jet.lang.psi.JetFile
+
+public class OperatorToFunctionIntention : JetSelfTargetingIntention<JetExpression>(""operator.to.function"", javaClass()) {
+    fun isApplicablePrefix(element: JetPrefixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.PLUSPLUS, JetTokens.MINUSMINUS, JetTokens.EXCL -> true
+            else -> false
+        }
+    }
+
+    fun isApplicablePostfix(element: JetPostfixExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUSPLUS, JetTokens.MINUSMINUS -> true
+            else -> false
+        }
+    }
+
+    fun isApplicableBinary(element: JetBinaryExpression): Boolean {
+        return when (element.getOperationReference().getReferencedNameElementType()) {
+            JetTokens.PLUS, JetTokens.MINUS, JetTokens.MUL, JetTokens.DIV, JetTokens.PERC, JetTokens.RANGE, JetTokens.IN_KEYWORD, JetTokens.NOT_IN, JetTokens.PLUSEQ, JetTokens.MINUSEQ, JetTokens.MULTEQ, JetTokens.DIVEQ, JetTokens.PERCEQ, JetTokens.EQEQ, JetTokens.EXCLEQ, JetTokens.GT, JetTokens.LT, JetTokens.GTEQ, JetTokens.LTEQ -> true
+            JetTokens.EQ -> element.getLeft() is JetArrayAccessExpression
+            else -> false
+        }
+    }
+
+    fun isApplicableArrayAccess(element: JetArrayAccessExpression): Boolean {
+        return true
+    }
+
+    fun isApplicableCall(element: JetCallExpression): Boolean {
+        //element.getCalleeExpression()?.getClass()?.getMethods()?.forEach{println(""element has method "" + it.getName())}
+        //val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        //val calleeClass = context[BindingContext.CLASS, element.getCalleeExpression()]
+        //println(""calleeClass is "" + calleeClass?.getName())
+        //calleeClass.javaClass.getMethods().forEach { println(""element has method "" + it.getName()) }
+        return element.getParent() !is JetDotQualifiedExpression && element.getValueArgumentList() != null
+    }
+
+    override fun isApplicableTo(element: JetExpression): Boolean {
+        return when (element) {
+            is JetPrefixExpression -> isApplicablePrefix(element)
+            is JetPostfixExpression -> isApplicablePostfix(element)
+            is JetBinaryExpression -> isApplicableBinary(element)
+            is JetArrayAccessExpression -> isApplicableArrayAccess(element)
+            is JetCallExpression -> isApplicableCall(element)
+            else -> false
+        }
+    }
+
+
+    fun convertPrefix(element: JetPrefixExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val base = element.getBaseExpression()!!.getText()
+
+        val call = when (op) {
+            JetTokens.PLUS -> ""plus()""
+            JetTokens.MINUS -> ""minus()""
+            JetTokens.PLUSPLUS -> ""inc()""
+            JetTokens.MINUSMINUS -> ""dec()""
+            JetTokens.EXCL -> ""not()""
+            else -> return
+        }
+
+        val transformation = ""$base.$call""
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+        element.replace(transformed)
+    }
+
+    fun convertPostFix(element: JetPostfixExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val base = element.getBaseExpression()!!.getText()
+
+        val call = when (op) {
+            JetTokens.PLUSPLUS -> ""inc()""
+            JetTokens.MINUSMINUS -> ""dec()""
+            else -> return
+        }
+
+        val transformation = ""$base.$call""
+        val transformed = JetPsiFactory.createExpression(element.getProject(), transformation)
+        element.replace(transformed)
+    }
+
+    fun convertBinary(element: JetBinaryExpression) {
+        val op = element.getOperationReference().getReferencedNameElementType()
+        val left = element.getLeft()!!
+        val right = element.getRight()!!
+        val leftText = left.getText()
+        val rightText = right.getText()
+
+        if (op == JetTokens.EQ) {
+            if (left is JetArrayAccessExpression) {
+                convertArrayAccess(left as JetArrayAccessExpression)
+            }
+            return
+        }
+
+        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()
+        val functionCandidate = context[BindingContext.RESOLVED_CALL, element.getOperationReference()]
+        val functionName = functionCandidate?.getCandidateDescriptor()?.getName().toString()
+
+        val elemType = context[BindingContext.EXPRESSION_TYPE, left]
+
+
+        val transformation = when (op) {
+            JetTokens.PLUS -> ""$leftText.plus($rightText)""
+            JetTokens.MINUS -> ""$leftText.minus($rightText)""
+            JetTokens.MUL -> ""$leftText.times($rightText)""
+            JetTokens.DIV -> ""$leftText.div($rightText)""
+            JetTokens.PERC -> ""$leftText.mod($rightText)""
+            JetTokens.RANGE -> ""$leftText.rangeTo($rightText)""
+            JetTokens.IN_KEYWORD -> ""$rightText.contains($leftText)""
+            JetTokens.NOT_IN -> ""!$rightText.contains($leftText)""
+            JetTokens.PLUSEQ -> if (functionName == ""plusAssign"") ""$leftText.plusAssign($rightText)"" else ""$leftText = $leftText.plus($rightText)""
+            JetTokens.MINUSEQ -> if (functionName == ""minusAssign"") ""$leftText.minusAssign($rightText)"" else ""$leftText = $leftText.minus($rightText)""
+            JetTokens.MULTEQ -> if (functionName == ""multAssign"") ""$leftText.multAssign($rightText)"" else ""$leftText = $leftText.mult($rightText)""
+            JetTokens.DIVEQ -> if (functionName == ""divAssign"") ""$leftText.divAssign($rightText)"" else ""$leftText = $leftText.div($rightText)""
+            JetTokens.PERCEQ -> if (functionName == ""modAssign"") ""$leftText.modAssign($rightText)"" else ""$leftText = $leftText.mod($rightText)""
+            JetTokens.EQEQ -> (if (elemType?.isNullable() ?: true) ""$leftText?."" else ""$leftText."") + ""equals($rightText) ?: $rightText.identityEquals(null)""","It still produces unnecessary code. If `a` has a non-nullable type, `a == b` should be replaced by `a.equals(b)`, not `a.equals(b) ?: b.identityEquals(null)`
",I don't think you need this import.
164,"@@ -0,0 +1,22 @@
+package demo
+
+import com.google.common.primitives.Ints
+import com.google.common.base.Joiner
+import java.util.ArrayList
+
+class KotlinGreetingJoiner(val greeter : Greeter) {
+
+    val names = ArrayList<String?>()
+
+    fun addName(name : String?): Unit{
+        names.add(name)
+    }
+
+    fun getJoinedGreeting() : String? {
+        val joiner = Joiner.on("" and "").skipNulls();","why do we need guava in such simple example? we can replace ugly `Joiner.on("" and "").skipNulls().join(names)` with `names.filterNotNull().joinToString("" and "")`. We also don't need `com.google.common.primitives.Ints` at all...
",Missing license header.
165,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,",May be `JavaCompilerWrapper`?,I don't think you need this import.
166,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,
+            classPathRoots: List<File>,
+            outDir: File?,
+            private val messageCollector: MessageCollector?,
+            arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): Javac = ServiceManager.getService(project, Javac::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+        outDir?.let {
+            it.mkdirs()
+            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, listOf(it))
+        }
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { JCClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .map { it.fqName to it }
+            .toMap()",There is `keysToMap` in Kotlin project itself & also `associateBy` in stdlib. I'm not sure it's quite important but they may be faster (one internal container instead of two) and definitely shorter.,I don't think you need this import.
167,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,
+            classPathRoots: List<File>,
+            outDir: File?,
+            private val messageCollector: MessageCollector?,
+            arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): Javac = ServiceManager.getService(project, Javac::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+        outDir?.let {
+            it.mkdirs()
+            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, listOf(it))
+        }
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { JCClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .map { it.fqName to it }
+            .toMap()
+
+    private val javaPackages = compilationUnits
+            .map { FqName(it.packageName.toString()) to JCPackage(it.packageName.toString(), this) }
+            .toMap()",See above,I don't think you need this import.
168,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,
+            classPathRoots: List<File>,
+            outDir: File?,
+            private val messageCollector: MessageCollector?,
+            arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): Javac = ServiceManager.getService(project, Javac::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+        outDir?.let {
+            it.mkdirs()
+            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, listOf(it))
+        }
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { JCClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .map { it.fqName to it }
+            .toMap()
+
+    private val javaPackages = compilationUnits
+            .map { FqName(it.packageName.toString()) to JCPackage(it.packageName.toString(), this) }
+            .toMap()
+
+    fun compile() = with(javac) {
+        if (errorCount() > 0) return false
+
+        fileManager.setClassPathForCompilation()
+        messageCollector?.report(CompilerMessageSeverity.INFO,
+                                 ""Compiling Java sources"",
+                                 CompilerMessageLocation.NO_LOCATION)
+        compile(fileObjects)
+        errorCount() == 0
+    }
+
+    override fun close() {
+        fileManager.close()
+        javac.close()
+    }
+
+    fun findClass(fqName: FqName, scope: GlobalSearchScope = EverythingGlobalScope()) = when {
+        scope is EverythingGlobalScope -> javaClasses[fqName] ?: findClassInSymbols(fqName.asString())
+        scope.contains(AnyJavaSourceVirtualFile) -> javaClasses[fqName]","I don't quite understand the idea with this object. As I can see, it's used in `contains` only. Who does put it into the scope?",I don't think you need this import.
169,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,
+            classPathRoots: List<File>,
+            outDir: File?,
+            private val messageCollector: MessageCollector?,
+            arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): Javac = ServiceManager.getService(project, Javac::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+        outDir?.let {
+            it.mkdirs()
+            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, listOf(it))
+        }
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { JCClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .map { it.fqName to it }
+            .toMap()
+
+    private val javaPackages = compilationUnits
+            .map { FqName(it.packageName.toString()) to JCPackage(it.packageName.toString(), this) }
+            .toMap()
+
+    fun compile() = with(javac) {
+        if (errorCount() > 0) return false
+
+        fileManager.setClassPathForCompilation()
+        messageCollector?.report(CompilerMessageSeverity.INFO,
+                                 ""Compiling Java sources"",
+                                 CompilerMessageLocation.NO_LOCATION)
+        compile(fileObjects)
+        errorCount() == 0
+    }
+
+    override fun close() {
+        fileManager.close()
+        javac.close()
+    }
+
+    fun findClass(fqName: FqName, scope: GlobalSearchScope = EverythingGlobalScope()) = when {
+        scope is EverythingGlobalScope -> javaClasses[fqName] ?: findClassInSymbols(fqName.asString())
+        scope.contains(AnyJavaSourceVirtualFile) -> javaClasses[fqName]
+        else -> findClassInSymbols(fqName.asString()) ?: javaClasses[fqName]
+    }
+
+    fun findPackage(fqName: FqName, scope: GlobalSearchScope) = when {
+        scope is EverythingGlobalScope -> javaPackages[fqName] ?: findPackageInSymbols(fqName.asString())
+        scope.contains(AnyJavaSourceVirtualFile) -> javaPackages[fqName]
+        else -> findPackageInSymbols(fqName.asString()) ?: javaPackages[fqName]
+    }
+
+    fun findSubPackages(fqName: FqName) = symbols.packages
+                                                  .filter { (k, _) -> k.toString().startsWith(""$fqName."") }
+                                                  .map { JavacPackage(it.value, this) } +
+                                          javaPackages
+                                                  .filter { it.key.isSubpackageOf(fqName) && it.key != fqName }
+                                                  .map { it.value }",There is `filterValues`.,I don't think you need this import.
170,"@@ -0,0 +1,227 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.JavacClass
+import org.jetbrains.kotlin.wrappers.symbols.JavacPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.wrappers.trees.JCClass
+import org.jetbrains.kotlin.wrappers.trees.JCPackage
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.TypeElement
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class Javac(javaFiles: Collection<File>,
+            classPathRoots: List<File>,
+            outDir: File?,
+            private val messageCollector: MessageCollector?,
+            arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): Javac = ServiceManager.getService(project, Javac::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+        outDir?.let {
+            it.mkdirs()
+            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, listOf(it))
+        }
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { JCClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .map { it.fqName to it }
+            .toMap()
+
+    private val javaPackages = compilationUnits
+            .map { FqName(it.packageName.toString()) to JCPackage(it.packageName.toString(), this) }
+            .toMap()
+
+    fun compile() = with(javac) {
+        if (errorCount() > 0) return false
+
+        fileManager.setClassPathForCompilation()
+        messageCollector?.report(CompilerMessageSeverity.INFO,
+                                 ""Compiling Java sources"",
+                                 CompilerMessageLocation.NO_LOCATION)
+        compile(fileObjects)
+        errorCount() == 0
+    }
+
+    override fun close() {
+        fileManager.close()
+        javac.close()
+    }
+
+    fun findClass(fqName: FqName, scope: GlobalSearchScope = EverythingGlobalScope()) = when {
+        scope is EverythingGlobalScope -> javaClasses[fqName] ?: findClassInSymbols(fqName.asString())
+        scope.contains(AnyJavaSourceVirtualFile) -> javaClasses[fqName]
+        else -> findClassInSymbols(fqName.asString()) ?: javaClasses[fqName]
+    }
+
+    fun findPackage(fqName: FqName, scope: GlobalSearchScope) = when {
+        scope is EverythingGlobalScope -> javaPackages[fqName] ?: findPackageInSymbols(fqName.asString())
+        scope.contains(AnyJavaSourceVirtualFile) -> javaPackages[fqName]
+        else -> findPackageInSymbols(fqName.asString()) ?: javaPackages[fqName]
+    }
+
+    fun findSubPackages(fqName: FqName) = symbols.packages
+                                                  .filter { (k, _) -> k.toString().startsWith(""$fqName."") }
+                                                  .map { JavacPackage(it.value, this) } +
+                                          javaPackages
+                                                  .filter { it.key.isSubpackageOf(fqName) && it.key != fqName }
+                                                  .map { it.value }
+
+    fun findClassesFromPackage(fqName: FqName) = javaClasses.filter { it.key?.parentOrNull() == fqName }
+                                                         .flatMap { it.value.withInnerClasses() } +
+                                                 elements.getPackageElement(fqName.asString())
+                                                         ?.members()
+                                                         ?.elements
+                                                         ?.filterIsInstance(TypeElement::class.java)
+                                                         ?.map { JavacClass(it, this) }
+                                                         .orEmpty()
+
+    fun getTreePath(tree: JCTree, compilationUnit: CompilationUnitTree): TreePath = trees.getPath(compilationUnit, tree)
+
+    private inline fun <reified T> Iterable<T>.toJavacList() = JavacList.from(this)
+
+    private fun findClassInSymbols(fqName: String) = elements.getTypeElement(fqName)?.let { JavacClass(it, this) }
+
+    private fun findPackageInSymbols(fqName: String) = elements.getPackageElement(fqName)?.let { JavacPackage(it, this) }
+
+    private fun JavacFileManager.setClassPathForCompilation() = apply {
+        setLocation(StandardLocation.CLASS_PATH,
+                    getLocation(StandardLocation.CLASS_PATH) + getLocation(StandardLocation.CLASS_OUTPUT))
+
+        val reader = ClassReader.instance(context)
+        val names = Names.instance(context)
+        val outDirName = getLocation(StandardLocation.CLASS_OUTPUT).firstOrNull()?.path ?: """"
+
+        list(StandardLocation.CLASS_OUTPUT, """", setOf(JavaFileObject.Kind.CLASS), true)
+                .forEach {
+                    val fqName = it.name
+                            .substringAfter(outDirName)
+                            .substringBefore("".class"")
+                            .replace(""/"", ""."")
+                            .let { if (it.startsWith(""."")) it.substring(1) else it }
+                            .let(names::fromString)
+
+                    symbols.classes[fqName]?.let { symbols.classes[fqName] = null }
+                    val symbol = reader.enterClass(fqName, it)
+
+                    (elements.getPackageOf(symbol) as? Symbol.PackageSymbol)?.let {
+                        it.members_field.enter(symbol)
+                        it.flags_field = it.flags_field or Flags.EXISTS.toLong()
+                    }
+                }
+
+    }
+
+    private fun JavaClass.withInnerClasses(): List<JavaClass> = listOf(this) + innerClasses.flatMap { it.withInnerClasses() }
+
+}
+
+private object AnyJavaSourceVirtualFile : VirtualFile() {
+    override fun refresh(asynchronous: Boolean, recursive: Boolean, postRunnable: Runnable?) {}
+
+    override fun getLength() = 0L
+
+    override fun getFileSystem() = throw UnsupportedOperationException()","May be (if you need this object at all) it's better to provide some message like `""Should never be called""`. ",I don't think you need this import.
171,"@@ -0,0 +1,24 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.factories
+
+import org.jetbrains.kotlin.effectsystem.structure.ESBooleanExpression
+import org.jetbrains.kotlin.effectsystem.structure.ESClause
+import org.jetbrains.kotlin.effectsystem.structure.ESEffect
+
+fun createClause(premise: ESBooleanExpression, conclusion: ESEffect) = ESClause(premise, conclusion)
+fun createUnconditionalClause(effect: ESEffect): ESClause = ESClause(true.lift(), effect)","Why do we need this `unconditionalClause`? As far as I understand it's interpreted as ""if effect takes place then true is true"", and this statement is always true.",I don't think we need to create a new `ESBooleanExpression` here.
172,"@@ -0,0 +1,240 @@
+@file:kotlin.jvm.JvmMultifileClass
+@file:kotlin.jvm.JvmName(""StringsKt"")
+@file:Suppress(""PLATFORM_CLASS_MAPPED_TO_KOTLIN"")
+
+package kotlin.text
+
+
+/**
+ * Returns `true` if the contents of this string is equal to the word ""true"", ignoring case, and `false` otherwise.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toBoolean(): Boolean = java.lang.Boolean.parseBoolean(this)
+
+/**
+ * Parses the string as a signed [Byte] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toByte(radix: Int = 10): Byte = java.lang.Byte.parseByte(this, radix)
+
+/**
+ * Parses the string as a [Short] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toShort(radix: Int = 10): Short = java.lang.Short.parseShort(this, radix)
+
+/**
+ * Parses the string as an [Int] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toInt(radix: Int = 10): Int = java.lang.Integer.parseInt(this, radix)
+
+/**
+ * Parses the string as a [Long] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toLong(radix: Int = 10): Long = java.lang.Long.parseLong(this, radix)
+
+/**
+ * Parses the string as a [Float] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toFloat(radix: Int = 10): Float = java.lang.Float.parseFloat(this)","Radix parameter seems to be unused
",How about using `java.lang.Boolean.parseBoolean(this)`?
173,"@@ -0,0 +1,240 @@
+@file:kotlin.jvm.JvmMultifileClass
+@file:kotlin.jvm.JvmName(""StringsKt"")
+@file:Suppress(""PLATFORM_CLASS_MAPPED_TO_KOTLIN"")
+
+package kotlin.text
+
+
+/**
+ * Returns `true` if the contents of this string is equal to the word ""true"", ignoring case, and `false` otherwise.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toBoolean(): Boolean = java.lang.Boolean.parseBoolean(this)
+
+/**
+ * Parses the string as a signed [Byte] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toByte(radix: Int = 10): Byte = java.lang.Byte.parseByte(this, radix)
+
+/**
+ * Parses the string as a [Short] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toShort(radix: Int = 10): Short = java.lang.Short.parseShort(this, radix)
+
+/**
+ * Parses the string as an [Int] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toInt(radix: Int = 10): Int = java.lang.Integer.parseInt(this, radix)
+
+/**
+ * Parses the string as a [Long] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toLong(radix: Int = 10): Long = java.lang.Long.parseLong(this, radix)
+
+/**
+ * Parses the string as a [Float] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toFloat(radix: Int = 10): Float = java.lang.Float.parseFloat(this)
+
+/**
+ * Parses the string as a [Double] number and returns the result.
+ * @throws NumberFormatException if the string is not a valid representation of a number.
+ */
+@kotlin.internal.InlineOnly
+public inline fun String.toDouble(radix: Int = 10): Double = java.lang.Double.parseDouble(this)","Radix parameter seems to be unused
",How about using `java.lang.Boolean.parseBoolean(this)`?
174,"@@ -0,0 +1,243 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope","I think it would be nice to move parts of this class that use `com.intellij.openapi` to other compiler modules, to get rid of dependency of module `javac-wrapper` on `openapi`. This can be done in the future, I suppose.",I don't think you need this import.
175,"@@ -0,0 +1,243 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.model.JavacTypes
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.config.CompilerConfiguration
+import org.jetbrains.kotlin.config.JVMConfigurationKeys
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.wrappers.trees.TreeBasedClass
+import org.jetbrains.kotlin.wrappers.trees.TreeBasedPackage
+import org.jetbrains.kotlin.wrappers.trees.TreePathResolverCache
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.Element
+import javax.lang.model.element.TypeElement
+import javax.lang.model.type.TypeMirror
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class JavacWrapper(javaFiles: Collection<File>,","Since you're passing `CompilerConfiguration` here, there's no need to pass `classPathRoots` and `messageCollector` separately because in production code, they can be trivially obtained from the configuration (and tests can be adapted to mimic that)",I don't think you need this import.
176,"@@ -0,0 +1,243 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.intellij.ide.highlighter.JavaFileType
+import com.intellij.openapi.components.ServiceManager
+import com.intellij.openapi.fileTypes.FileType
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.CommonClassNames
+import com.intellij.psi.search.EverythingGlobalScope
+import com.intellij.psi.search.GlobalSearchScope
+import com.sun.source.tree.CompilationUnitTree
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.api.JavacTrees
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.code.Symbol
+import com.sun.tools.javac.code.Symtab
+import com.sun.tools.javac.file.JavacFileManager
+import com.sun.tools.javac.jvm.ClassReader
+import com.sun.tools.javac.main.JavaCompiler
+import com.sun.tools.javac.model.JavacElements
+import com.sun.tools.javac.model.JavacTypes
+import com.sun.tools.javac.tree.JCTree
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Names
+import com.sun.tools.javac.util.Options
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.config.CompilerConfiguration
+import org.jetbrains.kotlin.config.JVMConfigurationKeys
+import com.sun.tools.javac.util.List as JavacList
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedClass
+import org.jetbrains.kotlin.wrappers.symbols.SymbolBasedPackage
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.isSubpackageOf
+import org.jetbrains.kotlin.name.parentOrNull
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.wrappers.trees.TreeBasedClass
+import org.jetbrains.kotlin.wrappers.trees.TreeBasedPackage
+import org.jetbrains.kotlin.wrappers.trees.TreePathResolverCache
+import java.io.Closeable
+import java.io.File
+import javax.lang.model.element.Element
+import javax.lang.model.element.TypeElement
+import javax.lang.model.type.TypeMirror
+import javax.tools.JavaFileManager
+import javax.tools.JavaFileObject
+import javax.tools.StandardLocation
+
+class JavacWrapper(javaFiles: Collection<File>,
+                   kotlinFiles: Collection<KtFile>,
+                   classPathRoots: List<File>,
+                   private val configuration: CompilerConfiguration,
+                   private val messageCollector: MessageCollector?,
+                   arguments: Array<String>?) : Closeable {
+
+    companion object {
+        fun getInstance(project: Project): JavacWrapper = ServiceManager.getService(project, JavacWrapper::class.java)
+    }
+
+    val JAVA_LANG_OBJECT by lazy { findClassInSymbols(CommonClassNames.JAVA_LANG_OBJECT) }
+
+    private val context = Context()
+
+    init {
+        messageCollector?.let { JavacLogger.preRegister(context, it) }
+        arguments?.toList()?.let { JavacOptionsMapper.map(Options.instance(context), it) }
+    }
+
+    private val javac = object : JavaCompiler(context) {
+        override fun parseFiles(files: Iterable<JavaFileObject>?) = compilationUnits
+    }
+    private val fileManager = context[JavaFileManager::class.java] as JavacFileManager
+
+    init {
+        fileManager.setLocation(StandardLocation.CLASS_PATH, classPathRoots)
+    }
+
+    private val symbols = Symtab.instance(context)
+    private val trees = JavacTrees.instance(context)
+    private val elements = JavacElements.instance(context)
+    private val types = JavacTypes.instance(context)
+    private val fileObjects = fileManager.getJavaFileObjectsFromFiles(javaFiles).toJavacList()
+    private val compilationUnits: JavacList<JCTree.JCCompilationUnit> = fileObjects.map(javac::parse).toJavacList()
+
+    private val javaClasses = compilationUnits
+            .flatMap { unit -> unit.typeDecls
+                    .flatMap { TreeBasedClass(it as JCTree.JCClassDecl, trees.getPath(unit, it), this).withInnerClasses() }
+            }
+            .associateBy(JavaClass::fqName)
+
+    private val javaPackages = compilationUnits
+            .map { TreeBasedPackage(it.packageName.toString(), this) }
+            .associateBy(TreeBasedPackage::fqName)
+
+    private val kotlinClassifiersCache = KotlinClassifiersCache(kotlinFiles, this)
+    private val treePathResolverCache = TreePathResolverCache(this)
+
+    fun compile(outDir: File? = null) = with(javac) {
+        if (errorCount() > 0) return false
+
+        fileManager.setClassPathForCompilation(outDir)
+        messageCollector?.report(CompilerMessageSeverity.INFO,
+                                 ""Compiling Java sources"")
+        compile(fileObjects)
+        errorCount() == 0
+    }
+
+    override fun close() {
+        fileManager.close()
+        javac.close()
+    }
+
+    fun findClass(fqName: FqName, scope: GlobalSearchScope = EverythingGlobalScope()) = when {
+        scope is EverythingGlobalScope -> javaClasses[fqName] ?: findClassInSymbols(fqName.asString())","Using `instanceof` on `GlobalSearchScope` is very risky and should be avoided at all costs. For example, if I wrap the everything-scope twice into the not-scope:
```
GlobalSearchScope.notScope(GlobalSearchScope.notScope(
    GlobalSearchScope.allScope(project)
))
```
The resulting scope will be effectively the same, but your code won't work anymore because it would be another instance.

Also, relying on specific scopes being passed here (like a scope with all .java files) is risky as well, because we might reconfigure the compiler in such a way that the compiled module is split into a different set of scopes in the near future.",I don't think you need this import.
177,"@@ -0,0 +1,25 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+public enum class ExpressionKind(val output: String) {
+    IF : ExpressionKind(""if"")
+    ELSE : ExpressionKind(""else"")
+    WHILE : ExpressionKind(""while"")
+    DOWHILE : ExpressionKind(""do...while"")
+    FOR : ExpressionKind(""for"")
+}","Storing string representation in enum is a good idea.  
I think this enum shouldn't be public and is better to put it near corresponding methods in Utils.kt
",I think it would be better to use `
178,"@@ -0,0 +1,25 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.psi;
+
+import com.intellij.psi.PsiElement;
+import org.jetbrains.annotations.Nullable;
+
+public interface KtValVarKeywordProvider extends PsiElement {","""Provider"" is not a great name for it, I think
",Why do we need this interface?
179,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(","Not related to changes, but why is it uppercase?
",I don't think we need this file.
180,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))","Please use Kotlin's `split`
",I don't think we need this file.
181,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)","`toTypedArray()`
",I don't think we need this file.
182,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)
+
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, argsArray)) {
+                // otherwise fallback to in-process
+
+                val stream = ByteArrayOutputStream()
+                val out = PrintStream(stream)
+
+                val rc = CompilerRunnerUtil.invokeExecMethod(compilerClassName, argsArray, environment, messageCollector, out)
+
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc))
+            }
+        }
+        catch (e: Throwable) {
+            MessageCollectorUtil.reportException(messageCollector, e)
+            reportInternalCompilerError(messageCollector)
+        }
+
+    }
+
+    private fun tryCompileWithDaemon(messageCollector: MessageCollector,
+                                     collector: OutputItemsCollector,
+                                     environment: CompilerEnvironment,
+                                     argsArray: Array<String>): Boolean {
+        if (isDaemonEnabled()) {","Early return would be helpful
",I don't think we need this file.
183,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)
+
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, argsArray)) {
+                // otherwise fallback to in-process
+
+                val stream = ByteArrayOutputStream()
+                val out = PrintStream(stream)
+
+                val rc = CompilerRunnerUtil.invokeExecMethod(compilerClassName, argsArray, environment, messageCollector, out)
+
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc))
+            }
+        }
+        catch (e: Throwable) {
+            MessageCollectorUtil.reportException(messageCollector, e)
+            reportInternalCompilerError(messageCollector)
+        }
+
+    }
+
+    private fun tryCompileWithDaemon(messageCollector: MessageCollector,
+                                     collector: OutputItemsCollector,
+                                     environment: CompilerEnvironment,
+                                     argsArray: Array<String>): Boolean {
+        if (isDaemonEnabled()) {
+            val libPath = CompilerRunnerUtil.getLibPath(environment.kotlinPaths, messageCollector)
+            // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+            //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+            val compilerId = CompilerId.makeCompilerId(File(libPath, ""kotlin-compiler.jar""))
+            val daemonOptions = configureDaemonOptions()
+            val daemonJVMOptions = configureDaemonJVMOptions(true)
+
+            val daemonReportMessages = ArrayList<DaemonReportMessage>()
+
+            val daemon = KotlinCompilerClient.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, DaemonReportingTargets(null, daemonReportMessages), true, true)
+
+            for (msg in daemonReportMessages) {
+                if (msg.category === DaemonReportCategory.EXCEPTION && daemon == null) {
+                    messageCollector.report(CompilerMessageSeverity.INFO,
+                                            ""Falling  back to compilation without daemon due to error: "" + msg.message,
+                                            CompilerMessageLocation.NO_LOCATION)
+                }
+                else {
+                    messageCollector.report(CompilerMessageSeverity.INFO, msg.message, CompilerMessageLocation.NO_LOCATION)
+                }
+            }
+
+            if (daemon != null) {
+                val compilerOut = ByteArrayOutputStream()
+                val daemonOut = ByteArrayOutputStream()
+
+                val services = CompilationServices(
+                        incrementalCompilationComponents = environment.services.get(IncrementalCompilationComponents::class.java),
+                        compilationCanceledStatus = environment.services.get(CompilationCanceledStatus::class.java))
+
+                val res = KotlinCompilerClient.incrementalCompile(daemon, argsArray, services, compilerOut, daemonOut)
+
+                ProcessCompilerOutput(messageCollector, collector, compilerOut, res.toString())
+                BufferedReader(StringReader(daemonOut.toString())).forEachLine {
+                    messageCollector.report(CompilerMessageSeverity.INFO, it, CompilerMessageLocation.NO_LOCATION)
+                }
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun getReturnCodeFromObject(rc: Any?): String {
+        if (rc == null) {","`when`
",I don't think we need this file.
184,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)
+
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, argsArray)) {
+                // otherwise fallback to in-process
+
+                val stream = ByteArrayOutputStream()
+                val out = PrintStream(stream)
+
+                val rc = CompilerRunnerUtil.invokeExecMethod(compilerClassName, argsArray, environment, messageCollector, out)
+
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc))
+            }
+        }
+        catch (e: Throwable) {
+            MessageCollectorUtil.reportException(messageCollector, e)
+            reportInternalCompilerError(messageCollector)
+        }
+
+    }
+
+    private fun tryCompileWithDaemon(messageCollector: MessageCollector,
+                                     collector: OutputItemsCollector,
+                                     environment: CompilerEnvironment,
+                                     argsArray: Array<String>): Boolean {
+        if (isDaemonEnabled()) {
+            val libPath = CompilerRunnerUtil.getLibPath(environment.kotlinPaths, messageCollector)
+            // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+            //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+            val compilerId = CompilerId.makeCompilerId(File(libPath, ""kotlin-compiler.jar""))
+            val daemonOptions = configureDaemonOptions()
+            val daemonJVMOptions = configureDaemonJVMOptions(true)
+
+            val daemonReportMessages = ArrayList<DaemonReportMessage>()
+
+            val daemon = KotlinCompilerClient.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, DaemonReportingTargets(null, daemonReportMessages), true, true)
+
+            for (msg in daemonReportMessages) {
+                if (msg.category === DaemonReportCategory.EXCEPTION && daemon == null) {
+                    messageCollector.report(CompilerMessageSeverity.INFO,
+                                            ""Falling  back to compilation without daemon due to error: "" + msg.message,
+                                            CompilerMessageLocation.NO_LOCATION)
+                }
+                else {
+                    messageCollector.report(CompilerMessageSeverity.INFO, msg.message, CompilerMessageLocation.NO_LOCATION)
+                }
+            }
+
+            if (daemon != null) {
+                val compilerOut = ByteArrayOutputStream()
+                val daemonOut = ByteArrayOutputStream()
+
+                val services = CompilationServices(
+                        incrementalCompilationComponents = environment.services.get(IncrementalCompilationComponents::class.java),
+                        compilationCanceledStatus = environment.services.get(CompilationCanceledStatus::class.java))
+
+                val res = KotlinCompilerClient.incrementalCompile(daemon, argsArray, services, compilerOut, daemonOut)
+
+                ProcessCompilerOutput(messageCollector, collector, compilerOut, res.toString())
+                BufferedReader(StringReader(daemonOut.toString())).forEachLine {
+                    messageCollector.report(CompilerMessageSeverity.INFO, it, CompilerMessageLocation.NO_LOCATION)
+                }
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun getReturnCodeFromObject(rc: Any?): String {
+        if (rc == null) {
+            return INTERNAL_ERROR
+        }
+        else if (ExitCode::class.java.name == rc.javaClass.name) {
+            return rc.toString()
+        }
+        else {
+            throw IllegalStateException(""Unexpected return: "" + rc)
+        }
+    }
+
+    private fun <T : CommonCompilerArguments> mergeBeans(from: CommonCompilerArguments, to: T): T {
+        // TODO: rewrite when updated version of com.intellij.util.xmlb is available on TeamCity
+        try {
+            val copy = XmlSerializerUtil.createCopy(to)
+
+            val fromFields = collectFieldsToCopy(from.javaClass)
+            for (fromField in fromFields) {
+                val toField = copy.javaClass.getField(fromField.name)
+                toField.set(copy, fromField.get(from))
+            }
+
+            return copy
+        }
+        catch (e: NoSuchFieldException) {
+            throw rethrow(e)
+        }
+        catch (e: IllegalAccessException) {
+            throw rethrow(e)","This `try`/`catch` and `rethrow`s are not needed in Kotlin
",I don't think we need this file.
185,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)
+
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, argsArray)) {
+                // otherwise fallback to in-process
+
+                val stream = ByteArrayOutputStream()
+                val out = PrintStream(stream)
+
+                val rc = CompilerRunnerUtil.invokeExecMethod(compilerClassName, argsArray, environment, messageCollector, out)
+
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc))
+            }
+        }
+        catch (e: Throwable) {
+            MessageCollectorUtil.reportException(messageCollector, e)
+            reportInternalCompilerError(messageCollector)
+        }
+
+    }
+
+    private fun tryCompileWithDaemon(messageCollector: MessageCollector,
+                                     collector: OutputItemsCollector,
+                                     environment: CompilerEnvironment,
+                                     argsArray: Array<String>): Boolean {
+        if (isDaemonEnabled()) {
+            val libPath = CompilerRunnerUtil.getLibPath(environment.kotlinPaths, messageCollector)
+            // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+            //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+            val compilerId = CompilerId.makeCompilerId(File(libPath, ""kotlin-compiler.jar""))
+            val daemonOptions = configureDaemonOptions()
+            val daemonJVMOptions = configureDaemonJVMOptions(true)
+
+            val daemonReportMessages = ArrayList<DaemonReportMessage>()
+
+            val daemon = KotlinCompilerClient.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, DaemonReportingTargets(null, daemonReportMessages), true, true)
+
+            for (msg in daemonReportMessages) {
+                if (msg.category === DaemonReportCategory.EXCEPTION && daemon == null) {
+                    messageCollector.report(CompilerMessageSeverity.INFO,
+                                            ""Falling  back to compilation without daemon due to error: "" + msg.message,
+                                            CompilerMessageLocation.NO_LOCATION)
+                }
+                else {
+                    messageCollector.report(CompilerMessageSeverity.INFO, msg.message, CompilerMessageLocation.NO_LOCATION)
+                }
+            }
+
+            if (daemon != null) {
+                val compilerOut = ByteArrayOutputStream()
+                val daemonOut = ByteArrayOutputStream()
+
+                val services = CompilationServices(
+                        incrementalCompilationComponents = environment.services.get(IncrementalCompilationComponents::class.java),
+                        compilationCanceledStatus = environment.services.get(CompilationCanceledStatus::class.java))
+
+                val res = KotlinCompilerClient.incrementalCompile(daemon, argsArray, services, compilerOut, daemonOut)
+
+                ProcessCompilerOutput(messageCollector, collector, compilerOut, res.toString())
+                BufferedReader(StringReader(daemonOut.toString())).forEachLine {
+                    messageCollector.report(CompilerMessageSeverity.INFO, it, CompilerMessageLocation.NO_LOCATION)
+                }
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun getReturnCodeFromObject(rc: Any?): String {
+        if (rc == null) {
+            return INTERNAL_ERROR
+        }
+        else if (ExitCode::class.java.name == rc.javaClass.name) {
+            return rc.toString()
+        }
+        else {
+            throw IllegalStateException(""Unexpected return: "" + rc)
+        }
+    }
+
+    private fun <T : CommonCompilerArguments> mergeBeans(from: CommonCompilerArguments, to: T): T {
+        // TODO: rewrite when updated version of com.intellij.util.xmlb is available on TeamCity
+        try {
+            val copy = XmlSerializerUtil.createCopy(to)
+
+            val fromFields = collectFieldsToCopy(from.javaClass)
+            for (fromField in fromFields) {
+                val toField = copy.javaClass.getField(fromField.name)
+                toField.set(copy, fromField.get(from))
+            }
+
+            return copy
+        }
+        catch (e: NoSuchFieldException) {
+            throw rethrow(e)
+        }
+        catch (e: IllegalAccessException) {
+            throw rethrow(e)
+        }
+
+    }
+
+    private fun collectFieldsToCopy(clazz: Class<*>): List<Field> {
+        val fromFields = ArrayList<Field>()
+
+        var currentClass: Class<*>? = clazz
+        while (currentClass != null) {
+            for (field in currentClass.declaredFields) {
+                val modifiers = field.modifiers
+                if (!Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
+                    fromFields.add(field)
+                }
+            }
+            currentClass = currentClass.superclass
+        }
+
+        return fromFields
+    }
+
+    private fun setupK2JvmArguments(moduleFile: File, settings: K2JVMCompilerArguments) {
+        settings.module = moduleFile.absolutePath
+        settings.noStdlib = true
+        settings.noJdkAnnotations = true
+        settings.noJdk = true
+    }
+
+    private fun setupK2JsArguments(
+            outputFile: File,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            settings: K2JSCompilerArguments) {
+        settings.noStdlib = true
+        settings.freeArgs = ContainerUtil.map(sourceFiles, object : Function<File, String> {","Please use Kotlin's `map { ... }`
",I don't think we need this file.
186,"@@ -0,0 +1,255 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.compilerRunner
+
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.util.ArrayUtil
+import com.intellij.util.Function
+import com.intellij.util.containers.ContainerUtil
+import com.intellij.util.xmlb.XmlSerializerUtil
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageLocation
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.ERROR
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity.INFO
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollectorUtil
+import org.jetbrains.kotlin.config.CompilerSettings
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCompilationComponents
+import org.jetbrains.kotlin.progress.CompilationCanceledStatus
+import org.jetbrains.kotlin.rmi.CompilerId
+import org.jetbrains.kotlin.rmi.configureDaemonJVMOptions
+import org.jetbrains.kotlin.rmi.configureDaemonOptions
+import org.jetbrains.kotlin.rmi.isDaemonEnabled
+import org.jetbrains.kotlin.rmi.kotlinr.*
+import org.jetbrains.kotlin.utils.rethrow
+import java.io.*
+import java.lang.reflect.Field
+import java.lang.reflect.Modifier
+import java.util.*
+
+public object KotlinCompilerRunner {
+    private val K2JVM_COMPILER = ""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""
+    private val K2JS_COMPILER = ""org.jetbrains.kotlin.cli.js.K2JSCompiler""
+    private val INTERNAL_ERROR = ExitCode.INTERNAL_ERROR.toString()
+
+    public fun runK2JvmCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jvmArguments: K2JVMCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            moduleFile: File,
+            collector: OutputItemsCollector) {
+        val arguments = mergeBeans(commonArguments, k2jvmArguments)
+        setupK2JvmArguments(moduleFile, arguments)
+
+        runCompiler(K2JVM_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    public fun runK2JsCompiler(
+            commonArguments: CommonCompilerArguments,
+            k2jsArguments: K2JSCompilerArguments,
+            compilerSettings: CompilerSettings,
+            messageCollector: MessageCollector,
+            environment: CompilerEnvironment,
+            collector: OutputItemsCollector,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            outputFile: File) {
+        val arguments = mergeBeans(commonArguments, k2jsArguments)
+        setupK2JsArguments(outputFile, sourceFiles, libraryFiles, arguments)
+
+        runCompiler(K2JS_COMPILER, arguments, compilerSettings.additionalArguments, messageCollector, collector, environment)
+    }
+
+    private fun ProcessCompilerOutput(
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            stream: ByteArrayOutputStream,
+            exitCode: String) {
+        val reader = BufferedReader(StringReader(stream.toString()))
+        CompilerOutputParser.parseCompilerMessagesFromReader(messageCollector, reader, collector)
+
+        if (INTERNAL_ERROR == exitCode) {
+            reportInternalCompilerError(messageCollector)
+        }
+    }
+
+    private fun reportInternalCompilerError(messageCollector: MessageCollector) {
+        messageCollector.report(ERROR, ""Compiler terminated with internal error"", CompilerMessageLocation.NO_LOCATION)
+    }
+
+    private fun runCompiler(
+            compilerClassName: String,
+            arguments: CommonCompilerArguments,
+            additionalArguments: String,
+            messageCollector: MessageCollector,
+            collector: OutputItemsCollector,
+            environment: CompilerEnvironment) {
+        try {
+            messageCollector.report(INFO, ""Using kotlin-home = "" + environment.kotlinPaths.homePath, CompilerMessageLocation.NO_LOCATION)
+
+            val argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments)
+            argumentsList.addAll(StringUtil.split(additionalArguments, "" ""))
+
+            val argsArray = ArrayUtil.toStringArray(argumentsList)
+
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, argsArray)) {
+                // otherwise fallback to in-process
+
+                val stream = ByteArrayOutputStream()
+                val out = PrintStream(stream)
+
+                val rc = CompilerRunnerUtil.invokeExecMethod(compilerClassName, argsArray, environment, messageCollector, out)
+
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc))
+            }
+        }
+        catch (e: Throwable) {
+            MessageCollectorUtil.reportException(messageCollector, e)
+            reportInternalCompilerError(messageCollector)
+        }
+
+    }
+
+    private fun tryCompileWithDaemon(messageCollector: MessageCollector,
+                                     collector: OutputItemsCollector,
+                                     environment: CompilerEnvironment,
+                                     argsArray: Array<String>): Boolean {
+        if (isDaemonEnabled()) {
+            val libPath = CompilerRunnerUtil.getLibPath(environment.kotlinPaths, messageCollector)
+            // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+            //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+            val compilerId = CompilerId.makeCompilerId(File(libPath, ""kotlin-compiler.jar""))
+            val daemonOptions = configureDaemonOptions()
+            val daemonJVMOptions = configureDaemonJVMOptions(true)
+
+            val daemonReportMessages = ArrayList<DaemonReportMessage>()
+
+            val daemon = KotlinCompilerClient.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, DaemonReportingTargets(null, daemonReportMessages), true, true)
+
+            for (msg in daemonReportMessages) {
+                if (msg.category === DaemonReportCategory.EXCEPTION && daemon == null) {
+                    messageCollector.report(CompilerMessageSeverity.INFO,
+                                            ""Falling  back to compilation without daemon due to error: "" + msg.message,
+                                            CompilerMessageLocation.NO_LOCATION)
+                }
+                else {
+                    messageCollector.report(CompilerMessageSeverity.INFO, msg.message, CompilerMessageLocation.NO_LOCATION)
+                }
+            }
+
+            if (daemon != null) {
+                val compilerOut = ByteArrayOutputStream()
+                val daemonOut = ByteArrayOutputStream()
+
+                val services = CompilationServices(
+                        incrementalCompilationComponents = environment.services.get(IncrementalCompilationComponents::class.java),
+                        compilationCanceledStatus = environment.services.get(CompilationCanceledStatus::class.java))
+
+                val res = KotlinCompilerClient.incrementalCompile(daemon, argsArray, services, compilerOut, daemonOut)
+
+                ProcessCompilerOutput(messageCollector, collector, compilerOut, res.toString())
+                BufferedReader(StringReader(daemonOut.toString())).forEachLine {
+                    messageCollector.report(CompilerMessageSeverity.INFO, it, CompilerMessageLocation.NO_LOCATION)
+                }
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun getReturnCodeFromObject(rc: Any?): String {
+        if (rc == null) {
+            return INTERNAL_ERROR
+        }
+        else if (ExitCode::class.java.name == rc.javaClass.name) {
+            return rc.toString()
+        }
+        else {
+            throw IllegalStateException(""Unexpected return: "" + rc)
+        }
+    }
+
+    private fun <T : CommonCompilerArguments> mergeBeans(from: CommonCompilerArguments, to: T): T {
+        // TODO: rewrite when updated version of com.intellij.util.xmlb is available on TeamCity
+        try {
+            val copy = XmlSerializerUtil.createCopy(to)
+
+            val fromFields = collectFieldsToCopy(from.javaClass)
+            for (fromField in fromFields) {
+                val toField = copy.javaClass.getField(fromField.name)
+                toField.set(copy, fromField.get(from))
+            }
+
+            return copy
+        }
+        catch (e: NoSuchFieldException) {
+            throw rethrow(e)
+        }
+        catch (e: IllegalAccessException) {
+            throw rethrow(e)
+        }
+
+    }
+
+    private fun collectFieldsToCopy(clazz: Class<*>): List<Field> {
+        val fromFields = ArrayList<Field>()
+
+        var currentClass: Class<*>? = clazz
+        while (currentClass != null) {
+            for (field in currentClass.declaredFields) {
+                val modifiers = field.modifiers
+                if (!Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
+                    fromFields.add(field)
+                }
+            }
+            currentClass = currentClass.superclass
+        }
+
+        return fromFields
+    }
+
+    private fun setupK2JvmArguments(moduleFile: File, settings: K2JVMCompilerArguments) {
+        settings.module = moduleFile.absolutePath
+        settings.noStdlib = true
+        settings.noJdkAnnotations = true
+        settings.noJdk = true
+    }
+
+    private fun setupK2JsArguments(
+            outputFile: File,
+            sourceFiles: Collection<File>,
+            libraryFiles: List<String>,
+            settings: K2JSCompilerArguments) {
+        settings.noStdlib = true
+        settings.freeArgs = ContainerUtil.map(sourceFiles, object : Function<File, String> {
+            override fun `fun`(file: File): String {
+                return file.path
+            }
+        })
+        settings.outputFile = outputFile.path
+        settings.metaInfo = true
+        settings.libraryFiles = ArrayUtil.toStringArray(libraryFiles)","`toTypedArray()`
",I don't think we need this file.
187,"@@ -0,0 +1,26 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package kotlin.jvm
+
+import java.lang.annotation.Retention
+import java.lang.annotation.RetentionPolicy
+
+/**
+ * Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.","Maybe it will be useful to document exactly what overloads are generated here? One might think that `2^n` overloads will be generated, if `n` is the number of default parameters
",How about `Instructs the Kotlin com
188,"@@ -0,0 +1,26 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.descriptors.SourceFile
+import org.jetbrains.kotlin.load.java.sources.JavaSourceElement
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+
+class JavacSourceElement(override val javaElement: JavaElement) : JavaSourceElement {",`JavacBasedSourceElement`?,I don't think we need this class.
189,"@@ -0,0 +1,26 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.load.java.sources.JavaSourceElementFactory
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+
+class JavacSourceElementFactory : JavaSourceElementFactory {",`JavacBasedSourceElementFactory`?,I don't think we need this class. I
190,"@@ -0,0 +1,26 @@
+import kotlin.test.assertEquals
+
+fun test1() {
+    val u = when (true) {
+        true -> 42
+        else -> 1.0
+    }
+
+    assertEquals(42, u)
+}
+
+fun test2() {
+    val u = 1L.let {
+        when (it) {
+            is Long -> if (it.toLong() == 2L) it.toLong() else it * 2 // CompilationException
+            else -> it.toDouble()
+        }
+    }
+
+    assertEquals(1L, u)
+}
+
+fun box(): String {
+    return ""OK""","what about test1, test2 call?
",I think this should be `1L.let`
191,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =","~~Why do we need our own isAlive implementation?~~
My bad. `Process.isAlive` was introduced in Java 8
",I don't think we need this import.
192,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)","Will we see black console window on Windows if we start `java.exe`? Shouldn't we run `javaw.exe` instead?
",I don't think this is needed.
193,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)","But if it is not then the child process could hang if there are bytes were not consumed: generally it may happen if the child process is trying to write to the pipe but nobody reads it anymore and the pipe internal buffer is full
",I don't think this is needed.
194,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    lock.write { stdouThread.stop() }
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.asParams.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way","pidfile, some kind of ping, shutdown port?
",I don't think this is needed.
195,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    lock.write { stdouThread.stop() }
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.asParams.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way
+                Thread.sleep(1000)
+                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+            }
+            else {
+                if (!autostart) return null;
+                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            }
+
+            startDaemon(compilerId, daemonLaunchingOptions, daemonOptions, errStream)
+            errStream.println(""[daemon client] daemon started, trying to connect"")
+            return connectToService(compilerId, daemonOptions, errStream)
+        }
+
+        public fun shutdownCompileService(): Unit {
+            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonLaunchingOptions(), DaemonOptions(), System.out, autostart = false, checkId = false)
+                    ?.shutdown()
+        }
+
+        public fun incrementalCompile(compiler: CompileService, args: Array<String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+            try {
+                caches.forEach { cacheServers.put( it.getKey(), RemoteIncrementalCacheServer( it.getValue())) }
+                val res = compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+                return res
+            }
+            finally {
+                cacheServers.forEach { it.getValue().disconnect() }
+                outStrm.disconnect()
+            }
+        }
+
+        public fun isDaemonEnabled(): Boolean = System.getProperty(COMPILE_DAEMON_ENABLED_PROPERTY) != null
+
+        public fun configureDaemonLaunchingOptions(opts: DaemonLaunchingOptions) {
+            System.getProperty(COMPILE_DAEMON_JVM_OPTIONS_PROPERTY)?.let {
+                // TODO: find better way to pass and parse jvm options for daemon
+                opts.jvmParams = it.split(""##"")
+            }
+        }
+
+        data class ClientOptions(
+                public var stop: Boolean = false
+        ) :CmdlineParams {
+            override val asParams: Iterable<String>
+                get() =
+                    if (stop) listOf(""stop"") else listOf()","listOf() -> emptyList()
",I don't think this is needed.
196,"@@ -0,0 +1,262 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    lock.write { stdouThread.stop() }
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.asParams.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way
+                Thread.sleep(1000)
+                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+            }
+            else {
+                if (!autostart) return null;
+                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            }
+
+            startDaemon(compilerId, daemonLaunchingOptions, daemonOptions, errStream)
+            errStream.println(""[daemon client] daemon started, trying to connect"")
+            return connectToService(compilerId, daemonOptions, errStream)
+        }
+
+        public fun shutdownCompileService(): Unit {
+            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonLaunchingOptions(), DaemonOptions(), System.out, autostart = false, checkId = false)
+                    ?.shutdown()
+        }
+
+        public fun incrementalCompile(compiler: CompileService, args: Array<String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+            try {
+                caches.forEach { cacheServers.put( it.getKey(), RemoteIncrementalCacheServer( it.getValue())) }
+                val res = compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+                return res
+            }
+            finally {
+                cacheServers.forEach { it.getValue().disconnect() }
+                outStrm.disconnect()
+            }
+        }
+
+        public fun isDaemonEnabled(): Boolean = System.getProperty(COMPILE_DAEMON_ENABLED_PROPERTY) != null
+
+        public fun configureDaemonLaunchingOptions(opts: DaemonLaunchingOptions) {
+            System.getProperty(COMPILE_DAEMON_JVM_OPTIONS_PROPERTY)?.let {
+                // TODO: find better way to pass and parse jvm options for daemon
+                opts.jvmParams = it.split(""##"")
+            }
+        }
+
+        data class ClientOptions(
+                public var stop: Boolean = false
+        ) :CmdlineParams {
+            override val asParams: Iterable<String>
+                get() =
+                    if (stop) listOf(""stop"") else listOf()
+
+            override val parsers: List<PropParser<*,*,*>>
+                get() = listOf( BoolPropParser(this, ::stop))
+        }
+
+        platformStatic public fun main(vararg args: String) {
+            val compilerId = CompilerId()
+            val daemonOptions = DaemonOptions()
+            val daemonLaunchingOptions = DaemonLaunchingOptions()
+            val clientOptions = ClientOptions()
+            val filteredArgs = args.asIterable().propParseFilter(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions)
+
+            if (!clientOptions.stop) {
+                if (compilerId.compilerClasspath.none()) {
+                    // attempt to find compiler to use
+                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
+                    System.getProperty(""java.class.path"")
+                            ?.split(File.pathSeparator)
+                            ?.map { File(it).parent }
+                            ?.distinct()
+                            ?.map {
+                                it?.walk()
+                                        ?.firstOrNull { it.getName().equals(COMPILER_JAR_NAME, ignoreCase = true) }
+                            }
+                            ?.filterNotNull()
+                            ?.firstOrNull()
+                            ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
+                }
+                if (compilerId.compilerClasspath.none())
+                    throw IllegalArgumentException(""Cannot find compiler jar"")
+                else
+                    println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
+
+                compilerId.updateDigest()
+            }
+
+            connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, System.out, autostart = !clientOptions.stop, checkId = !clientOptions.stop)?.let {
+                when {
+                    clientOptions.stop -> {
+                        println(""Shutdown the daemon"")
+                        it.shutdown()
+                        println(""Daemon shut down successfully"")
+                    }
+                    else -> {
+                        println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
+                        val outStrm = RemoteOutputStreamServer(System.out)
+                        try {
+                            val memBefore = it.getUsedMemory() / 1024
+                            val startTime = System.nanoTime()
+                            val res = it.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN)
+                            val endTime = System.nanoTime()","We can use kotlin's `measureTimeMillis` or `measureTimeNano`: http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.util/index.html
",I don't think this is needed.
197,"@@ -0,0 +1,263 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import kotlin.concurrent.thread
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+                val javaw = File(it, ""javaw.exe"")
+                if (javaw.exists()) javaw
+                else File(it, ""java"")
+            }
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable.absolutePath,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                       compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            var isEchoRead = Semaphore(1)
+            isEchoRead.acquire()
+
+            val stdoutThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
+                                      isEchoRead.release()
+                                      return@forEachLine
+                                  }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (!succeeded)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdoutThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    stdoutThread.stop()
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way
+                Thread.sleep(1000)
+                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+            }
+            else {
+                if (!autostart) return null;
+                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            }
+
+            startDaemon(compilerId, daemonJVMOptions, daemonOptions, errStream)
+            errStream.println(""[daemon client] daemon started, trying to connect"")
+            return connectToService(compilerId, daemonOptions, errStream)
+        }
+
+        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, System.out, autostart = false, checkId = false)
+                    ?.shutdown()
+        }
+
+        public fun shutdownCompileService(): Unit {
+            shutdownCompileService(DaemonOptions())
+        }
+
+        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            try {
+                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
+            }
+            finally {
+                outStrm.disconnect()
+            }
+        }
+
+        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+            try {
+                caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer( it.getValue()) })
+                return compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+            }
+            finally {
+                cacheServers.forEach { it.getValue().disconnect() }
+                outStrm.disconnect()
+            }
+        }
+
+        data class ClientOptions(
+                public var stop: Boolean = false
+        ) : OptionsGroup {
+            override val mappers: List<PropMapper<*, *, *>>
+                get() = listOf( BoolPropMapper(this, ::stop))
+        }
+
+        jvmStatic public fun main(vararg args: String) {
+            val compilerId = CompilerId()
+            val daemonOptions = DaemonOptions()
+            val daemonLaunchingOptions = DaemonJVMOptions()
+            val clientOptions = ClientOptions()
+            val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
+
+            if (!clientOptions.stop) {
+                if (compilerId.compilerClasspath.none()) {
+                    // attempt to find compiler to use
+                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")","Why are you printing this & other information to stdout, not stderr?
",I don't think we need this `f
198,"@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.structure
+
+interface ESEffect {
+    /**
+     * Returns:
+     *  - true, when presence of `this`-effect necessary implies presence of `other`-effect
+     *  - false, when presence of `this`-effect necessary implies absence of `other`-effect
+     *  - null, when presence of `this`-effect doesn't implies neither presence nor absence of `other`-effect
+     */
+    fun isImplies(other: ESEffect): Boolean?",It's matter of taste but I'd use here some enum with three elements,I'm not sure if this is the b
199,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1","Try to run optimize imports and reformat
",I don't think we need this im
200,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {","Looks like it should be object
",nit: `fun` -> `function`
201,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L","private?
",I think this is not needed.
202,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {","we prefer to first declare a public API
",I don't think we need this cl
203,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running","minor: I'd inline `connectToDaemon`
",I don't think this is needed.
204,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:","Why ClassCastException is not enough here?
",I don't think this is needed.
205,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)","We prefer to use braces in `if` except one-line ifs: `if (cond) return/break/continue`
",I don't think this is needed.
206,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+                val javaw = File(it, ""javaw.exe"")
+                if (javaw.exists()) javaw
+                else File(it, ""java"")
+            }
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable.absolutePath,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.extractors.flatMap { it.extract(""-"") } +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                       compilerId.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            var isEchoRead = Semaphore(1)
+            isEchoRead.acquire()
+
+            val stdoutThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
+                                      isEchoRead.release()
+                                      return@forEachLine
+                                  }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (!succeeded)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else","braces
",I don't think this is needed.
207,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+                val javaw = File(it, ""javaw.exe"")
+                if (javaw.exists()) javaw
+                else File(it, ""java"")
+            }
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable.absolutePath,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.extractors.flatMap { it.extract(""-"") } +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                       compilerId.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            var isEchoRead = Semaphore(1)
+            isEchoRead.acquire()
+
+            val stdoutThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
+                                      isEchoRead.release()
+                                      return@forEachLine
+                                  }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (!succeeded)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdoutThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    stdoutThread.stop()
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&","why we skip empty parameters?
",I don't think this is needed.
208,"@@ -0,0 +1,271 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.Semaphore
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+import kotlin.reflect.KProperty1
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+                val javaw = File(it, ""javaw.exe"")
+                if (javaw.exists()) javaw
+                else File(it, ""java"")
+            }
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable.absolutePath,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.extractors.flatMap { it.extract(""-"") } +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                       compilerId.extractors.flatMap { it.extract(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            var isEchoRead = Semaphore(1)
+            isEchoRead.acquire()
+
+            val stdoutThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
+                                      isEchoRead.release()
+                                      return@forEachLine
+                                  }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (!succeeded)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdoutThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    stdoutThread.stop()
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&","`containsAll`
",I don't think this is needed.
209,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)","i'd just add default value for `name` to primary constructor
",Could you please add the copy
210,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()","we can get list with string which ends with ""null"" and `filterNotNull` is unnecessary here
",Could you please add the copy
211,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {","I think we need better name for this function
",Could you please add the copy
212,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->","I think it'll be simpler if rewrite with `while`
",Could you please add the copy
213,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }","replace `;` with `\n`
",Could you please add the copy
214,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true","please don't mix blocks with and without braces
",Could you please add the copy
215,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {","minor: I don't like `Cmdline`
",Could you please add the copy
216,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>","I think these properties should not be part of public api
",Could you please add the copy
217,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =","what is cs?
",Could you please add the copy
218,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",","I don't like public vars and public constructor in inheritors of CmdlineParams
",Could you please add the copy
219,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),","I'd extract `{ it.isEmpty() }` to constant
",Could you please add the copy
220,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),","i'd extract `{ it }` or use `identity()` from `core/util.runtime/src/org/jetbrains/kotlin/utils/functions.kt`
",Could you please add the copy
221,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),","Should `allowMergedArg` be false here?
",Could you please add the copy
222,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,","I'd toggle case of `s` or drop `auto` prefix
",Could you please add the copy
223,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::port),
+                        PropExtractor(this, ::autoshutdownMemoryThreshold, skipIf = { it == 0L }),
+                        PropExtractor(this, ::autoshutdownIdleSeconds, skipIf = { it == 0 }),
+                        PropExtractor(this, ::startEcho))
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""","private?
",Could you please add the copy
224,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::port),
+                        PropExtractor(this, ::autoshutdownMemoryThreshold, skipIf = { it == 0L }),
+                        PropExtractor(this, ::autoshutdownIdleSeconds, skipIf = { it == 0 }),
+                        PropExtractor(this, ::startEcho))
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {","private?
",Could you please add the copyright header to this file?
225,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::port),
+                        PropExtractor(this, ::autoshutdownMemoryThreshold, skipIf = { it == 0L }),
+                        PropExtractor(this, ::autoshutdownIdleSeconds, skipIf = { it == 0 }),
+                        PropExtractor(this, ::startEcho))
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {
+    DigestInputStream(file.inputStream(), md).use {
+        val buf = ByteArray(1024)
+        while (it.read(buf) != -1) { }
+        it.close()
+    }
+}
+
+fun updateForAllClasses(dir: File, md: MessageDigest) {
+    dir.walk().forEach { updateEntryDigest(it, md) }
+}
+
+fun updateEntryDigest(entry: File, md: MessageDigest) {
+    when {
+        entry.isDirectory
+            -> updateForAllClasses(entry, md)
+        entry.isFile &&
+                (entry.getName().endsWith("".class"", ignoreCase = true) ||","`getName()` can be replaces with `name`
",Could you please add the copyright header to this file?
226,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::port),
+                        PropExtractor(this, ::autoshutdownMemoryThreshold, skipIf = { it == 0L }),
+                        PropExtractor(this, ::autoshutdownIdleSeconds, skipIf = { it == 0 }),
+                        PropExtractor(this, ::startEcho))
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {
+    DigestInputStream(file.inputStream(), md).use {
+        val buf = ByteArray(1024)
+        while (it.read(buf) != -1) { }
+        it.close()
+    }
+}
+
+fun updateForAllClasses(dir: File, md: MessageDigest) {
+    dir.walk().forEach { updateEntryDigest(it, md) }
+}
+
+fun updateEntryDigest(entry: File, md: MessageDigest) {
+    when {
+        entry.isDirectory
+            -> updateForAllClasses(entry, md)
+        entry.isFile &&
+                (entry.getName().endsWith("".class"", ignoreCase = true) ||
+                entry.getName().endsWith("".jar"", ignoreCase = true))
+            -> updateSingleFileDigest(entry, md)
+        // else skip
+    }
+}
+
+fun Iterable<File>.getFilesClasspathDigest(): String {
+    val md = MessageDigest.getInstance(COMPILER_ID_DIGEST)
+    this.forEach { updateEntryDigest(it, md) }
+    return md.digest().joinToString("""", transform = { ""%02x"".format(it) })
+}
+
+fun Iterable<String>.getClasspathDigest(): String = map { File(it) }.getFilesClasspathDigest()
+
+
+public data class CompilerId(
+        public var compilerClasspath: List<String> = listOf(),
+        public var compilerDigest: String = """",
+        public var compilerVersion: String = """"
+        // TODO: checksum
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::compilerClasspath, convert = { it.joinToString(File.pathSeparator) }),
+                        PropExtractor(this, ::compilerDigest),
+                        PropExtractor(this, ::compilerVersion, skipIf = { it.isEmpty() }))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() =
+            listOf( PropParser(this, ::compilerClasspath, { it.trim('""').split(File.pathSeparator)}),
+                    PropParser(this, ::compilerDigest, { it.trim('""') }),
+                    PropParser(this, ::compilerVersion, { it.trim('""') }))
+
+    public fun updateDigest() {
+        compilerDigest = compilerClasspath.getClasspathDigest()
+    }
+
+    companion object {
+        public platformStatic fun makeCompilerId(vararg paths: File): CompilerId = makeCompilerId(paths.asIterable())","`platformStatic` deprecated now
",Could you please add the copyright header to this file?
227,"@@ -0,0 +1,272 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.platform.platformStatic
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+
+
+open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+                                                    val prop: P,
+                                                    val name: String,
+                                                    val convert: ((v: V) -> String?) = { it.toString() },
+                                                    val skipIf: ((v: V) -> Boolean) = { false },
+                                                    val mergeWithDelimiter: String? = null)
+{
+    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+            }
+}
+
+class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+}
+
+
+open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P, alternativeNames: List<String>,
+                                                        val parse: (s: String) -> V,
+                                                        val allowMergedArg: Boolean = false) {
+    val names = listOf(prop.name) + alternativeNames
+    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+    fun apply(s: String) = prop.set(dest, parse(s))
+}
+
+class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+
+class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+
+fun Iterable<String>.filterSetProps(parsers: List<PropParser<*,*,*>>, prefix: String, restParser: RestPropParser<*,*>? = null) : Iterable<String>  {
+    var currentParser: PropParser<*,*,*>? = null
+    var matchingOption = """"
+    val res = filter { param ->
+        if (currentParser == null) {
+            val parser = parsers.find { it.names.any { name ->
+                if (param.startsWith(prefix + name)) { matchingOption = prefix + name; true }
+                else false } }
+            if (parser != null) {
+                val optionLength = matchingOption.length()
+                when {
+                    parser is BoolPropParser<*,*> ->
+                        if (param.length() > optionLength) throw IllegalArgumentException(""Invalid switch option '$param', expecting $matchingOption without arguments"")
+                        else parser.apply("""")
+                    param.length() > optionLength ->
+                        if (param[optionLength] != '=') {
+                            if (parser.allowMergedArg) parser.apply(param.substring(optionLength))
+                            else throw IllegalArgumentException(""Invalid option syntax '$param', expecting $matchingOption[= ]<arg>"")
+                        }
+                        else parser.apply(param.substring(optionLength + 1))
+                    else -> currentParser = parser
+                }
+                false
+            }
+            else if (restParser != null && param.startsWith(prefix)) {
+                restParser.add(param.removePrefix(prefix))
+                false
+            }
+            else true
+        }
+        else {
+            currentParser!!.apply(param)
+            currentParser = null
+            false
+        }
+    }
+    if (currentParser != null) throw IllegalArgumentException(""Expecting argument for the option $matchingOption"")
+    return res
+}
+
+// TODO: find out how to create more generic variant using first constructor
+//fun<C> C.propsToParams() {
+//    val kc = C::class
+//    kc.constructors.first().
+//}
+
+
+
+public interface CmdlineParams : Serializable {
+    public val extractors: List<PropExtractor<*,*,*>>
+    public val parsers: List<PropParser<*,*,*>>
+}
+
+public fun Iterable<String>.filterSetProps(vararg cs: CmdlineParams, prefix: String) : Iterable<String> =
+    filterSetProps(cs.flatMap { it.parsers }, prefix)
+
+
+public data class DaemonLaunchingOptions(
+        public var maxMemory: String = """",
+        public var maxPermSize: String = """",
+        public var reservedCodeCacheSize: String = """",
+        public var otherJvmParams: MutableCollection<String> = arrayListOf()
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*,*,*>>
+        get() = listOf( PropExtractor(this, ::maxMemory, ""Xmx"", skipIf = { it.isEmpty() }, mergeWithDelimiter = """"),
+                        PropExtractor(this, ::maxPermSize, ""XX:MaxPermSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        PropExtractor(this, ::reservedCodeCacheSize, ""XX:ReservedCodeCacheSize"", skipIf = { it.isEmpty() }, mergeWithDelimiter = ""=""),
+                        RestPropExtractor(this, ::otherJvmParams))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() = listOf( PropParser(this, ::maxMemory, listOf(""Xmx""), { it }, allowMergedArg = true),
+                        PropParser(this, ::maxPermSize, listOf(""XX:MaxPermSize""), { it }, allowMergedArg = true),
+                        PropParser(this, ::reservedCodeCacheSize, listOf(""XX:ReservedCodeCacheSize""), { it }, allowMergedArg = true))
+                        // otherJvmParams is missing here deliberately, it is used explicitly as a restParser param to filterSetProps
+}
+
+public data class DaemonOptions(
+        public var port: Int = COMPILE_DAEMON_DEFAULT_PORT,
+        public var autoshutdownMemoryThreshold: Long = 0 /* 0 means unchecked */,
+        public var autoshutdownIdleSeconds: Int = 0 /* 0 means unchecked */,
+        public var startEcho: String = COMPILER_SERVICE_RMI_NAME
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::port),
+                        PropExtractor(this, ::autoshutdownMemoryThreshold, skipIf = { it == 0L }),
+                        PropExtractor(this, ::autoshutdownIdleSeconds, skipIf = { it == 0 }),
+                        PropExtractor(this, ::startEcho))
+
+    override val parsers: List<PropParser<*,*,*>>
+            get() = listOf( PropParser(this, ::port, { it.toInt()}),
+                            PropParser(this, ::autoshutdownMemoryThreshold, { it.toLong()}),
+                            PropParser(this, ::autoshutdownIdleSeconds, { it.toInt()}),
+                            PropParser(this, ::startEcho, { it.trim('""') }))
+}
+
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+
+fun updateSingleFileDigest(file: File, md: MessageDigest) {
+    DigestInputStream(file.inputStream(), md).use {
+        val buf = ByteArray(1024)
+        while (it.read(buf) != -1) { }
+        it.close()
+    }
+}
+
+fun updateForAllClasses(dir: File, md: MessageDigest) {
+    dir.walk().forEach { updateEntryDigest(it, md) }
+}
+
+fun updateEntryDigest(entry: File, md: MessageDigest) {
+    when {
+        entry.isDirectory
+            -> updateForAllClasses(entry, md)
+        entry.isFile &&
+                (entry.getName().endsWith("".class"", ignoreCase = true) ||
+                entry.getName().endsWith("".jar"", ignoreCase = true))
+            -> updateSingleFileDigest(entry, md)
+        // else skip
+    }
+}
+
+fun Iterable<File>.getFilesClasspathDigest(): String {
+    val md = MessageDigest.getInstance(COMPILER_ID_DIGEST)
+    this.forEach { updateEntryDigest(it, md) }
+    return md.digest().joinToString("""", transform = { ""%02x"".format(it) })
+}
+
+fun Iterable<String>.getClasspathDigest(): String = map { File(it) }.getFilesClasspathDigest()
+
+
+public data class CompilerId(
+        public var compilerClasspath: List<String> = listOf(),
+        public var compilerDigest: String = """",
+        public var compilerVersion: String = """"
+        // TODO: checksum
+) : CmdlineParams {
+
+    override val extractors: List<PropExtractor<*, *, *>>
+        get() = listOf( PropExtractor(this, ::compilerClasspath, convert = { it.joinToString(File.pathSeparator) }),
+                        PropExtractor(this, ::compilerDigest),
+                        PropExtractor(this, ::compilerVersion, skipIf = { it.isEmpty() }))
+
+    override val parsers: List<PropParser<*,*,*>>
+        get() =
+            listOf( PropParser(this, ::compilerClasspath, { it.trim('""').split(File.pathSeparator)}),
+                    PropParser(this, ::compilerDigest, { it.trim('""') }),
+                    PropParser(this, ::compilerVersion, { it.trim('""') }))
+
+    public fun updateDigest() {
+        compilerDigest = compilerClasspath.getClasspathDigest()
+    }
+
+    companion object {
+        public platformStatic fun makeCompilerId(vararg paths: File): CompilerId = makeCompilerId(paths.asIterable())
+
+        public platformStatic fun makeCompilerId(paths: Iterable<File>): CompilerId =","it has only one usage
",Could you please add the copyright header to this file?
228,"@@ -0,0 +1,276 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false","Would be simpler to use an AtomicBoolean here. Or better yet, a semaphore, in which case you won't need a wait loop.
",I don't think this is needed.
229,"@@ -0,0 +1,276 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =","typo: stdoutThread
",I don't think this is needed.
230,"@@ -0,0 +1,276 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    lock.write { stdouThread.stop() }
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.asParams.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way
+                Thread.sleep(1000)
+                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+            }
+            else {
+                if (!autostart) return null;
+                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            }
+
+            startDaemon(compilerId, daemonLaunchingOptions, daemonOptions, errStream)
+            errStream.println(""[daemon client] daemon started, trying to connect"")
+            return connectToService(compilerId, daemonOptions, errStream)
+        }
+
+        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonLaunchingOptions(), daemonOptions, System.out, autostart = false, checkId = false)
+                    ?.shutdown()
+        }
+
+        public fun shutdownCompileService(): Unit {
+            shutdownCompileService(DaemonOptions())
+        }
+
+        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            try {
+                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
+            }
+            finally {
+                outStrm.disconnect()
+            }
+        }
+
+        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+            try {
+                caches.forEach { cacheServers.put( it.getKey(), RemoteIncrementalCacheServer( it.getValue())) }","`mapValues()`
",I don't think this is needed.
231,"@@ -0,0 +1,276 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
+import org.jetbrains.kotlin.rmi.*
+import java.io.File
+import java.io.OutputStream
+import java.io.PrintStream
+import java.rmi.ConnectException
+import java.rmi.Remote
+import java.rmi.registry.LocateRegistry
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.locks.ReentrantReadWriteLock
+import kotlin.concurrent.read
+import kotlin.concurrent.thread
+import kotlin.concurrent.write
+import kotlin.platform.platformStatic
+
+fun Process.isAlive() =
+        try {
+            this.exitValue()
+            false
+        }
+        catch (e: IllegalThreadStateException) {
+            true
+        }
+
+public class KotlinCompilerClient {
+
+    companion object {
+
+        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
+        val DAEMON_STARTUP_CHECK_INTERVAL_MS = 100L
+
+        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+
+            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
+            return compilerObj as? CompileService ?:
+                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+        }
+
+        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
+            try {
+                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
+                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
+                if (daemon != null)
+                    return daemon
+                errStream.println(""[daemon client] daemon not found"")
+            }
+            catch (e: ConnectException) {
+                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+                // ignoring it - processing below
+            }
+            return null
+        }
+
+
+        private fun startDaemon(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
+            val javaExecutable = listOf(System.getProperty(""java.home""), ""bin"", ""java"").joinToString(File.separator)
+            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
+            val args = listOf(javaExecutable,
+                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                       daemonLaunchingOptions.jvmParams +
+                       COMPILER_DAEMON_CLASS_FQN +
+                       daemonOptions.asParams +
+                       compilerId.asParams
+            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
+            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+            val daemon = processBuilder.start()
+
+            val lock = ReentrantReadWriteLock()
+            var isEchoRead = false
+
+            val stdouThread =
+                    thread {
+                        daemon.getInputStream()
+                              .reader()
+                              .forEachLine {
+                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho))
+                                      lock.write { isEchoRead = true; return@forEachLine }
+                                  errStream.println(""[daemon] "" + it)
+                              }
+                    }
+            try {
+                // trying to wait for process
+                if (daemonOptions.startEcho.isNotEmpty()) {
+                    errStream.println(""[daemon client] waiting for daemon to respond"")
+                    var waitMillis: Long = DAEMON_STARTUP_TIMEOUT_MS / DAEMON_STARTUP_CHECK_INTERVAL_MS
+                    while (waitMillis-- > 0) {
+                        Thread.sleep(DAEMON_STARTUP_CHECK_INTERVAL_MS)
+                        if (!daemon.isAlive() || lock.read { isEchoRead } == true) break;
+                    }
+                    if (!daemon.isAlive())
+                        throw Exception(""Daemon terminated unexpectedly"")
+                    if (lock.read { isEchoRead } == false)
+                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
+                }
+                else
+                // without startEcho defined waiting for max timeout
+                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
+            }
+            finally {
+                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+                if (stdouThread.isAlive)
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                    lock.write { stdouThread.stop() }
+            }
+        }
+
+        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
+            val remoteId = compiler.getCompilerId()
+            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
+            errStream.println(""[daemon client] localId = "" + localId.toString())
+            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+        }
+
+        public fun connectToCompileService(compilerId: CompilerId, daemonLaunchingOptions: DaemonLaunchingOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
+            val service = connectToService(compilerId, daemonOptions, errStream)
+            if (service != null) {
+                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
+                    errStream.println(""[daemon client] found the suitable daemon"")
+                    return service
+                }
+                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.asParams.joinToString("" ""))
+                if (!autostart) return null;
+                errStream.println(""[daemon client] shutdown the daemon"")
+                service.shutdown()
+                // TODO: find more reliable way
+                Thread.sleep(1000)
+                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+            }
+            else {
+                if (!autostart) return null;
+                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            }
+
+            startDaemon(compilerId, daemonLaunchingOptions, daemonOptions, errStream)
+            errStream.println(""[daemon client] daemon started, trying to connect"")
+            return connectToService(compilerId, daemonOptions, errStream)
+        }
+
+        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonLaunchingOptions(), daemonOptions, System.out, autostart = false, checkId = false)
+                    ?.shutdown()
+        }
+
+        public fun shutdownCompileService(): Unit {
+            shutdownCompileService(DaemonOptions())
+        }
+
+        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            try {
+                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
+            }
+            finally {
+                outStrm.disconnect()
+            }
+        }
+
+        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+
+            val outStrm = RemoteOutputStreamServer(out)
+            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+            try {
+                caches.forEach { cacheServers.put( it.getKey(), RemoteIncrementalCacheServer( it.getValue())) }
+                return compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+            }
+            finally {
+                cacheServers.forEach { it.getValue().disconnect() }
+                outStrm.disconnect()
+            }
+        }
+
+        public fun isDaemonEnabled(): Boolean = System.getProperty(COMPILE_DAEMON_ENABLED_PROPERTY) != null
+
+        public fun configureDaemonLaunchingOptions(opts: DaemonLaunchingOptions) {
+            System.getProperty(COMPILE_DAEMON_JVM_OPTIONS_PROPERTY)?.let {
+                // TODO: find better way to pass and parse jvm options for daemon
+                opts.jvmParams = it.split(""##"")
+            }
+        }
+
+        data class ClientOptions(
+                public var stop: Boolean = false
+        ) :CmdlineParams {
+            override val asParams: Iterable<String>
+                get() =
+                    if (stop) listOf(""stop"") else listOf()
+
+            override val parsers: List<PropParser<*,*,*>>
+                get() = listOf( BoolPropParser(this, ::stop))
+        }
+
+        platformStatic public fun main(vararg args: String) {
+            val compilerId = CompilerId()
+            val daemonOptions = DaemonOptions()
+            val daemonLaunchingOptions = DaemonLaunchingOptions()
+            val clientOptions = ClientOptions()
+            val filteredArgs = args.asIterable().propParseFilter(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions)
+
+            if (!clientOptions.stop) {
+                if (compilerId.compilerClasspath.none()) {
+                    // attempt to find compiler to use
+                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
+                    System.getProperty(""java.class.path"")
+                            ?.split(File.pathSeparator)
+                            ?.map { File(it).parent }
+                            ?.distinct()
+                            ?.map {
+                                it?.walk()
+                                        ?.firstOrNull { it.getName().equals(COMPILER_JAR_NAME, ignoreCase = true) }
+                            }
+                            ?.filterNotNull()
+                            ?.firstOrNull()
+                            ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
+                }
+                if (compilerId.compilerClasspath.none())
+                    throw IllegalArgumentException(""Cannot find compiler jar"")
+                else
+                    println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
+
+                compilerId.updateDigest()
+            }
+
+            connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, System.out, autostart = !clientOptions.stop, checkId = !clientOptions.stop)?.let {
+                when {
+                    clientOptions.stop -> {
+                        println(""Shutdown the daemon"")
+                        it.shutdown()
+                        println(""Daemon shut down successfully"")
+                    }
+                    else -> {
+                        println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
+                        val outStrm = RemoteOutputStreamServer(System.out)
+                        try {
+                            val memBefore = it.getUsedMemory() / 1024
+                            val startTime = System.nanoTime()
+                            val res = it.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN)
+                            val endTime = System.nanoTime()
+                            println(""Compilation result code: $res"")
+                            val memAfter = it.getUsedMemory() / 1024
+                            println(""Compilation time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
+                            println(""Used memory $memAfter (${""%+d"".format(memAfter - memBefore)} kb)"")
+                        }
+                        finally {
+                            outStrm.disconnect()
+                        }
+                    }
+                }
+            }
+            ?: if (clientOptions.stop) println(""No daemon found to shut down"")","I think that such dangling `?:` are fairly hard to understand.
",I don't think this is needed.
232,"@@ -0,0 +1,278 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.caches
+
+import com.intellij.openapi.projectRoots.Sdk
+import com.intellij.psi.PsiField
+import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiModifier
+import com.intellij.psi.search.GlobalSearchScope
+import com.intellij.psi.search.PsiShortNamesCache
+import com.sun.tools.javac.util.Convert.shortName
+import junit.framework.TestCase
+import org.jetbrains.kotlin.asJava.elements.KtLightField
+import org.jetbrains.kotlin.asJava.elements.KtLightMethod
+import org.jetbrains.kotlin.idea.refactoring.fqName.getKotlinFqName
+import org.jetbrains.kotlin.idea.test.ConfigLibraryUtil
+import org.jetbrains.kotlin.idea.test.KotlinCodeInsightTestCase
+import org.jetbrains.kotlin.idea.test.PluginTestCaseBase
+import org.jetbrains.kotlin.load.java.JvmAbi
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.test.KotlinTestUtils
+
+
+/**","Please remove this comment
",I think we don't need this import.
233,"@@ -0,0 +1,278 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:
+ * - [Iterable.groupingBy]
+ * - [Sequence.groupingBy]
+ * - [Array.groupingBy]
+ * - [CharSequence.groupingBy]
+ *
+ * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.
+ */
+@SinceKotlin(""1.1"")
+public interface Grouping<T, out K> {
+    /** Returns an [Iterator] which iterates through the elements of the source. */
+    fun elementIterator(): Iterator<T>","@{18f15b45-4413-42a3-82e7-d057983d1e65,Ilya Gorbunov} `sourceIterator()` or just `source()` ? Need to be documented: whether it creates iterator every time or keep the same instance. If the behaviour is undefined we have to notice it here.",I don't think we need the `out` parameter.
234,"@@ -0,0 +1,278 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:
+ * - [Iterable.groupingBy]
+ * - [Sequence.groupingBy]
+ * - [Array.groupingBy]
+ * - [CharSequence.groupingBy]
+ *
+ * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.
+ */
+@SinceKotlin(""1.1"")
+public interface Grouping<T, out K> {
+    /** Returns an [Iterator] which iterates through the elements of the source. */
+    fun elementIterator(): Iterator<T>
+    /** Extracts the key of an [element]. */
+    fun keyOf(element: T): K
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and aggregates elements of each group with the specified [operation].
+ *
+ * The key for each element is provided by the [Grouping.keyOf] function.
+ *
+ * @param operation function is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `value`: the current value of the accumulator of a group, can be `null` if it's first `element` encountered in the group;
+ *  - `element`: the element from the source being aggregated;
+ *  - `first`: indicates whether it's first `element` encountered in the group.
+ *
+ * @return a [Map] associating the key of each group with the result of aggregation of the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R> Grouping<T, K>.aggregate(
+        operation: (key: K, value: R?, element: T, first: Boolean) -> R
+): Map<K, R> {
+    val result = mutableMapOf<K, R>()",Why don't we use `aggregateTo` instead?,I'm not sure if this is the right way to do it. I think
235,"@@ -0,0 +1,278 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:
+ * - [Iterable.groupingBy]
+ * - [Sequence.groupingBy]
+ * - [Array.groupingBy]
+ * - [CharSequence.groupingBy]
+ *
+ * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.
+ */
+@SinceKotlin(""1.1"")
+public interface Grouping<T, out K> {
+    /** Returns an [Iterator] which iterates through the elements of the source. */
+    fun elementIterator(): Iterator<T>
+    /** Extracts the key of an [element]. */
+    fun keyOf(element: T): K
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and aggregates elements of each group with the specified [operation].
+ *
+ * The key for each element is provided by the [Grouping.keyOf] function.
+ *
+ * @param operation function is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `value`: the current value of the accumulator of a group, can be `null` if it's first `element` encountered in the group;
+ *  - `element`: the element from the source being aggregated;
+ *  - `first`: indicates whether it's first `element` encountered in the group.
+ *
+ * @return a [Map] associating the key of each group with the result of aggregation of the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R> Grouping<T, K>.aggregate(
+        operation: (key: K, value: R?, element: T, first: Boolean) -> R
+): Map<K, R> {
+    val result = mutableMapOf<K, R>()
+    for (e in this.elementIterator()) {
+        val key = keyOf(e)
+        val value = result[key]
+        result[key] = operation(key, value, e, value == null && !result.containsKey(key))
+    }
+    return result
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and aggregates elements of each group with the specified [operation]
+ * to the given [destination] map.
+ *
+ * The key for each element is provided by the [Grouping.keyOf] function.
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's first `element` encountered in the group;
+ *  - `element`: the element from the source being aggregated;
+ *  - `first`: indicates whether it's first `element` encountered in the group.
+ *
+ * If the [destination] map already has a value corresponding to some key,
+ * then the elements being aggregated for that key are never considered as `first`.
+ *
+ * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(
+        destination: M,
+        operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R","`value` vs `accumulator`, `v` vs `acc`",I'm not sure if this is the right way to do it. I think
236,"@@ -0,0 +1,278 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:
+ * - [Iterable.groupingBy]
+ * - [Sequence.groupingBy]
+ * - [Array.groupingBy]
+ * - [CharSequence.groupingBy]
+ *
+ * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.
+ */
+@SinceKotlin(""1.1"")
+public interface Grouping<T, out K> {
+    /** Returns an [Iterator] which iterates through the elements of the source. */
+    fun elementIterator(): Iterator<T>
+    /** Extracts the key of an [element]. */
+    fun keyOf(element: T): K
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and aggregates elements of each group with the specified [operation].
+ *
+ * The key for each element is provided by the [Grouping.keyOf] function.
+ *
+ * @param operation function is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `value`: the current value of the accumulator of a group, can be `null` if it's first `element` encountered in the group;
+ *  - `element`: the element from the source being aggregated;
+ *  - `first`: indicates whether it's first `element` encountered in the group.
+ *
+ * @return a [Map] associating the key of each group with the result of aggregation of the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R> Grouping<T, K>.aggregate(
+        operation: (key: K, value: R?, element: T, first: Boolean) -> R
+): Map<K, R> {
+    val result = mutableMapOf<K, R>()
+    for (e in this.elementIterator()) {
+        val key = keyOf(e)
+        val value = result[key]
+        result[key] = operation(key, value, e, value == null && !result.containsKey(key))
+    }
+    return result
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and aggregates elements of each group with the specified [operation]
+ * to the given [destination] map.
+ *
+ * The key for each element is provided by the [Grouping.keyOf] function.
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's first `element` encountered in the group;
+ *  - `element`: the element from the source being aggregated;
+ *  - `first`: indicates whether it's first `element` encountered in the group.
+ *
+ * If the [destination] map already has a value corresponding to some key,
+ * then the elements being aggregated for that key are never considered as `first`.
+ *
+ * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(
+        destination: M,
+        operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R
+): M {
+    for (e in this.elementIterator()) {
+        val key = keyOf(e)
+        val acc = destination[key]
+        destination[key] = operation(key, acc, e, acc == null && !destination.containsKey(key))
+    }
+    return destination
+}
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting with an initial value of accumulator provided by the [initialValueSelector] function.
+ *
+ * @param initialValueSelector a function that provides an initial value of accumulator for an each group.
+ *  It's invoked with parameters:
+ *  - `key`: the key of a group;
+ *  - `element`: the first element being encountered in that group.
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being accumulated.
+ *
+ * @return a [Map] associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R> Grouping<T, K>.fold(
+        initialValueSelector: (key: K, element: T) -> R,
+        operation: (key: K, accumulator: R, element: T) -> R
+): Map<K, R> =
+        aggregate { key, value, e, first -> operation(key, if (first) initialValueSelector(key, e) else value as R, e) }
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting with an initial value of accumulator provided by the [initialValueSelector] function
+ * to the given [destination] map.
+ *
+ * @param initialValueSelector a function that provides an initial value of accumulator for an each group.
+ *  It's invoked with parameters:
+ *  - `key`: the key of a group;
+ *  - `element`: the first element being encountered in that group.
+ *
+ * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of
+ * the accumulator for that group and the [initialValueSelector] function is not called for that group.
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being accumulated.
+ *
+ * @return the [destination] map associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(
+        destination: M,
+        initialValueSelector: (key: K, element: T) -> R,
+        operation: (key: K, accumulator: R, element: T) -> R
+): M =
+        aggregateTo(destination) { key, value, e, first -> operation(key, if (first) initialValueSelector(key, e) else value as R, e) }
+
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting with the [initialValue].
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being accumulated.
+ *
+ * @return a [Map] associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R> Grouping<T, K>.fold(
+        initialValue: R,
+        operation: (accumulator: R, element: T) -> R
+): Map<K, R> =
+        aggregate { k, v, e, first -> operation(if (first) initialValue else v as R, e) }
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting with the [initialValue] to the given [destination] map.
+ *
+ * If the [destination] map already has a value corresponding to the key of some group,
+ * that value is used as an initial value of the accumulator for that group.
+ *
+ * @param operation a function that is invoked on each element with the following parameters:
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being accumulated.
+ *
+ * @return the [destination] map associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(
+        destination: M,
+        initialValue: R,
+        operation: (accumulator: R, element: T) -> R
+): M =
+        aggregateTo(destination) { k, v, e, first -> operation(if (first) initialValue else v as R, e) }
+
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting the first element in that group.
+ *
+ * @param operation a function that is invoked on each subsequent element of the group with the following parameters:
+ *  - `key`: the key of a group this element belongs to;
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being accumulated.
+ *
+ * @return a [Map] associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <S, T : S, K> Grouping<T, K>.reduce(
+        operation: (key: K, accumulator: S, element: T) -> S
+): Map<K, S> =
+        aggregate { key, value, e, first ->
+            if (first) e else operation(key, value as S, e)
+        }
+
+/**
+ * Groups elements from the [Grouping] source by key and accumulates elements of each group with the specified [operation]
+ * starting the first element in that group to the given [destination] map.
+ *
+ * If the [destination] map already has a value corresponding to the key of some group,
+ * that value is used as an initial value of the accumulator for that group and the first element of that group is also
+ * subjected to the [operation].
+
+ * @param operation a function that is invoked on each subsequent element of the group with the following parameters:
+ *  - `accumulator`: the current value of the accumulator of the group;
+ *  - `element`: the element from the source being folded;
+ *
+ * @return the [destination] map associating the key of each group with the result of accumulating the group elements.
+ */
+@SinceKotlin(""1.1"")
+public inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(
+        destination: M,
+        operation: (key: K, accumulator: S, element: T) -> S
+): M =
+        aggregateTo(destination) { key, value, e, first ->
+            if (first) e else operation(key, value as S, e)
+        }
+
+
+/**
+ * Groups elements from the [Grouping] source by key and counts elements in each group.
+ *
+ * @return a [Map] associating the key of each group with the count of element in the group.
+ */
+@SinceKotlin(""1.1"")
+@JvmVersion
+public fun <T, K> Grouping<T, K>.eachCount(): Map<K, Int> =
+        // fold(0) { acc, e -> acc + 1 } optimized for boxing
+        fold(
+                initialValueSelector = { k, e -> kotlin.jvm.internal.Ref.IntRef() },
+                operation = { k, acc, e -> acc.apply { element += 1 } })
+        .mapValues { it.value.element }
+
+/**
+ * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.
+ *
+ * @return the [destination] map associating the key of each group with the count of element in the group.
+ */
+@SinceKotlin(""1.1"")
+public fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =
+        foldTo(destination, 0) { acc, e -> acc + 1 }
+
+/**
+ * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group.
+ *
+ * @return a [Map] associating the key of each group with the count of element in the group.
+ */
+@SinceKotlin(""1.1"")
+@JvmVersion
+public inline fun <T, K> Grouping<T, K>.eachSumOf(valueSelector: (T) -> Int): Map<K, Int> =
+        // fold(0) { acc, e -> acc + valueSelector(e)} optimized for boxing
+        fold(
+                initialValueSelector = { k, e -> kotlin.jvm.internal.Ref.IntRef() },
+                operation = { k, acc, e -> acc.apply { element += valueSelector(e) } })
+        .mapValues { it.value.element }",as we already use internal API hack we could do even more: we can create replace `IntRef` to `Int` inplace and then do unchecked cast.,I'm not sure if this is the right way to do it. I think
237,"@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.descriptors.PropertyDescriptor
+import org.jetbrains.kotlin.load.java.components.JavaPropertyInitializerEvaluator
+import org.jetbrains.kotlin.load.java.structure.JavaField
+
+class JavacJavaPropertyInitializerEvaluator : JavaPropertyInitializerEvaluator {",There is already `JavaPropertyInitializerEvaluator.DO_NOTHING` with the same functionality,I don't think we need this class.
238,"@@ -0,0 +1,282 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:","|`line 32`|
|---|
""a group"" -> ""the group"" here and below",I think it would be good to mention that `keySelector` 
239,"@@ -0,0 +1,282 @@
+package kotlin.collections
+
+/**
+ * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.
+ *
+ * A [Grouping] structure serves as an intermediate step in group-and-fold operations:
+ * they group elements by their keys and then fold each group with some aggregating operation.
+ *
+ * It is created by attaching `keySelector: (T) -> K` function to a source of elements.
+ * To get an instance of [Grouping] use one of `groupingBy` extension functions:
+ * - [Iterable.groupingBy]
+ * - [Sequence.groupingBy]","|`line 61`|
|---|
Any chance for some `@sample`'s?",I think it would be good to mention that `keySelector` 
240,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {",Why not simply `at.getNonStrictParentOfType<KtStringTemplateExpression>`()?,I don't think you need this import.
241,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)","I think that it's better to create a single `StringBuilder` to hold the entire preprocessed contents, and to use the overload of `escapeStringCharacters` that takes a `StringBuilder` as a parameter.",I don't think you need this import.
242,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+",Please reformat the files to remove unnecessary blank lines.,I don't think you need this import.
243,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+
+    }
+
+
+}
+
+private sealed class TemplateChunk
+private data class LiteralChunk(val text: String) : TemplateChunk()
+private data class EntryChunk(val text: String) : TemplateChunk()
+private class NewLineChunk : TemplateChunk()",Can be `object NewLineChunk`,I don't think you need this import.
244,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+
+    }
+
+
+}
+
+private sealed class TemplateChunk
+private data class LiteralChunk(val text: String) : TemplateChunk()
+private data class EntryChunk(val text: String) : TemplateChunk()
+private class NewLineChunk : TemplateChunk()
+
+private class TemplateTokenizer(private val inputString: String) : Sequence<TemplateChunk> {","I think this naming is kind of confusing; a tokenizer is something that returns a sequence, not something that is a sequence. I'd call it `TemplateTokenSequence`",I don't think you need this import.
245,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+
+    }
+
+
+}
+
+private sealed class TemplateChunk
+private data class LiteralChunk(val text: String) : TemplateChunk()
+private data class EntryChunk(val text: String) : TemplateChunk()
+private class NewLineChunk : TemplateChunk()
+
+private class TemplateTokenizer(private val inputString: String) : Sequence<TemplateChunk> {
+
+    private fun String.guessIsTemplateEntryStart(): Boolean =
+            if (this.startsWith(""\${"")) {
+                true
+            }
+            else if (this.length > 1 && this[0] == '$'){
+                KotlinLexer().apply { start(this@guessIsTemplateEntryStart.substring(1)) }.tokenType == KtTokens.IDENTIFIER",Better to declare the result of `substring` as a variable outside of the `apply` block.,I don't think you need this import.
246,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+
+    }
+
+
+}
+
+private sealed class TemplateChunk
+private data class LiteralChunk(val text: String) : TemplateChunk()
+private data class EntryChunk(val text: String) : TemplateChunk()
+private class NewLineChunk : TemplateChunk()
+
+private class TemplateTokenizer(private val inputString: String) : Sequence<TemplateChunk> {
+
+    private fun String.guessIsTemplateEntryStart(): Boolean =
+            if (this.startsWith(""\${"")) {
+                true
+            }
+            else if (this.length > 1 && this[0] == '$'){
+                KotlinLexer().apply { start(this@guessIsTemplateEntryStart.substring(1)) }.tokenType == KtTokens.IDENTIFIER
+            }
+            else {
+                false
+            }
+
+    private fun findTemplateEntryEnd(input: String, from: Int): Int{
+        val wrapped = '""' + input.substring(from) + '""'
+        val lexer = KotlinLexer().apply { start(wrapped) }.apply { advance() }
+
+        if (lexer.tokenType == KtTokens.SHORT_TEMPLATE_ENTRY_START){
+            lexer.advance()
+            return if (lexer.tokenType == KtTokens.IDENTIFIER){
+                from + lexer.tokenEnd -1
+            } else{
+                -1
+            }
+        }
+        else if(lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+            var depth = 0
+            while (lexer.tokenType != null) {
+                if (lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    depth++
+                }
+                else if (lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_END) {
+                    depth--
+                    if (depth == 0) {
+                        return from + lexer.currentPosition.offset - 1
+                    }
+                }
+                lexer.advance()
+            }
+            return -1
+        }
+        else {
+            return -1
+        }
+    }
+
+    private suspend fun SequenceBuilder<TemplateChunk>.yieldLiteral(chunk: String) {
+
+            val splitLines = LineTokenizer.tokenize(chunk, false, true)
+            for (i in 0..splitLines.size - 1) {
+                if (i != 0) {
+                    yield(NewLineChunk())
+                }
+                splitLines[i].takeIf { !it.isEmpty() }?.let { yield(LiteralChunk(it)) }
+            }
+
+    }
+
+    private fun iterTemplateChunks(): Iterator<TemplateChunk> {
+        if (inputString.isEmpty()) {
+            return emptySequence<TemplateChunk>().iterator()
+        }
+        return buildIterator {
+            var from = 0
+            var to = 0
+            while (to < inputString.length) {
+                val c = inputString[to]
+                if (c == '\\') {
+                    to += 1
+                    if (to < inputString.length)
+                        to += 1",I think this assumes that all escapes are single-character? That's not true; there are also `\uxxxx` escape sequences.,I don't think you need this import.
247,"@@ -0,0 +1,285 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor
+
+import com.intellij.codeInsight.editorActions.CopyPastePreProcessor
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.editor.RawText
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.openapi.util.text.LineTokenizer
+import com.intellij.openapi.util.text.StringUtil
+import com.intellij.psi.PsiDocumentManager
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.editor.fixers.range
+import org.jetbrains.kotlin.lexer.KotlinLexer
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtEscapeStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtStringTemplateEntry
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.isSingleQuoted
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import kotlin.coroutines.experimental.SequenceBuilder
+import kotlin.coroutines.experimental.buildIterator
+
+private fun PsiElement.findContainingTemplate(): PsiElement {
+    val parent = this.parent
+    @Suppress(""IfThenToElvis"")
+    return if (parent is KtStringTemplateEntry) parent.parent else parent
+}
+
+private fun PsiFile.getTemplateIfAtLiteral(offset: Int): KtStringTemplateExpression? {
+    val at = this.findElementAt(offset) ?: return null
+    return when (at.node?.elementType) {
+        KtTokens.REGULAR_STRING_PART, KtTokens.ESCAPE_SEQUENCE, KtTokens.LONG_TEMPLATE_ENTRY_START, KtTokens.SHORT_TEMPLATE_ENTRY_START -> at.parent.parent as? KtStringTemplateExpression
+        KtTokens.CLOSING_QUOTE -> if (offset == at.startOffset) at.parent as? KtStringTemplateExpression else null
+        else -> null
+
+    }
+}
+
+
+//Copied from StringLiteralCopyPasteProcessor to avoid erroneous inheritance
+private fun deduceBlockSelectionWidth(startOffsets: IntArray, endOffsets: IntArray, text: String): Int {
+    val fragmentCount = startOffsets.size
+    assert(fragmentCount > 0)
+    var totalLength = fragmentCount - 1 // number of line breaks inserted between fragments
+    for (i in 0..fragmentCount - 1) {
+        totalLength += endOffsets[i] - startOffsets[i]
+    }
+    if (totalLength < text.length && (text.length + 1) % fragmentCount == 0) {
+        return (text.length + 1) / fragmentCount - 1
+    }
+    else {
+        return -1
+    }
+}
+
+class KotlinLiteralCopyPasteProcessor : CopyPastePreProcessor {
+    override fun preprocessOnCopy(file: PsiFile, startOffsets: IntArray, endOffsets: IntArray, text: String): String? {
+        if (file !is KtFile){
+            return null
+        }
+        val buffer = StringBuilder()
+        var changed = false
+        val fileText = file.text
+        val deducedBlockSelectionWidth = deduceBlockSelectionWidth(startOffsets, endOffsets, text)
+
+        for (i in startOffsets.indices) {
+            if (i > 0) {
+                buffer.append('\n') // LF is added for block selection
+            }
+
+            val fileRange = TextRange(startOffsets[i], endOffsets[i])
+
+            var givenTextOffset = fileRange.startOffset
+            while (givenTextOffset < fileRange.endOffset) {
+                val element: PsiElement? = file.findElementAt(givenTextOffset)
+                if (element == null) {
+                    buffer.append(fileText.substring(givenTextOffset, fileRange.endOffset))
+                    break
+                }
+                val elTp = element.node.elementType
+                if (elTp == KtTokens.ESCAPE_SEQUENCE && fileRange.contains(element.range) && !fileRange.contains(element.findContainingTemplate().range)) {
+                    val tpEntry = element.parent as KtEscapeStringTemplateEntry
+                    changed = true
+                    buffer.append(tpEntry.unescapedValue)
+                    givenTextOffset = element.endOffset
+                }
+                else if (elTp == KtTokens.SHORT_TEMPLATE_ENTRY_START || elTp == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    //Process inner templates without escaping
+                    val tpEntry = element.parent
+                    val inter = fileRange.intersection(tpEntry.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+                else {
+                    val inter = fileRange.intersection(element.range)!!
+                    buffer.append(fileText.substring(inter.startOffset, inter.endOffset))
+                    givenTextOffset = inter.endOffset
+                }
+
+            }
+            val blockSelectionPadding = deducedBlockSelectionWidth - fileRange.length
+            for (j in 0..blockSelectionPadding - 1) {
+                buffer.append(' ')
+            }
+
+        }
+
+        return if (changed) buffer.toString() else null
+    }
+
+    override fun preprocessOnPaste(project: Project, file: PsiFile, editor: Editor, text: String, rawText: RawText?): String {
+        if (file !is KtFile){
+            return text
+        }
+        PsiDocumentManager.getInstance(project).commitDocument(editor.document)
+        val selectionModel = editor.selectionModel
+        val beginTp = file.getTemplateIfAtLiteral(selectionModel.selectionStart) ?: return text
+        val endTp = file.getTemplateIfAtLiteral(selectionModel.selectionEnd) ?: return text
+        if (beginTp.isSingleQuoted() != endTp.isSingleQuoted()) {
+            return text
+        }
+
+
+        return if (beginTp.isSingleQuoted()) {
+            TemplateTokenizer(text).map {
+                when (it) {
+                    is LiteralChunk -> StringUtil.escaper(true, ""\$\"""").`fun`(it.text)
+                    is EntryChunk -> it.text
+                    is NewLineChunk -> ""\\n\""+\n \""""
+
+                }
+            }.joinToString(separator = """")
+        }
+        else {
+            val tripleQuoteRe = Regex(""[\""]{3,}"")
+            TemplateTokenizer(text).map { chunk ->
+                when (chunk) {
+                    is LiteralChunk -> chunk.text.replace(""\$"", ""\${'$'}"").let { escapedDollar ->
+                        tripleQuoteRe.replace(escapedDollar) { ""\""\"""" + ""\${'\""'}"".repeat(it.value.count() - 2) }
+                    }
+
+                    is EntryChunk -> chunk.text
+                    is NewLineChunk -> ""\n""
+
+                }
+            }.joinToString(separator = """")
+        }
+
+    }
+
+
+}
+
+private sealed class TemplateChunk
+private data class LiteralChunk(val text: String) : TemplateChunk()
+private data class EntryChunk(val text: String) : TemplateChunk()
+private class NewLineChunk : TemplateChunk()
+
+private class TemplateTokenizer(private val inputString: String) : Sequence<TemplateChunk> {
+
+    private fun String.guessIsTemplateEntryStart(): Boolean =
+            if (this.startsWith(""\${"")) {
+                true
+            }
+            else if (this.length > 1 && this[0] == '$'){
+                KotlinLexer().apply { start(this@guessIsTemplateEntryStart.substring(1)) }.tokenType == KtTokens.IDENTIFIER
+            }
+            else {
+                false
+            }
+
+    private fun findTemplateEntryEnd(input: String, from: Int): Int{
+        val wrapped = '""' + input.substring(from) + '""'
+        val lexer = KotlinLexer().apply { start(wrapped) }.apply { advance() }
+
+        if (lexer.tokenType == KtTokens.SHORT_TEMPLATE_ENTRY_START){
+            lexer.advance()
+            return if (lexer.tokenType == KtTokens.IDENTIFIER){
+                from + lexer.tokenEnd -1
+            } else{
+                -1
+            }
+        }
+        else if(lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+            var depth = 0
+            while (lexer.tokenType != null) {
+                if (lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_START) {
+                    depth++
+                }
+                else if (lexer.tokenType == KtTokens.LONG_TEMPLATE_ENTRY_END) {
+                    depth--
+                    if (depth == 0) {
+                        return from + lexer.currentPosition.offset - 1
+                    }
+                }
+                lexer.advance()
+            }
+            return -1
+        }
+        else {
+            return -1
+        }
+    }
+
+    private suspend fun SequenceBuilder<TemplateChunk>.yieldLiteral(chunk: String) {
+
+            val splitLines = LineTokenizer.tokenize(chunk, false, true)
+            for (i in 0..splitLines.size - 1) {
+                if (i != 0) {
+                    yield(NewLineChunk())
+                }
+                splitLines[i].takeIf { !it.isEmpty() }?.let { yield(LiteralChunk(it)) }
+            }
+
+    }
+
+    private fun iterTemplateChunks(): Iterator<TemplateChunk> {
+        if (inputString.isEmpty()) {
+            return emptySequence<TemplateChunk>().iterator()
+        }
+        return buildIterator {
+            var from = 0
+            var to = 0
+            while (to < inputString.length) {
+                val c = inputString[to]
+                if (c == '\\') {
+                    to += 1
+                    if (to < inputString.length)
+                        to += 1
+                    continue
+
+                }
+                when (c) {",No reason to use `when` here; `if` would be cleaner.,I don't think you need this import.
248,"@@ -0,0 +1,3 @@
+// INTENTION_TEXT: ""Convert to sealed class""","Since you aren't changing the intention text dynamically, there's no need to include INTENTION_TEXT in testdata files.",// INTENTION_TEXT:
249,"@@ -0,0 +1,3 @@
+<spot>@JvmStatic</spot>","The template shows a top-level method, not a method inside an `object`. Please update it to show what the intention action actually does.",
250,"@@ -0,0 +1,3 @@
+[3]
+
+[3, 5]","Please update this file to be exactly the result of your intention on `before.kt.template`. Also you can use `<spot>` tag to highlight the place where the user should put his attention
",
251,"@@ -0,0 +1,3 @@
+for ((i,x) in foo.withIndices()) {","Please add a whitespace after the comma
",
252,"@@ -0,0 +1,3 @@
+fun foo(a: String?, b: String?) {
+    a?.equals(b) ?: b.identityEquals(null)
+}","Please, add test for the case of non-nullable receiver
",
253,"@@ -0,0 +1,3 @@
+fun foo(x: Boolean) : Boolean {
+    return x || x || x","This behavior is objectionable: order of predicates evaluation can change program behavior, when evaluated expressions have side effects. I'll disable intention in this case.
",
254,"@@ -0,0 +1,30 @@
+/*","Consider merging small and relevant declarations together into one file, e.g. `JavaType` implementations into `symbolBasedTypes.kt`, `JavaAnnotationArgument` implementations into `symbolBasedAnnotationArguments.kt` and so on. I think it'd be more readable in the end",Why is this needed?
255,"@@ -0,0 +1,30 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaEnumValueAnnotationArgument
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.element.VariableElement
+
+class JavacReferenceAnnotationArgument(val element: VariableElement,
+                                       javac: Javac) : JavacAnnotationArgument(FqName(element.simpleName.toString()), javac),
+        JavaEnumValueAnnotationArgument {
+
+    override fun resolve() = JavacField(element, javac)","In NB plugin you're using containing class at this point, but here you aren't. Are you sure it's not a mistake?",I think it would be better to use `
256,"@@ -0,0 +1,30 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationAsAnnotationArgument
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.AnnotationMirror
+
+class SymbolBasedAnnotationAsAnnotationArgument(val mirror: AnnotationMirror,","I'd assume that all `SymbolBased*AnnotationArgument`s are subclasses of `SymbolBasedAnnotationArgument`, but only one of them is (`SymbolBasedReferenceAnnotationArgument`). I suggest either inheriting all of them from `SymbolBasedAnnotationArgument`, or getting rid of the latter altogether",I think we can remove this class. It's not used anywhere.
257,"@@ -0,0 +1,30 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaArrayType
+import javax.lang.model.type.ArrayType
+import javax.lang.model.type.TypeMirror
+
+class SymbolBasedArrayType<out T : TypeMirror>(typeMirror: T,","Instead of generic type parameter, inherit from `SymbolBasedType<ArrayType>`, cast `typeMirror` to `ArrayType` once at creation site",Why do we need this class?
258,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.","""in the runtime"" -> ""at runtime""?
   ""   ""?
",I'm not sure if this is the best way to do this.
259,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`","""coercible"" usually assumes some transformation of the value representation to fit to a new type. If it's exactly the same object, just viewed as an instance of a new type, then maybe it would be better to say ""implicitly convertible"" or ""assignable""?
",I'm not sure if this is the best way to do this.
260,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.","I do not get the meaning of ""overriding `invoke` only would be the best"".
",I'm not sure if this is the best way to do this. I'm not 
261,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.
+Enabling SAM conversions on Java 8 would also be terrific.
+
+## Brief solution overview
+
+* Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.
+* Introduce a physical class `Function` and unlimited number of *fictitious* (synthetic) classes `Function0`, `Function1`, ... in the compiler front-end
+* On JVM, introduce `Function0`..`Function22`, which are optimized in a certain way,
+and `FunctionN` for functions with 23+ parameters.
+When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.
+* Also on JVM (under the hood) add abstract `FunctionImpl` which implements all of `Fun0`..`Fun22` and `FunN`","What is `Fun0`?
",I don't think this is the right place to put this. I thin
262,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.
+Enabling SAM conversions on Java 8 would also be terrific.
+
+## Brief solution overview
+
+* Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.
+* Introduce a physical class `Function` and unlimited number of *fictitious* (synthetic) classes `Function0`, `Function1`, ... in the compiler front-end
+* On JVM, introduce `Function0`..`Function22`, which are optimized in a certain way,
+and `FunctionN` for functions with 23+ parameters.
+When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.
+* Also on JVM (under the hood) add abstract `FunctionImpl` which implements all of `Fun0`..`Fun22` and `FunN`
+(throwing exceptions), and which knows its arity.
+Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.
+* Provide a way to get arity of an arbitrary `Function` object (pretty straightforward).
+* Hack `is/as Function5` on any numbered function in codegen (and probably `KClass.cast()` in reflection) to check against `Function` and its arity.","So, is it `Function` or `FunctionImpl` who knows the function arity? For which type are we going to check in `is` operator?
",I don't think we need to mention `KClass` here.
263,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.
+Enabling SAM conversions on Java 8 would also be terrific.
+
+## Brief solution overview
+
+* Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.
+* Introduce a physical class `Function` and unlimited number of *fictitious* (synthetic) classes `Function0`, `Function1`, ... in the compiler front-end
+* On JVM, introduce `Function0`..`Function22`, which are optimized in a certain way,
+and `FunctionN` for functions with 23+ parameters.
+When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.
+* Also on JVM (under the hood) add abstract `FunctionImpl` which implements all of `Fun0`..`Fun22` and `FunN`
+(throwing exceptions), and which knows its arity.
+Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.
+* Provide a way to get arity of an arbitrary `Function` object (pretty straightforward).
+* Hack `is/as Function5` on any numbered function in codegen (and probably `KClass.cast()` in reflection) to check against `Function` and its arity.
+
+## Extension functions
+
+Extension function type `T.(P) -> R` is now just a shorthand for `@kotlin.extension Function2<T, P, R>`.
+`kotlin.extension` is a **type annotation** defined in built-ins.
+So effectively functions and extension functions now have the same type,
+which means that everything which takes a function will work with an extension function and vice versa.
+
+To prevent unpleasant ambiguities, we introduce additional restrictions:
+* A value of an extension function type cannot be **called** as a function, and a value of a non-extension
+function type cannot be called as an extension. This requires an additional diagnostic which is only fired
+when a call is resolved to the `invoke` with the wrong extension-ness.
+* If an extension function **literal** argument has some shape (its parameters are written out explicitly
+in the code and it's evident that there is or there isn't a receiver parameter), this shape must exactly match","What could make it evident that there is or there isn't a receiver parameter?
",I don't think we need to mention `KClass.cast()` here.
264,"@@ -0,0 +1,304 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. One of the problems with them is that they should be effectively duplicated in reflection which means a lot of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter), so that it's possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.
+Enabling SAM conversions on Java 8 would also be terrific.
+
+## Brief solution overview
+
+* Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.
+* Introduce a physical class `Function` and unlimited number of *fictitious* (synthetic) classes `Function0`, `Function1`, ... in the compiler front-end
+* On JVM, introduce `Function0`..`Function22`, which are optimized in a certain way,
+and `FunctionN` for functions with 23+ parameters.
+When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.
+* Also on JVM (under the hood) add abstract `FunctionImpl` which implements all of `Fun0`..`Fun22` and `FunN`
+(throwing exceptions), and which knows its arity.
+Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.
+* Provide a way to get arity of an arbitrary `Function` object (pretty straightforward).
+* Hack `is/as Function5` on any numbered function in codegen (and probably `KClass.cast()` in reflection) to check against `Function` and its arity.
+
+## Extension functions
+
+Extension function type `T.(P) -> R` is now just a shorthand for `@kotlin.extension Function2<T, P, R>`.
+`kotlin.extension` is a **type annotation** defined in built-ins.
+So effectively functions and extension functions now have the same type,
+which means that everything which takes a function will work with an extension function and vice versa.
+
+To prevent unpleasant ambiguities, we introduce additional restrictions:
+* A value of an extension function type cannot be **called** as a function, and a value of a non-extension
+function type cannot be called as an extension. This requires an additional diagnostic which is only fired
+when a call is resolved to the `invoke` with the wrong extension-ness.
+* If an extension function **literal** argument has some shape (its parameters are written out explicitly
+in the code and it's evident that there is or there isn't a receiver parameter), this shape must exactly match
+the extension-ness of the corresponding parameter. You can't pass an extension function **literal**
+where a function is expected and vice versa. The same holds for function expressions.
+If you really want to do that, change the shape or use the `as` operator.
+
+So basically you can now safely coerce values between function and extension function types,
+but still should invoke them in the format which you specified in their type (with or without `@extension`).
+
+With this we'll get rid of classes `ExtensionFunction0`, `ExtensionFunction1`, ...
+and the rest of this article will deal only with usual functions.
+
+## Function0, Function1, ... types
+
+The arity of the functional interface that the type checker can create in theory **is not limited** to any number,
+but in practice should be limited to 255 on JVM.
+
+These interfaces are named `kotlin.Function0<R>`, `kotlin.Function1<P0, R>`, ..., `kotlin.Function42<P0, P1, ..., P41, R>`, ...
+They are *fictitious*, which means they have no sources and no runtime representation.
+Type checker creates the corresponding descriptors on demand, IDE creates corresponding source files on demand as well.
+Each of them inherits from `kotlin.Function` (described below) and contains only two functions,
+both of which should be synthetically produced by the compiler:
+* (declaration) `invoke` with no receiver, with the corresponding number of parameters and return type.
+* (synthesized) `invoke` with first type parameter as the extension receiver type, and the rest as parameters and return type.","""first type parameter""? Are you talking about `<T, ...>`?
",I don't think we need to mention `KClass.cast()` here.
265,"@@ -0,0 +1,31 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.builtins.PrimitiveType
+import org.jetbrains.kotlin.load.java.structure.JavaPrimitiveType
+import org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType
+import javax.lang.model.type.TypeMirror
+
+class JavacPrimitiveType<out T : TypeMirror>(typeMirror: T,
+                                             javac: Javac) : JavacType<T>(typeMirror, javac), JavaPrimitiveType {
+
+    override val type: PrimitiveType?
+        get() = if (""void"" == typeMirror.toString()) null else JvmPrimitiveType.get(typeMirror.toString()).primitiveType",You can extract `typeMirror.toString()`,I'm not sure if this is the right place to put this class
266,"@@ -0,0 +1,31 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationArgument
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.name.FqName
+
+open class TreeBasedAnnotationArgument(val tree: JCTree.JCExpression,
+                                       fqName: FqName,",`Name` should be enough here as well,I don't think we need the `open` keyword.
267,"@@ -0,0 +1,313 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.reflect.KMutableProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+public val COMPILE_DAEMON_TIMEOUT_INFINITE_S: Int = 0
+public val COMPILE_DAEMON_MEMORY_THRESHOLD_INFINITE: Long = 0L
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+//open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+//                                                    val prop: P,
+//                                                    val name: String,
+//                                                    val convert: ((v: V) -> String?) = { it.toString() },
+//                                                    val skipIf: ((v: V) -> Boolean) = { false },
+//                                                    val mergeWithDelimiter: String? = null)
+//{
+//    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+//    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+//            when {
+//                skipIf(prop.get(dest)) -> listOf<String>()
+//                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+//                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+//            }
+//}
+//
+//class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+//    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+//
+//class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+//    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+//}
+//
+//
+//open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+//                                                        val prop: P, alternativeNames: List<String>,
+//                                                        val parse: (s: String) -> V,
+//                                                        val allowMergedArg: Boolean = false) {
+//    val names = listOf(prop.name) + alternativeNames
+//    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+//    fun apply(s: String) = prop.set(dest, parse(s))
+//}
+//
+//class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+//
+//class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+//    fun add(s: String) { prop.get(dest).add(s) }
+//}","let's drop it
",How about `kotlin.rmi.service.CompileDaemon`?
268,"@@ -0,0 +1,313 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.reflect.KMutableProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+public val COMPILE_DAEMON_TIMEOUT_INFINITE_S: Int = 0
+public val COMPILE_DAEMON_MEMORY_THRESHOLD_INFINITE: Long = 0L
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+//open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+//                                                    val prop: P,
+//                                                    val name: String,
+//                                                    val convert: ((v: V) -> String?) = { it.toString() },
+//                                                    val skipIf: ((v: V) -> Boolean) = { false },
+//                                                    val mergeWithDelimiter: String? = null)
+//{
+//    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+//    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+//            when {
+//                skipIf(prop.get(dest)) -> listOf<String>()
+//                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+//                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+//            }
+//}
+//
+//class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+//    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+//
+//class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+//    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+//}
+//
+//
+//open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+//                                                        val prop: P, alternativeNames: List<String>,
+//                                                        val parse: (s: String) -> V,
+//                                                        val allowMergedArg: Boolean = false) {
+//    val names = listOf(prop.name) + alternativeNames
+//    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+//    fun apply(s: String) = prop.set(dest, parse(s))
+//}
+//
+//class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+//
+//class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+//    fun add(s: String) { prop.get(dest).add(s) }
+//}
+
+// --------------------------------------------------------
+
+open class PropMapper<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P,
+                                                        val names: List<String> = listOf(prop.name),
+                                                        val fromString: (s: String) -> V,
+                                                        val toString: ((v: V) -> String?) = { it.toString() },
+                                                        val skipIf: ((v: V) -> Boolean) = { false },
+                                                        val mergeDelimiter: String? = null)
+{
+    open fun toArgs(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeDelimiter != null -> listOf(prefix + names.first() + mergeDelimiter + toString(prop.get(dest))).filterNotNull()","nothing to filter out by `filterNotNull` 
",How about `kotlin.rmi.service.CompileDaemon`?
269,"@@ -0,0 +1,313 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.File
+import java.io.Serializable
+import java.lang.management.ManagementFactory
+import java.security.DigestInputStream
+import java.security.MessageDigest
+import kotlin.reflect.KMutableProperty1
+
+
+public val COMPILER_JAR_NAME: String = ""kotlin-compiler.jar""
+public val COMPILER_SERVICE_RMI_NAME: String = ""KotlinJvmCompilerService""
+public val COMPILER_DAEMON_CLASS_FQN: String = ""org.jetbrains.kotlin.rmi.service.CompileDaemon""
+public val COMPILE_DAEMON_DEFAULT_PORT: Int = 17031
+public val COMPILE_DAEMON_ENABLED_PROPERTY: String =""kotlin.daemon.enabled""
+public val COMPILE_DAEMON_JVM_OPTIONS_PROPERTY: String =""kotlin.daemon.jvm.options""
+public val COMPILE_DAEMON_OPTIONS_PROPERTY: String =""kotlin.daemon.options""
+public val COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX: String =""--daemon-""
+public val COMPILE_DAEMON_TIMEOUT_INFINITE_S: Int = 0
+public val COMPILE_DAEMON_MEMORY_THRESHOLD_INFINITE: Long = 0L
+
+val COMPILER_ID_DIGEST = ""MD5""
+
+//open class PropExtractor<C, V, P: KProperty1<C, V>>(val dest: C,
+//                                                    val prop: P,
+//                                                    val name: String,
+//                                                    val convert: ((v: V) -> String?) = { it.toString() },
+//                                                    val skipIf: ((v: V) -> Boolean) = { false },
+//                                                    val mergeWithDelimiter: String? = null)
+//{
+//    constructor(dest: C, prop: P, convert: ((v: V) -> String?) = { it.toString() }, skipIf: ((v: V) -> Boolean) = { false }) : this(dest, prop, prop.name, convert, skipIf)
+//    open fun extract(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+//            when {
+//                skipIf(prop.get(dest)) -> listOf<String>()
+//                mergeWithDelimiter != null -> listOf(prefix + name + mergeWithDelimiter + convert(prop.get(dest))).filterNotNull()
+//                else -> listOf(prefix + name, convert(prop.get(dest))).filterNotNull()
+//            }
+//}
+//
+//class BoolPropExtractor<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, name: String? = null)
+//    : PropExtractor<C, Boolean, P>(dest, prop, name ?: prop.name, convert = { null }, skipIf = { !prop.get(dest) })
+//
+//class RestPropExtractor<C, P: KMutableProperty1<C, out MutableCollection<String>>>(dest: C, prop: P) : PropExtractor<C, MutableCollection<String>, P>(dest, prop, convert = { null }) {
+//    override fun extract(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+//}
+//
+//
+//open class PropParser<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+//                                                        val prop: P, alternativeNames: List<String>,
+//                                                        val parse: (s: String) -> V,
+//                                                        val allowMergedArg: Boolean = false) {
+//    val names = listOf(prop.name) + alternativeNames
+//    constructor(dest: C, prop: P, parse: (s: String) -> V, allowMergedArg: Boolean = false) : this(dest, prop, listOf(), parse, allowMergedArg)
+//    fun apply(s: String) = prop.set(dest, parse(s))
+//}
+//
+//class BoolPropParser<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P): PropParser<C, Boolean, P>(dest, prop, { true })
+//
+//class RestPropParser<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P): PropParser<C, MutableCollection<String>, P>(dest, prop, { arrayListOf() }) {
+//    fun add(s: String) { prop.get(dest).add(s) }
+//}
+
+// --------------------------------------------------------
+
+open class PropMapper<C, V, P: KMutableProperty1<C, V>>(val dest: C,
+                                                        val prop: P,
+                                                        val names: List<String> = listOf(prop.name),
+                                                        val fromString: (s: String) -> V,
+                                                        val toString: ((v: V) -> String?) = { it.toString() },
+                                                        val skipIf: ((v: V) -> Boolean) = { false },
+                                                        val mergeDelimiter: String? = null)
+{
+    open fun toArgs(prefix: String = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX): List<String> =
+            when {
+                skipIf(prop.get(dest)) -> listOf<String>()
+                mergeDelimiter != null -> listOf(prefix + names.first() + mergeDelimiter + toString(prop.get(dest))).filterNotNull()
+                else -> listOf(prefix + names.first(), toString(prop.get(dest))).filterNotNull()
+            }
+    fun apply(s: String) = prop.set(dest, fromString(s))
+}
+
+class StringPropMapper<C, P: KMutableProperty1<C, String>>(dest: C,
+                                                           prop: P,
+                                                           names: List<String> = listOf(),
+                                                           fromString: ((String) -> String) = { it },
+                                                           toString: ((String) -> String?) = { it.toString() },
+                                                           skipIf: ((String) -> Boolean) = { it.isEmpty() },
+                                                           mergeDelimiter: String? = null)
+: PropMapper<C, String, P>(dest = dest, prop = prop, names = if (names.any()) names else listOf(prop.name),
+                            fromString = fromString,  toString = toString, skipIf = skipIf, mergeDelimiter = mergeDelimiter)
+
+class BoolPropMapper<C, P: KMutableProperty1<C, Boolean>>(dest: C, prop: P, names: List<String> = listOf())
+    : PropMapper<C, Boolean, P>(dest = dest, prop = prop, names = if (names.any()) names else listOf(prop.name), 
+                                fromString = { true },  toString = { null }, skipIf = { !prop.get(dest) })
+
+class RestPropMapper<C, P: KMutableProperty1<C, MutableCollection<String>>>(dest: C, prop: P) 
+    : PropMapper<C, MutableCollection<String>, P>(dest = dest, prop = prop, toString = { null }, fromString = { arrayListOf() }) 
+{
+    override fun toArgs(prefix: String): List<String> = prop.get(dest).map { prefix + it }
+    fun add(s: String) { prop.get(dest).add(s) }
+}
+
+// ------------------------------------------
+
+fun Iterable<String>.filterExtractProps(propMappers: List<PropMapper<*,*,*>>, prefix: String, restParser: RestPropMapper<*,*>? = null) : Iterable<String>  {","During the previous review I slightly rewrite this and something else, I hope this will be useful.
https://github.com/JetBrains/kotlin/commit/ef2ea84a85c3415fc9fa1c933e44c880df979d80#diff-4ff40116c0033e709c32c7abef5b2b0eR84
",How about `kotlin.rmi.service.CompileDaemon`?
270,"@@ -0,0 +1,32 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPrimitiveType
+import org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType
+import javax.lang.model.type.TypeMirror
+
+class SymbolBasedPrimitiveType<out T : TypeMirror>(typeMirror: T,",Drop generic type parameter here and inherit from `SymbolBasedType<*>`,I don't think we need the `out` parameter here.
271,"@@ -0,0 +1,32 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPrimitiveType
+import org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType
+import javax.lang.model.type.TypeMirror
+
+class SymbolBasedPrimitiveType<out T : TypeMirror>(typeMirror: T,
+                                                   javac: JavacWrapper) : SymbolBasedType<T>(typeMirror, javac), JavaPrimitiveType {
+
+    override val type
+        get() = with(typeMirror.toString()) {
+            if (""void"" == this) null else JvmPrimitiveType.get(this).primitiveType",Please inspect `TypeMirror.getKind` instead of `toString`,I'm not sure if this is the right way to do this. I think
272,"@@ -0,0 +1,32 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPrimitiveType
+import org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType
+
+class TreeBasedPrimitiveType<out T : JCTree.JCPrimitiveTypeTree>(tree: T,
+                                                                 treePath: TreePath,
+                                                                 javac: JavacWrapper) : TreeBasedType<T>(tree, treePath, javac), JavaPrimitiveType {
+
+    override val type
+        get() = if (""void"" == tree.toString()) null else JvmPrimitiveType.get(tree.toString()).primitiveType","Again, please inspect `tree.getKind()` instead of the string returned by `toString`",Can we use `TreePath.isVoid(tree)` instead?
273,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {","About functionality:
1. It's not good to give a user a partial functionality.
He would be surprised to find that the case 'super.foo()' is working, but 'super.foo().bar()' isn't.
2. I'd expect some choice which receiver I'd like to invoke here.
",Please don't use wildcard imports.
274,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {
+    private PsiElement elementToReplace;
+    private final LinkedHashSet<String> options;","It's better to use less concrete types like Set<String> or Collection<String> here. (The following code should be independent of concrete implementation of collection to make it easy to change it later if necessary).
",Please don't use wildcard imports.
275,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {
+    private PsiElement elementToReplace;
+    private final LinkedHashSet<String> options;
+
+
+    public SpecifySuperExplicitlyFix(@NotNull JetSuperExpression element, @NotNull LinkedHashSet<String> options) {
+        super(element);
+        elementToReplace = element;
+        this.options = options;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""specify.super.explicitly"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""specify.super.explicitly.family"");
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        return !options.isEmpty();
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) {","Don't override 'Deprecated' method.
",Please don't use wildcard imports.
276,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {
+    private PsiElement elementToReplace;
+    private final LinkedHashSet<String> options;
+
+
+    public SpecifySuperExplicitlyFix(@NotNull JetSuperExpression element, @NotNull LinkedHashSet<String> options) {
+        super(element);
+        elementToReplace = element;
+        this.options = options;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""specify.super.explicitly"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""specify.super.explicitly.family"");
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        return !options.isEmpty();
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) {
+        elementToReplace = elementToReplace.replace(JetPsiFactory.createExpression(project, options.iterator().next()));
+        buildAndShowTemplate(project, editor, file, elementToReplace, options);
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {","I'd rather divide this method into several smaller ones with meaningful names.
",Please don't use wildcard imports.
277,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {
+    private PsiElement elementToReplace;
+    private final LinkedHashSet<String> options;
+
+
+    public SpecifySuperExplicitlyFix(@NotNull JetSuperExpression element, @NotNull LinkedHashSet<String> options) {
+        super(element);
+        elementToReplace = element;
+        this.options = options;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""specify.super.explicitly"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""specify.super.explicitly.family"");
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        return !options.isEmpty();
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) {
+        elementToReplace = elementToReplace.replace(JetPsiFactory.createExpression(project, options.iterator().next()));
+        buildAndShowTemplate(project, editor, file, elementToReplace, options);
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetSuperExpression superExp = QuickFixUtil.getParentElementOfType(diagnostic, JetSuperExpression.class);
+                if (superExp == null) {
+                    return null;
+                }
+
+                JetClass klass = QuickFixUtil.getParentElementOfType(diagnostic, JetClass.class);
+                if (klass == null) {
+                    return null;
+                }
+
+                JetDelegationSpecifierList superClasses = PsiTreeUtil.getChildOfType(klass, JetDelegationSpecifierList.class);
+                if (superClasses == null) {
+                    return null;
+                }
+
+                //Used for checking visibility
+                BindingContext contextClasses = KotlinCacheManagerUtil.getDeclarationsFromProject(superExp).getBindingContext();
+                ClassDescriptor fromClass = contextClasses.get(BindingContext.CLASS, klass);
+                if (fromClass == null) {
+                    return null;
+                }
+
+                //Fetch class descriptors for all super classes
+                LinkedHashSet<ClassDescriptor> superClassDescs = new LinkedHashSet<ClassDescriptor>();
+                for (JetDelegationSpecifier delSpec : superClasses.getDelegationSpecifiers()) {
+                    JetSimpleNameExpression jetRef = PsiTreeUtil.findChildOfType(delSpec.getTypeReference(), JetSimpleNameExpression.class);
+                    if (jetRef == null) {
+                        continue;
+                    }
+                    ClassDescriptor classDesc = resolveToClass(jetRef, contextClasses);
+                    if (classDesc != null) {
+                        superClassDescs.add(classDesc);
+                    }
+                }
+                if (superClassDescs.isEmpty()) {
+                    return null;
+                }
+
+                //Get the name of the member in question and other access information. The super expression
+                //MUST be a part of a dot qualified expression.
+                JetDotQualifiedExpression dotExp = QuickFixUtil.getParentElementOfType(diagnostic, JetDotQualifiedExpression.class);
+                if (dotExp == null) {
+                    return null;
+                }
+                JetExpression nextExp = dotExp;
+                JetExpression currentExp = null;
+
+                ArrayList<String> memberNames = new ArrayList<String>();
+                //contains a null in the index where the memberName at that same index is of a property.
+                ArrayList<JetValueArgumentList> argsForFunction = new ArrayList<JetValueArgumentList>();
+                while (nextExp != null && (nextExp instanceof JetDotQualifiedExpression || nextExp instanceof JetArrayAccessExpression)) {
+                    currentExp = nextExp;
+                    String memberName;
+                    JetValueArgumentList valArgs;
+
+                    if (currentExp instanceof JetDotQualifiedExpression) {
+                        JetCallExpression call = PsiTreeUtil.getChildOfType(currentExp, JetCallExpression.class);
+                        if (call != null) {
+                            JetSimpleNameExpression name = PsiTreeUtil.getChildOfType(call, JetSimpleNameExpression.class);
+                            if (name == null) {
+                                return null;
+                            }
+                            memberName = name.getText();
+                            valArgs = call.getValueArgumentList();
+                        }
+                        else {
+                            JetSimpleNameExpression name = PsiTreeUtil.getChildOfType(currentExp, JetSimpleNameExpression.class);
+                            if (name == null) {
+                                return null;
+                            }
+                            memberName = name.getText();
+                            valArgs = null;
+                        }
+                    }
+                    else {
+                        //array indexing not supported for now.
+                        return null;
+                        /**
+                        memberName = ""get""; //array indexing is the same as get function call
+
+                        JetContainerNode indexNode =  ((JetArrayAccessExpression) currentExp).getIndicesNode();
+                        JetConstantExpression constant = PsiTreeUtil.getChildOfType(indexNode, JetConstantExpression.class);
+                        JetReferenceExpression refIndex = PsiTreeUtil.getChildOfType(indexNode, JetReferenceExpression.class);
+                        if (constant == null && refIndex == null) {
+                            return null;
+                        }
+                        if (constant != null) {
+                            valArgs = JetPsiFactory.createCallArguments(diagnostic.getPsiFile()
+                            .getProject(), ""("" + constant.getText() + "")"");
+                        }
+                        else {
+                            valArgs = JetPsiFactory.createCallArguments(diagnostic.getPsiFile()
+                            .getProject(), ""("" + refIndex.getText() + "")"");
+                        }**/
+                    }
+                    memberNames.add(memberName);
+                    argsForFunction.add(valArgs);
+                    nextExp = PsiTreeUtil.getParentOfType(currentExp, JetExpression.class);
+                }
+                if (memberNames.isEmpty()) {
+                    return null;
+                }
+
+                //Right now, code has unexpected behavior with chained calls e.g. super.foo().bar.baz() so we just return null.
+                if (memberNames.size() > 1) {
+                    return null;
+                }
+
+
+                //Get the expected type of the expression if applicable (e.g. var a : Int = super.foo)
+                BindingContext contextExpressions = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) diagnostic.getPsiFile())
+                        .getBindingContext();
+                JetProperty assignment = PsiTreeUtil.getParentOfType(currentExp, JetProperty.class);
+                JetType expectedJetType = null;
+                if (assignment != null) {
+                    expectedJetType = contextExpressions.get(BindingContext.TYPE, assignment.getTypeRef());
+                }
+                //TODO with Expected Type, if it is part of a return statement, look at return type of the function.
+
+                LinkedHashSet<String> options = new LinkedHashSet<String>();
+                for (ClassDescriptor classDesc : superClassDescs) {
+                    //ClassDescriptor currentClassDesc = classDesc;
+
+                    boolean failed = false;
+                    JetType returnType;
+                    //for (int i = 0; i < memberNames.size(); i++) {
+                                                            //should be currentClassDesc and .get(i)'s
+                        returnType = memberNameAndArgsFound(classDesc, fromClass, memberNames.get(0),
+                                                                    argsForFunction.get(0), contextExpressions);
+                        /*
+                        if (returnType == null) {
+                            failed = true;
+                            break;
+                        }
+                        //Update the class from which we see the next member.
+                        fromClass = currentClassDesc;
+                        TODO deal with generic types (especially in arrays) as the return type.
+                        currentClassDesc = DescriptorUtils.getClassDescriptorForType(returnType);
+                    }*/
+                    if (!failed && returnType != null &&
+                        (expectedJetType == null || JetTypeChecker.INSTANCE.isSubtypeOf(returnType, expectedJetType))) {
+                        options.add(""super<"" + classDesc.getName().getIdentifier() + "">"");
+                    }
+                }
+                return new SpecifySuperExplicitlyFix(superExp, options);
+            }
+        };
+    }
+
+    /*returns null if false or error occured*/
+    private static JetType memberNameAndArgsFound(@NotNull ClassDescriptor classDesc, @NotNull ClassDescriptor fromClass,","Please annotate return type as Nullable if a method may return null.
The method name should explain what this method does (better using some verbs like 'do something') and what it returns ('memberNameAndArgsFound' returning JetType is unclear).
",Please don't use wildcard imports.
278,"@@ -0,0 +1,334 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.codeInsight.template.*;
+import com.intellij.openapi.editor.CaretModel;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.util.PsiTreeUtil;
+import com.intellij.refactoring.rename.inplace.MyLookupExpression;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.descriptors.*;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.lang.resolve.BindingContext;
+import org.jetbrains.jet.lang.resolve.name.Name;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.lang.types.checker.JetTypeChecker;
+import org.jetbrains.jet.plugin.JetBundle;
+import org.jetbrains.jet.plugin.caches.resolve.KotlinCacheManagerUtil;
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class SpecifySuperExplicitlyFix extends JetIntentionAction<JetSuperExpression> {
+    private PsiElement elementToReplace;
+    private final LinkedHashSet<String> options;
+
+
+    public SpecifySuperExplicitlyFix(@NotNull JetSuperExpression element, @NotNull LinkedHashSet<String> options) {
+        super(element);
+        elementToReplace = element;
+        this.options = options;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""specify.super.explicitly"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""specify.super.explicitly.family"");
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        return !options.isEmpty();
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) {
+        elementToReplace = elementToReplace.replace(JetPsiFactory.createExpression(project, options.iterator().next()));
+        buildAndShowTemplate(project, editor, file, elementToReplace, options);
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetSuperExpression superExp = QuickFixUtil.getParentElementOfType(diagnostic, JetSuperExpression.class);
+                if (superExp == null) {
+                    return null;
+                }
+
+                JetClass klass = QuickFixUtil.getParentElementOfType(diagnostic, JetClass.class);
+                if (klass == null) {
+                    return null;
+                }
+
+                JetDelegationSpecifierList superClasses = PsiTreeUtil.getChildOfType(klass, JetDelegationSpecifierList.class);
+                if (superClasses == null) {
+                    return null;
+                }
+
+                //Used for checking visibility
+                BindingContext contextClasses = KotlinCacheManagerUtil.getDeclarationsFromProject(superExp).getBindingContext();
+                ClassDescriptor fromClass = contextClasses.get(BindingContext.CLASS, klass);
+                if (fromClass == null) {
+                    return null;
+                }
+
+                //Fetch class descriptors for all super classes
+                LinkedHashSet<ClassDescriptor> superClassDescs = new LinkedHashSet<ClassDescriptor>();
+                for (JetDelegationSpecifier delSpec : superClasses.getDelegationSpecifiers()) {
+                    JetSimpleNameExpression jetRef = PsiTreeUtil.findChildOfType(delSpec.getTypeReference(), JetSimpleNameExpression.class);
+                    if (jetRef == null) {
+                        continue;
+                    }
+                    ClassDescriptor classDesc = resolveToClass(jetRef, contextClasses);
+                    if (classDesc != null) {
+                        superClassDescs.add(classDesc);
+                    }
+                }
+                if (superClassDescs.isEmpty()) {
+                    return null;
+                }
+
+                //Get the name of the member in question and other access information. The super expression
+                //MUST be a part of a dot qualified expression.
+                JetDotQualifiedExpression dotExp = QuickFixUtil.getParentElementOfType(diagnostic, JetDotQualifiedExpression.class);
+                if (dotExp == null) {
+                    return null;
+                }
+                JetExpression nextExp = dotExp;
+                JetExpression currentExp = null;
+
+                ArrayList<String> memberNames = new ArrayList<String>();
+                //contains a null in the index where the memberName at that same index is of a property.
+                ArrayList<JetValueArgumentList> argsForFunction = new ArrayList<JetValueArgumentList>();
+                while (nextExp != null && (nextExp instanceof JetDotQualifiedExpression || nextExp instanceof JetArrayAccessExpression)) {
+                    currentExp = nextExp;
+                    String memberName;
+                    JetValueArgumentList valArgs;
+
+                    if (currentExp instanceof JetDotQualifiedExpression) {
+                        JetCallExpression call = PsiTreeUtil.getChildOfType(currentExp, JetCallExpression.class);
+                        if (call != null) {
+                            JetSimpleNameExpression name = PsiTreeUtil.getChildOfType(call, JetSimpleNameExpression.class);
+                            if (name == null) {
+                                return null;
+                            }
+                            memberName = name.getText();
+                            valArgs = call.getValueArgumentList();
+                        }
+                        else {
+                            JetSimpleNameExpression name = PsiTreeUtil.getChildOfType(currentExp, JetSimpleNameExpression.class);
+                            if (name == null) {
+                                return null;
+                            }
+                            memberName = name.getText();
+                            valArgs = null;
+                        }
+                    }
+                    else {
+                        //array indexing not supported for now.
+                        return null;
+                        /**
+                        memberName = ""get""; //array indexing is the same as get function call
+
+                        JetContainerNode indexNode =  ((JetArrayAccessExpression) currentExp).getIndicesNode();
+                        JetConstantExpression constant = PsiTreeUtil.getChildOfType(indexNode, JetConstantExpression.class);
+                        JetReferenceExpression refIndex = PsiTreeUtil.getChildOfType(indexNode, JetReferenceExpression.class);
+                        if (constant == null && refIndex == null) {
+                            return null;
+                        }
+                        if (constant != null) {
+                            valArgs = JetPsiFactory.createCallArguments(diagnostic.getPsiFile()
+                            .getProject(), ""("" + constant.getText() + "")"");
+                        }
+                        else {
+                            valArgs = JetPsiFactory.createCallArguments(diagnostic.getPsiFile()
+                            .getProject(), ""("" + refIndex.getText() + "")"");
+                        }**/
+                    }
+                    memberNames.add(memberName);
+                    argsForFunction.add(valArgs);
+                    nextExp = PsiTreeUtil.getParentOfType(currentExp, JetExpression.class);
+                }
+                if (memberNames.isEmpty()) {
+                    return null;
+                }
+
+                //Right now, code has unexpected behavior with chained calls e.g. super.foo().bar.baz() so we just return null.
+                if (memberNames.size() > 1) {
+                    return null;
+                }
+
+
+                //Get the expected type of the expression if applicable (e.g. var a : Int = super.foo)
+                BindingContext contextExpressions = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) diagnostic.getPsiFile())
+                        .getBindingContext();
+                JetProperty assignment = PsiTreeUtil.getParentOfType(currentExp, JetProperty.class);
+                JetType expectedJetType = null;
+                if (assignment != null) {
+                    expectedJetType = contextExpressions.get(BindingContext.TYPE, assignment.getTypeRef());
+                }
+                //TODO with Expected Type, if it is part of a return statement, look at return type of the function.
+
+                LinkedHashSet<String> options = new LinkedHashSet<String>();
+                for (ClassDescriptor classDesc : superClassDescs) {
+                    //ClassDescriptor currentClassDesc = classDesc;
+
+                    boolean failed = false;
+                    JetType returnType;
+                    //for (int i = 0; i < memberNames.size(); i++) {
+                                                            //should be currentClassDesc and .get(i)'s
+                        returnType = memberNameAndArgsFound(classDesc, fromClass, memberNames.get(0),
+                                                                    argsForFunction.get(0), contextExpressions);
+                        /*
+                        if (returnType == null) {
+                            failed = true;
+                            break;
+                        }
+                        //Update the class from which we see the next member.
+                        fromClass = currentClassDesc;
+                        TODO deal with generic types (especially in arrays) as the return type.
+                        currentClassDesc = DescriptorUtils.getClassDescriptorForType(returnType);
+                    }*/
+                    if (!failed && returnType != null &&
+                        (expectedJetType == null || JetTypeChecker.INSTANCE.isSubtypeOf(returnType, expectedJetType))) {
+                        options.add(""super<"" + classDesc.getName().getIdentifier() + "">"");
+                    }
+                }
+                return new SpecifySuperExplicitlyFix(superExp, options);
+            }
+        };
+    }
+
+    /*returns null if false or error occured*/
+    private static JetType memberNameAndArgsFound(@NotNull ClassDescriptor classDesc, @NotNull ClassDescriptor fromClass,
+            @NotNull String memberName,
+            @Nullable JetValueArgumentList valArgs, @NotNull BindingContext contextExpressions) {
+        if (valArgs == null) {
+            Collection<VariableDescriptor> varDescs = classDesc.getMemberScope(classDesc.getDefaultType().getArguments())
+                    .getProperties(Name.identifier(memberName));
+            return memberNamePropFound(classDesc, fromClass, varDescs);
+        }
+        else {
+            Collection<FunctionDescriptor> funDescs = classDesc.getMemberScope(classDesc.getDefaultType().getArguments())
+                    .getFunctions(Name.identifier(memberName));
+            return memberNameFuncFound(fromClass, funDescs, valArgs, contextExpressions);
+
+        }
+    }
+
+    private static JetType memberNameFuncFound(@NotNull ClassDescriptor fromClass,
+            @NotNull Collection<FunctionDescriptor> funDescs,
+            @NotNull JetValueArgumentList valArgs, @NotNull BindingContext contextExpressions) {
+        for (FunctionDescriptor fun : funDescs) {
+            if (fun.getModality() == Modality.ABSTRACT || !fun.getKind().isReal() ||
+                    !Visibilities.isVisible(fun, fromClass)) {
+                continue;
+            }
+            List<ValueParameterDescriptor> valParams = fun.getValueParameters();
+            List<JetValueArgument> jValArgs = valArgs.getArguments();
+            if (jValArgs.size() != valParams.size()) {
+                continue;
+            }
+            boolean argTypesMatch = true;
+            for (int j = 0; j < valParams.size(); j++) {
+                JetExpression expr = jValArgs.get(j).getArgumentExpression();
+                JetType subtype = contextExpressions.get(BindingContext.EXPRESSION_TYPE, expr);
+                if (subtype == null || !JetTypeChecker.INSTANCE.isSubtypeOf(subtype, valParams.get(j).getType())) {
+                    argTypesMatch = false;
+                    break;
+                }
+            }
+            if (!argTypesMatch) {
+                continue;
+            }
+            return fun.getReturnType();
+        }
+        return null;
+    }
+
+    private static JetType memberNamePropFound(@NotNull ClassDescriptor classDesc, @NotNull ClassDescriptor fromClass,
+            @NotNull Collection<VariableDescriptor> varDescs) {
+        for (VariableDescriptor var : varDescs) {
+            if (classDesc.getKind() != ClassKind.TRAIT && Visibilities.isVisible(var, fromClass)) {
+                return var.getType();
+            }
+        }
+        return null;
+    }
+
+    /*Taken and modified from MapPlatformClassToKotlinFix*/","You shouldn't copy code. You may change this method in its class or/and move it to util instead.
",Please don't use wildcard imports.
279,"@@ -0,0 +1,34 @@
+# Class Literals as Annotation Arguments
+
+Prior to M12 Kotlin annotation allowed parameters of type `java.lang.Class<...>` whose values could be of the form `javaClass<...>()`. 
+Since M12 both these options are deprecated, and subject to deletion in further milestones.
+
+## Annotation Parameters
+
+Annotation parameters of type `java.lang.Class<T>` are deprecated.
+
+Annotation parameters of type `kotlin.reflect.KClass<T>` are supported.
+
+A quick-fix transforming one into the other is provided.
+
+## Annotation Arguments
+
+Arguments of the form `javaClass<T>()` are deprecated.
+
+Arguments of teh form `ClassName::class` are supported.","teh -> the
","""teh form"" -> ""the form"""
280,"@@ -0,0 +1,34 @@
+# Class Literals as Annotation Arguments
+
+Prior to M12 Kotlin annotation allowed parameters of type `java.lang.Class<...>` whose values could be of the form `javaClass<...>()`. 
+Since M12 both these options are deprecated, and subject to deletion in further milestones.
+
+## Annotation Parameters
+
+Annotation parameters of type `java.lang.Class<T>` are deprecated.
+
+Annotation parameters of type `kotlin.reflect.KClass<T>` are supported.
+
+A quick-fix transforming one into the other is provided.
+
+## Annotation Arguments
+
+Arguments of the form `javaClass<T>()` are deprecated.
+
+Arguments of teh form `ClassName::class` are supported.
+
+A quick-fix transforming one into the other is provided.
+
+## Loading Annotation Classes from Java
+
+Java annotation `@interfaces` may declare methods of type `java.lang.Class<T>`. And on the JVM this is the only representation we can compile our annotations to. These should be processed specially and mapped to `kotlin.reflect.KClass<T>`. At the call sites for annotations delcared in Kotlin as well as in Java, when a property of type `KClass<T>` is accessed, we have to map its value from `java.lang.Class` to `kotlin.reflect.KClass`. Same needs to happen when we access those properties through reflection.","delcared -> declared
","""teh"" -> ""the"""
281,"@@ -0,0 +1,34 @@
+# Class Literals as Annotation Arguments
+
+Prior to M12 Kotlin annotation allowed parameters of type `java.lang.Class<...>` whose values could be of the form `javaClass<...>()`. 
+Since M12 both these options are deprecated, and subject to deletion in further milestones.
+
+## Annotation Parameters
+
+Annotation parameters of type `java.lang.Class<T>` are deprecated.
+
+Annotation parameters of type `kotlin.reflect.KClass<T>` are supported.
+
+A quick-fix transforming one into the other is provided.
+
+## Annotation Arguments
+
+Arguments of the form `javaClass<T>()` are deprecated.
+
+Arguments of teh form `ClassName::class` are supported.
+
+A quick-fix transforming one into the other is provided.
+
+## Loading Annotation Classes from Java
+
+Java annotation `@interfaces` may declare methods of type `java.lang.Class<T>`. And on the JVM this is the only representation we can compile our annotations to. These should be processed specially and mapped to `kotlin.reflect.KClass<T>`. At the call sites for annotations delcared in Kotlin as well as in Java, when a property of type `KClass<T>` is accessed, we have to map its value from `java.lang.Class` to `kotlin.reflect.KClass`. Same needs to happen when we access those properties through reflection.
+
+> This is unprecedented in Kotlin: never before we mapped a Java class to another *real* class, all mappings we had before were fictitious, e.g. existed at compile time only.
+
+Since it is likely to be rather common that the value of an annotation property will only be used to retrieve an instance of `java.lang.Class`, e.g. `annInstance.implClass.java`, to avoid runtime overhead, we should optimize such cases in the JVM back-end by skipping the steps of converting a `java.lamg.Class` to `KClass` and then back.
+","lamg -> lang
","""teh"" -> ""the"""
282,"@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInspection.CleanupLocalInspectionTool
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.psi.KtClassBody
+
+class RemoveEmptyClassBodyInspection : IntentionBasedInspection<KtClassBody>(RemoveEmptyClassBodyIntention::class), CleanupLocalInspectionTool {","If you want your inspection to run as part of code cleanup, you need to specify cleanupTool=""true"" in its XML registration.
",I don't think we need this class.
283,"@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.adapters
+
+import org.jetbrains.kotlin.effectsystem.structure.ConstantID
+import org.jetbrains.kotlin.effectsystem.structure.ESValueID
+import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue
+
+class DataFlowValueID(val dfv: DataFlowValue) : ESValueID {",Not quite sure this wrapper is needed. Can `DataFlowValue` itself serve you here?,Nit: `dfv` -> `value`
284,"@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaTypeParameter
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.TypeParameterElement
+import javax.lang.model.type.TypeVariable
+
+class SymbolBasedTypeParameter<out T : TypeParameterElement>(element: T,
+                                                             javac: JavacWrapper) : SymbolBasedClassifier<T>(element, javac), JavaTypeParameter {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())",`Name.identifier`,I think we can use `element.simpleName.toSt
285,"@@ -0,0 +1,34 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaTypeParameter
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.TypeParameterElement
+import javax.lang.model.type.TypeVariable
+
+class SymbolBasedTypeParameter<out T : TypeParameterElement>(element: T,
+                                                             javac: JavacWrapper) : SymbolBasedClassifier<T>(element, javac), JavaTypeParameter {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())
+
+    override val upperBounds
+        get() = listOf(SymbolBasedClassifierType((element.asType() as TypeVariable).upperBound, javac))",I think you should handle the case of `IntersectionType` here by expanding it into multiple bounds. `TypeVariable.getUpperBound`'s javadoc implies that this is possible here.,I don't think we need to override `get()` h
286,"@@ -0,0 +1,342 @@
+# Function Types in Kotlin on JVM
+
+## Goals
+
+* Get rid of 23 hardwired physical function classes. The problem with them is,
+reflection introduces a few kinds of functions but each of them should be invokable as a normal function as well, and so
+we get `{top-level, member, extension, member-extension, local, ...} * 23` = **a lot** of physical classes in the runtime.
+* Make extension functions coercible to normal functions (with an extra parameter).
+At the moment it's not possible to do `listOfStrings.map(String::length)`
+* Allow functions with more than 23 parameters, theoretically any number of parameters (in practice 255 on JVM).
+* At the same time, allow to implement Kotlin functions easily from Java: `new Function2() { ... }` and overriding `invoke` only would be the best.
+Enabling SAM conversions on Java 8 would also be terrific.
+
+## Brief solution overview
+
+* Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.
+* Introduce a physical class `Function` and unlimited number of *fictitious* (synthetic) classes `Function0`, `Function1`, ... in the compiler front-end
+* On JVM, introduce `Function0`..`Function22`, which are optimized in a certain way,
+and `FunctionN` for functions with 23+ parameters.
+When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.
+* Also on JVM (under the hood) add abstract `FunctionImpl` which implements all of `Fun0`..`Fun22` and `FunN`
+(throwing exceptions), and which knows its arity.
+Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.
+* Provide a way to get arity of an arbitrary `Function` object (pretty straightforward).
+* Hack `is/as Function5` on any numbered function in codegen (and probably `KClass.cast()` in reflection) to check against `Function` and its arity.
+
+## Extension functions
+
+Extension function type `T.(P) -> R` is now just a shorthand for `[kotlin.extension] Function2<T, P, R>`.
+`kotlin.extension` is a **type annotation** defined in built-ins.
+So effectively functions and extension functions now have the same type,
+how can we make extension function expressions support extension function call syntax?
+
+We introduce the following convention: expression `foo` of type `Foo` can be used as an extension function
+(i.e. `object.foo(arguments)`) if and only if there is a function `invokeExtension`
+with the corresponding parameters available on the type `Foo`.
+This function may be declared in class `Foo` or somewhere as an extension to `Foo`.
+
+> Note that at the moment a less convenient convention is used: there must be a **member extension**
+> function `invoke` in the class which you want to be used as an extension function.
+> This means you can't add ""extension-function-ness"" to a foreign class,
+> since you'd need to declare a function with two receivers.
+> The new approach will solve this problem.
+
+We declare `invokeExtension` to be available on all extension functions:
+
+``` kotlin
+package kotlin
+
+...
+fun <T, R> (T.() -> R).invokeExtension(): R = this()
+fun <T, P1, R> (T.(P1) -> R).invokeExtension(p1: P1): R = this(p1)
+...
+```
+
+So now an expression type-checked to an ""extension function type"" can be used with the desired syntax.
+But, since a function type and a corresponding extension function type effectively have the same classifier (e.g. `Function7`),
+they are coercible to each other and therefore our `invokeExtension` will be applicable to the usual
+functions as well, which is something we don't want to happen! Example:
+
+``` kotlin
+val lengthHacked: (String) -> Int = { it.length }
+
+fun test() = """".lengthHacked()  // <-- bad! The declared function accepts a single non-receiver argument
+                                // and is not designed to be invoked as an extension
+```
+
+And here we introduce the following **restriction**: given a call `object.foo(arguments)`,
+if `foo` is resolved **exactly** to the built-in extension function `invokeExtension`,
+then the call *will not compile* unless the receiver type is annotated with `[extension]`.
+So `invokeExtension` will yield an error when used on a normal (not extension) function.
+
+To make your class invokable as an extension you only need to declare `invokeExtension`.
+Declaring `invoke` (and maybe overriding it from the needed function class) will only make your class invokable *as a usual function*.
+Inheriting from a function type thus makes sense if you want your class to behave like a simple function.
+Inheriting from an extension function type however makes no sense and should be prohibited / frowned upon.
+In a broad sense, providing type annotations on supertypes (which is what inheriting from an extension function is)
+maybe should be diagnosed in the compiler (maybe not, more knowledge needed).
+
+With this we'll get rid of classes `ExtensionFunction0`, `ExtensionFunction1`, ...
+and the rest of this article will deal only with usual functions.
+
+## Function0, Function1, ... types
+
+The arity of the functional trait that the type checker can create in theory **is not limited** to any number,
+but in practice should be limited to 255 on JVM.
+
+These traits are named `kotlin.Function0<R>`, `kotlin.Function1<P0, R>`, ..., `kotlin.Function42<P0, P1, ..., P41, R>`, ...
+They are *fictitious*, which means they have no sources and no runtime representation.
+Type checker creates the corresponding descriptors on demand, IDE creates corresponding source files on demand as well.
+Each of them inherits from `kotlin.Function` (described below) and contains a single
+`fun invoke()` with the corresponding number of parameters and return type.
+
+> TODO: investigate exactly what changes in IDE should be done and if they are possible at all.
+
+On JVM function types are erased to the physical classes defined in package `kotlin.jvm.internal`:
+`Function0`, `Function1`, ..., `Function22` and `FunctionN` for 23+ parameters.
+
+## Function trait
+
+There's also an empty trait `kotlin.Function<R>` for cases when e.g. you're storing functions with different/unknown arity
+in a collection to invoke them reflectively somewhere else.
+
+``` kotlin
+package kotlin
+
+trait Function<out R>
+```
+
+It's a physical trait, declared in platform-agnostic built-ins, and present in `kotlin-runtime.jar` for example.
+However its declaration is **empty** and should be empty because every physical JVM function class `Function0`, `Function1`, ...
+inherits from it (and adds `invoke()`), and we don't want to override anything besides `invoke()` when doing it from Java code.
+
+## Functions with 0..22 parameters at runtime
+
+There are 23 function traits in `kotlin.platform.jvm`: `Function0`, `Function1`, ..., `Function22`.
+Here's `Function1` declaration, for example:
+
+``` kotlin
+package kotlin.platform.jvm
+
+trait Function1<in P1, out R> : kotlin.Function<R> {
+    fun invoke(p1: P1): R
+}
+```
+
+These traits are supposed to be inherited from by Java classes when passing lambdas to Kotlin.
+
+Package `kotlin.platform.jvm` is supposed to contain interfaces which help use Kotlin from Java.
+(And not from Kotlin, because normally you would use a function type there,
+most of the time even without mentioning built-in function classes: `(P1, P2, P3) -> R`.)
+
+## Translation of Kotlin lambdas
+
+There's also `FunctionImpl` abstract class at runtime which helps in implementing `arity` and vararg-invocation.
+It inherits from all the physical function classes, unfortunately (more on that later).
+
+``` kotlin
+package kotlin.jvm.internal
+
+abstract class FunctionImpl(override val arity: Int) :
+    Function<Any?>,
+    Function0<Any?>, Function1<Any?, Any?>, ..., ..., Function22<...>,
+    FunctionN   // See the next section on FunctionN
+{
+    override fun invoke(): Any? {
+        // Default implementations of all ""invoke""s invoke ""invokeVararg""
+        // This is needed for KFunctionImpl (see below)
+        assert(arity == 0)
+        return invokeVararg()
+    }
+    
+    override fun invoke(p1: Any?): Any? {
+        assert(arity == 1)
+        return invokeVararg(p1)
+    }
+    
+    ...
+    override fun invoke(p1: Any?, ..., p22: Any?) { ... }
+    
+    override fun invokeVararg(vararg p: Any?): Any? = throw UnsupportedOperationException()
+    
+    override fun toString() = ... // Some calculation involving generic runtime signatures
+}
+```
+
+> TODO: sadly, this class needs to be implemented in Java because supertypes need to be **raw** classes
+> for reflection to pick up correct generic signatures for inheritors
+
+Each lambda is compiled to an anonymous class which inherits from `FunctionImpl` and implements the corresponding `invoke`:
+
+``` kotlin
+{ (s: String): Int -> s.length }
+
+// is translated to
+
+object : FunctionImpl(2), Function2<String, Int> {","Doesn't `Function2` have 3 type parameters (2 for parameter types and 1 for return type)?
",I don't think we need to mention `Function`
287,"@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClassifierType
+import org.jetbrains.kotlin.load.java.structure.JavaTypeParameter
+import org.jetbrains.kotlin.name.SpecialNames
+import javax.lang.model.element.TypeParameterElement
+import javax.lang.model.type.TypeVariable
+
+class JavacTypeParameter<out T : TypeParameterElement>(element: T,
+                                                       javac: Javac) : JavacClassifier<T>(element, javac), JavaTypeParameter {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(element.simpleName.toString())
+
+    override val upperBounds: Collection<JavaClassifierType>
+        get() = listOf(JavacClassifierType((element.asType() as TypeVariable).upperBound, javac))
+","In NB plugin, `equals` & `hashCode` are also implemented for this class. Should we have them here?",I think it would be better to use `List<Jav
288,"@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.structure
+
+/**
+ * An abstraction of effect-generating nature of some operation.
+ *
+ * [ESFunctor] roughly corresponds to some call, but it cares only
+ * about effects of this call, so instead of value arguments, its [apply]
+ * method takes just description of effects of each argument
+ * (represented by [EffectSchema]), and produces effects of the whole call
+ * (instead of some value, compared to usual calls).
+ *
+ * Implementors should never produce non-conservative effects.
+ * However, they are not obliged to produce most precise description
+ * of effects, though they are encouraged to do so.
+ */
+
+interface ESFunctor {",May be it's better to move this into `functors` package,I'm not sure if this is the best name for this interface. Maybe `Function`?
289,"@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaWildcardType
+import javax.lang.model.type.TypeMirror
+import javax.lang.model.type.WildcardType
+
+class JavacWildcardType<out T : TypeMirror>(typeMirror: T,
+                                            javac: Javac) : JavacType<T>(typeMirror, javac), JavaWildcardType {
+
+    override val bound
+        get() = typeMirror.let {
+            val boundMirror = (it as WildcardType).extendsBound ?: it.superBound
+
+            if (boundMirror != null) create(boundMirror, javac) else null","`boundMirror.let { create(it, javac) }`",I don't think this is the right place to put this. I think it should be in 
290,"@@ -0,0 +1,36 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaWildcardType
+import javax.lang.model.type.TypeMirror
+import javax.lang.model.type.WildcardType
+
+class SymbolBasedWildcardType<out T : TypeMirror>(typeMirror: T,",Looks like generic type parameter `T` is not needed here as well. This class should just inherit from `SymbolBasedType<WildcardType>` and `typeMirror` should have the type `WildcardType`,I don't think we need the `out` parameter.
291,"@@ -0,0 +1,38 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.AnnotationMirror
+import javax.lang.model.element.TypeElement
+
+open class SymbolBasedAnnotation(val annotationMirror: AnnotationMirror,
+                                 val javac: JavacWrapper) : JavaElement, JavaAnnotation {
+
+    override val arguments
+        get() = annotationMirror.elementValues
+                .map { SymbolBasedAnnotationArgument.create(it.value.value, Name.identifier(it.key.simpleName.toString()), javac) }","`.map { (key, value) -> ... }`",I don't think we need the `toString` here.
292,"@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.sun.tools.javac.util.Options
+import java.util.regex.Pattern
+
+object JavacOptionsMapper {
+
+    fun map(options: Options, arguments: List<String>) = arguments.forEach { options.putOption(it) }","Please don't use expression body syntax for `Unit`-returning functions, it's slightly confusing (I was figuring out what does this function return)",Why do we need this?
293,"@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.sun.tools.javac.util.Options
+import java.util.regex.Pattern
+
+object JavacOptionsMapper {
+
+    fun map(options: Options, arguments: List<String>) = arguments.forEach { options.putOption(it) }
+
+    private val optionPattern by lazy { Pattern.compile(""\\s+"") }",There's no need to make it lazy (it will be accessed anyway any time `JavacOptionsMapper.map` is called),I think this should be named `JavacOptionsMapper`
294,"@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.sun.tools.javac.util.Options
+import java.util.regex.Pattern
+
+object JavacOptionsMapper {
+
+    fun map(options: Options, arguments: List<String>) = arguments.forEach { options.putOption(it) }
+
+    private val optionPattern by lazy { Pattern.compile(""\\s+"") }
+
+    private fun Options.putOption(option: String) = option
+            .split(optionPattern)
+            .filter { it.isNotEmpty() }
+            .let { arg ->
+                when(arg.size) {
+                    1 -> put(arg[0], arg[0])
+                    2 -> put(arg[0], arg[1])
+                    else -> null","`else -> null` is not needed here, I think",nit: `arg -> arg[0] = arg[0]`
295,"@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaClassifier
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.element.Element
+
+abstract class SymbolBasedClassifier<out T : Element>(element: T,
+                                                      javac: JavacWrapper) : SymbolBasedElement<T>(element, javac), JavaClassifier, JavaAnnotationOwner {
+
+    override val annotations
+        get() = element.annotationMirrors
+                .map { SymbolBasedAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName) = element.annotationMirrors
+            .find { it.toString() == ""@${fqName.asString()}"" }","Please avoid using `toString` in this way in production code. I don't see anything in `TypeMirror.toString`'s javadoc that would suggest that the returned string is equal to `@` + annotation type's FQ name, which means that it can change between releases. I think inspecting the type directly via `AnnotationMirror.getAnnotationType` would be more robust",I don't think we need `out` here.
296,"@@ -0,0 +1,39 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMember
+import org.jetbrains.kotlin.name.FqName
+
+abstract class JCMember<out T : JCTree>(tree: T,
+                                        treePath: TreePath,
+                                        override val containingClass: JavaClass,
+                                        javac: Javac) : JCElement<T>(tree, treePath, javac), JavaMember {
+
+    override val isDeprecatedInJavaDoc = false
+
+    override val annotations
+        get() = emptyList<JavaAnnotation>()
+
+    override fun findAnnotation(fqName: FqName) = annotations.firstOrNull { it.classId?.asSingleFqName() == fqName }","Again, what do you want to find in the empty list?",I don't think we need to override `get()` here.
297,"@@ -0,0 +1,4 @@
+// ERROR: Too many arguments for public final fun get(index: kotlin.Int): kotlin.Int defined in kotlin.Array","I can't seem to fix the source of this error, so I declared it.
",// ERROR: Too many arguments for public final fun get(index: int):
298,"@@ -0,0 +1,4 @@
+// ERROR: Too many arguments for public final fun get(index: kotlin.Int): kotlin.Int defined in kotlin.Array
+fun foo(a: Array<Int>, i: Int) {
+    a<caret>[i, { }]","This wouldn't work unless the second argument was a function. Is it still possible to give multiple indices to this construct (i.e, `a[i, 2]`)?
",
299,"@@ -0,0 +1,4 @@
+// ERROR: Unresolved reference: !in","I don't understand this error.
",
300,"@@ -0,0 +1,4 @@
+// IS_APPLICABLE: false
+fun foo(x: Foo?) {
+    x!!.<caret>get(1)
+}","Why not applicable here? `x!![1]` looks pretty okay
",
301,"@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.lang.psi.JetClass;
+import org.jetbrains.jet.lang.psi.JetFile;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.plugin.JetBundle;","A lot of not optimized imports.
When committing, check that you your code is green (no warnings). If you edit some code, assure that you don't introduce new warnings.
",I don't think you need this import.
302,"@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.incremental.components.LookupTracker
+import org.jetbrains.kotlin.incremental.components.ScopeKind
+import org.jetbrains.kotlin.rmi.CompileService
+import org.jetbrains.kotlin.rmi.LoopbackNetworkInterface
+import org.jetbrains.kotlin.rmi.SOCKET_ANY_FREE_PORT
+import java.rmi.server.UnicastRemoteObject
+
+
+public class RemoteLookupTrackerServer(val base: LookupTracker, port: Int = SOCKET_ANY_FREE_PORT) : CompileService.RemoteLookupTracker {
+
+    init {
+        UnicastRemoteObject.exportObject(this, port, LoopbackNetworkInterface.clientLoopbackSocketFactory, LoopbackNetworkInterface.serverLoopbackSocketFactory)
+    }
+
+    override fun record(lookupContainingFile: String, lookupLine: Int?, lookupColumn: Int?, scopeFqName: String, scopeKind: ScopeKind, name: String) {
+        base.record(lookupContainingFile, lookupLine, lookupColumn, scopeFqName, scopeKind, name)
+    }
+
+    private val _isDoNothing: Boolean = base == LookupTracker.DO_NOTHING","I think underscore is not needed here
",`_isDoNothing` is not used.
303,"@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.descriptors.ConstructorDescriptor
+import org.jetbrains.kotlin.descriptors.PropertyDescriptor
+import org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor
+import org.jetbrains.kotlin.load.java.components.AbstractJavaResolverCache
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.resolve.lazy.ResolveSession
+
+class JavacBasedJavaResolverCache(resolveSession: ResolveSession) : AbstractJavaResolverCache(resolveSession) {",May be we should name it like `StubJavaResolverCache`. The thing here is obviously not javac based.,Could you please add the copyright header to all new files?
304,"@@ -0,0 +1,40 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaClassifier
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.element.Element
+
+abstract class JavacClassifier<out T : Element>(element: T,
+                                                javac: Javac) : JavacElement<T>(element, javac), JavaClassifier, JavaAnnotationOwner {
+
+    override val annotations: Collection<JavaAnnotation>
+            get() = element.annotationMirrors
+                    .map { JavacAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName): JavaAnnotation? = element.annotationMirrors
+            .filter { it.toString() == fqName.asString() }
+            .firstOrNull()
+            ?.let { JavacAnnotation(it, javac) }
+
+    override val isDeprecatedInJavaDoc = false",Why always false?,I don't think we need the `out` parameter.
305,"@@ -0,0 +1,40 @@
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+
+class TooLongCharLiteralToStringFix(
+        element: KtConstantExpression
+) : KotlinQuickFixAction<KtConstantExpression>(element) {
+    override fun getText(): String = ""Convert too long character literal to string""
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val text = element.text
+        if (!(text.startsWith(""'"") && text.endsWith(""'"") && text.length >= 2)) {
+            return
+        }
+
+        val newStringContent = text
+                .slice(1..text.length - 2)
+                .replace(""\\"", ""\\\\"")","For me it's suspicious. We can have a literal like `'Bye\n'` and expect to get `""Bye\n""` as result, so I'd not touch these back slashes. Please add a test for such case.
",I'm not sure if this is the right place to
306,"@@ -0,0 +1,40 @@
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+
+class TooLongCharLiteralToStringFix(
+        element: KtConstantExpression
+) : KotlinQuickFixAction<KtConstantExpression>(element) {
+    override fun getText(): String = ""Convert too long character literal to string""
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val text = element.text
+        if (!(text.startsWith(""'"") && text.endsWith(""'"") && text.length >= 2)) {
+            return
+        }
+
+        val newStringContent = text
+                .slice(1..text.length - 2)
+                .replace(""\\"", ""\\\\"")
+                .replace(""\"""", ""\\\"""")","Changing double quote to escaped double quote is logical, I think it should be left as is.
",I'm not sure if this is the right place to
307,"@@ -0,0 +1,40 @@
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+
+class TooLongCharLiteralToStringFix(
+        element: KtConstantExpression
+) : KotlinQuickFixAction<KtConstantExpression>(element) {
+    override fun getText(): String = ""Convert too long character literal to string""
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val text = element.text
+        if (!(text.startsWith(""'"") && text.endsWith(""'"") && text.length >= 2)) {
+            return
+        }
+
+        val newStringContent = text
+                .slice(1..text.length - 2)
+                .replace(""\\"", ""\\\\"")
+                .replace(""\"""", ""\\\"""")
+        val newElement = KtPsiFactory(element).createStringTemplate(newStringContent)","What happens if we have character literal like `'$x'` ? Should we get `""$x""` or `""\$x""`? I'd say the first case (without dollar escaping) is more logical, but I'd add a test for it.
",I'm not sure if this is the right place to
308,"@@ -0,0 +1,40 @@
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+
+class TooLongCharLiteralToStringFix(
+        element: KtConstantExpression
+) : KotlinQuickFixAction<KtConstantExpression>(element) {
+    override fun getText(): String = ""Convert too long character literal to string""
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val text = element.text
+        if (!(text.startsWith(""'"") && text.endsWith(""'"") && text.length >= 2)) {
+            return
+        }
+
+        val newStringContent = text
+                .slice(1..text.length - 2)
+                .replace(""\\"", ""\\\\"")
+                .replace(""\"""", ""\\\"""")
+        val newElement = KtPsiFactory(element).createStringTemplate(newStringContent)
+
+        element.replace(newElement)
+    }
+
+    override fun getFamilyName(): String = ""Strings""","Usually `= text` is in use here.
",I don't think you need to check for `endsW
309,"@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+
+class JCPackage(val name: String, val javac: Javac) : JavaPackage {
+
+    override val fqName: FqName
+        get() = FqName(name)",Consider making it an initializer and remove getter,I don't think we need this class. We can j
310,"@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+
+class TreeBasedPackage(val name: String, val javac: JavacWrapper) : JavaPackage {","Similarly to `SymbolBasedPackage`, I think it can inherit from `SymbolBasedElement` and avoid overriding `equals`/`hashCode`/`toString`",I think we can remove this class and just 
311,"@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+
+class TreeBasedPackage(val name: String, val javac: JavacWrapper) : JavaPackage {
+
+    override val fqName
+        get() = FqName(name)
+
+    override val subPackages
+        get() = javac.findSubPackages(fqName)
+
+    override fun getClasses(nameFilter: (Name) -> Boolean) = javac.findClassesFromPackage(fqName)","Shouldn't `TreeBasedPackage` contain only `TreeBasedClass`es, and `SymbolBasedPackage` -- only `SymbolBasedClass`es?",I think this should be `findClassesFromPac
312,"@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.kotlin.KotlinBinaryClassCache
+import org.jetbrains.kotlin.load.kotlin.KotlinJvmBinaryClass
+import org.jetbrains.kotlin.load.kotlin.VirtualFileFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.wrappers.trees.computeClassId
+
+
+abstract class JavacVirtualFileFinder : VirtualFileFinder() {
+
+    override fun findKotlinClass(javaClass: JavaClass): KotlinJvmBinaryClass? {
+        var file = javaClass.computeClassId()?.let(this::findVirtualFileWithHeader) ?: return null
+
+        if (javaClass.outerClass != null) {
+            // For nested classes we get a file of the containing class, to get the actual class file for A.B.C,
+            // we take the file for A, take its parent directory, then in this directory we look for A$B$C.class
+            file = file.parent!!.findChild(classFileName(javaClass) + "".class"").sure { ""Virtual file not found for $javaClass"" }","Again, it's better not to repeat the same code. Extract some protected function from `VirtualFileFinder`",nit: `findVirtualFileWithHeader` -> `findV
313,"@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.kotlin.KotlinBinaryClassCache
+import org.jetbrains.kotlin.load.kotlin.KotlinJvmBinaryClass
+import org.jetbrains.kotlin.load.kotlin.VirtualFileFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.wrappers.trees.computeClassId
+
+
+abstract class JavacVirtualFileFinder : VirtualFileFinder() {
+
+    override fun findKotlinClass(javaClass: JavaClass): KotlinJvmBinaryClass? {
+        var file = javaClass.computeClassId()?.let(this::findVirtualFileWithHeader) ?: return null
+
+        if (javaClass.outerClass != null) {
+            // For nested classes we get a file of the containing class, to get the actual class file for A.B.C,
+            // we take the file for A, take its parent directory, then in this directory we look for A$B$C.class
+            file = file.parent!!.findChild(classFileName(javaClass) + "".class"").sure { ""Virtual file not found for $javaClass"" }
+        }
+
+        return KotlinBinaryClassCache.getKotlinBinaryClass(file)
+    }
+
+    inline fun <T : Any> T?.sure(message: () -> String): T = this ?: throw AssertionError(message())",This function already exists (anyway you will not need it after processing the previous comment),nit: `findVirtualFileWithHeader` -> `findV
314,"@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtFunction
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
+
+class AddOpenModifierIntention : SelfTargetingIntention<KtDeclaration>(KtDeclaration::class.java, ""Make open""), LowPriorityAction {
+    override fun isApplicableTo(element: KtDeclaration, caretOffset: Int): Boolean {
+        if (element.hasModifier(KtTokens.OPEN_KEYWORD) || element.hasModifier(KtTokens.PRIVATE_KEYWORD)) return false
+        when (element) {
+            is KtProperty -> if (element.isLocal) return false
+            is KtFunction -> if (element.isLocal) return false
+        }
+        val ktClass = element.getNonStrictParentOfType<KtClass>() ?: return false
+        return ktClass.hasModifier(KtTokens.OPEN_KEYWORD)","Things are not so easy here. First of all, there is `KtDeclaration.implicitModality()`, please use it. For example, interface functions with body are implicitly open and do not require explicit open modifier. Also, you need `containingClassOrObject` and not `getNonStrictParentOfType<KtClass>`, you are risking to miss e.g. companion object in the middle this way. Remember also that object / interface members should never have `open` added, as well as top-level guys. And at last, class can have `open` members if it's `open`, `abstract` or `sealed` itself, I'd not limit it to just open classes as described in an issue. ",I think it would be better to use `KtClass
315,"@@ -0,0 +1,42 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.PackageElement
+
+class SymbolBasedPackage(val element: PackageElement, val javac: JavacWrapper) : JavaPackage {",Why doesn't it inherit from `SymbolBasedElement` to get `equals`/`hashCode`/`toString` for free?,I don't think we need this class. We can j
316,"@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+
+class AddRunToLambdaFix(element: KtLambdaExpression) : KotlinQuickFixAction<KtLambdaExpression>(element) {
+    override fun getText() = ""Add 'run' before the lambda expression""
+    override fun getFamilyName() = ""Add 'run' before the lambda expression""","`= getText()`
",I don't think you need to override `getFam
317,"@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.VariableElement
+
+class SymbolBasedField<out T : VariableElement>(element: T,
+                                                javac: JavacWrapper) : SymbolBasedMember<T>(element, javac), JavaField {
+
+    override val isEnumEntry
+        get() = element.kind == ElementKind.ENUM_CONSTANT
+
+    override val type
+        get() = SymbolBasedType.create(element.asType(), javac)
+
+    override val initializerValue: Any?
+        get() = element.constantValue
+
+    override val hasConstantNotNullInitializer
+        get() = element.constantValue?.let {
+            val typeMirror = type.typeMirror
+
+            (typeMirror.kind.isPrimitive || typeMirror.toString() == ""java.lang.String"")","Please inspect the underlying element instead of `toString`.
",I'm not sure if this is the best way to ch
318,"@@ -0,0 +1,43 @@
+package test
+
+public/*package*/ open class ExtendsAbstractListT {
+    public/*package*/ constructor ExtendsAbstractListT()
+}
+
+public abstract class Mine</*0*/ T> : java.util.AbstractList<T> {
+    public constructor Mine</*0*/ T>()
+    protected/*protected and package*/ final /*fake_override*/ var modCount: kotlin.Int
+    public abstract /*fake_override*/ val size: kotlin.Int
+    public open /*fake_override*/ fun add(/*0*/ T!): kotlin.Boolean
+    public open /*fake_override*/ fun add(/*0*/ kotlin.Int, /*1*/ T!): kotlin.Unit
+    public open /*fake_override*/ fun addAll(/*0*/ kotlin.Int, /*1*/ kotlin.collections.Collection<T!>): kotlin.Boolean
+    public open /*fake_override*/ fun addAll(/*0*/ kotlin.collections.Collection<T!>): kotlin.Boolean
+    public open /*fake_override*/ fun clear(): kotlin.Unit
+    public open /*fake_override*/ fun contains(/*0*/ T!): kotlin.Boolean
+    public open /*fake_override*/ fun containsAll(/*0*/ kotlin.collections.Collection<T!>): kotlin.Boolean
+    public open /*fake_override*/ fun forEach(/*0*/ java.util.function.Consumer<in T!>!): kotlin.Unit","Do I understand correctly that `xxx2.txt` differs from `xxx.txt` only in members that come from Java 8 and this is caused by the fact that the original test was run against JDK 6, but the test with javac is run against JDK 8?

I suggest just using JDK 8 then in both tests, to avoid complicating things too much.",`/*1*/` is not needed.
319,"@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.PackageElement
+
+class JavacPackage(val element: PackageElement, val javac: Javac) : JavaPackage {
+
+    override val fqName
+        get() = element.qualifiedName.let { FqName(it.toString()) }",I'd consider removing `let` from this and next getter. I suppose code without it will be easier to read,I don't think we need this class.
320,"@@ -0,0 +1,44 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaPackage
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.PackageElement
+
+class JavacPackage(val element: PackageElement, val javac: Javac) : JavaPackage {
+
+    override val fqName
+        get() = element.qualifiedName.let { FqName(it.toString()) }
+
+    override val subPackages
+        get() = javac.findSubPackages(element.qualifiedName.toString().let(::FqName))
+
+    override fun getClasses(nameFilter: (Name) -> Boolean) = javac.findClassesFromPackage(fqName)
+            .filter { Name.isValidIdentifier(it.name.toString())
+                      && nameFilter(Name.identifier(it.name.toString()))
+            }
+
+    override fun hashCode() = element.hashCode()
+
+    override fun equals(other: Any?) = (other as? JavacPackage)?.element == element",Why do you need to override `equals` from `JavacElement` here?,I'm not sure if this is the best way to do this. I'm not sure what the best way to do this is.
321,"@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr","It seems this file should be placed in the appropriate subdirectory in order to get rid of warning about file location?
",Why do we need this file?
322,"@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.rmi.RemoteOutputStream
+import java.io.OutputStream
+import java.rmi.server.UnicastRemoteObject
+
+
+class RemoteOutputStreamServer(val out: OutputStream) : RemoteOutputStream {","`: RemoteOutputStream by out`
",I don't think we need the `val` here.
323,"@@ -0,0 +1,45 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.kotlinr
+
+import org.jetbrains.kotlin.rmi.RemoteOutputStream
+import java.io.OutputStream
+import java.rmi.server.UnicastRemoteObject
+
+
+class RemoteOutputStreamServer(val out: OutputStream) : RemoteOutputStream {
+
+    init {
+        UnicastRemoteObject.exportObject(this, 0)
+    }
+
+    public fun disconnect() {
+        UnicastRemoteObject.unexportObject(this, true)
+    }
+
+    override fun close() {
+        out.close()
+    }
+
+    override fun write(data: ByteArray, start: Int, length: Int) {","`start` -> `offset` (as in the supertype) in order to get rid of corresponding warning.
",Why do we need this class?
324,"@@ -0,0 +1,46 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import org.jetbrains.jet.lang.psi.JetQualifiedExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetValueArgument
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+
+
+public class BracketToGetIntention : JetSelfTargetingIntention<JetArrayAccessExpression>(""bracket.to.get"", javaClass()) {
+    override fun isApplicableTo(element: JetArrayAccessExpression): Boolean {
+        return element is JetArrayAccessExpression
+    }
+
+    override fun applyTo(element: JetArrayAccessExpression, editor: Editor) {
+        val array = element.getArrayExpression()!!
+        val indices = element.getIndexExpressions()
+
+        val arrayText = array.getText()
+        val indicesText = indices.map { it.getText() }.makeString("", "")","This line feels like a hack. It also doesn't preserve comments. Is there any way to get the contents of the indices without losing comments?
",I think this should be `bracket.to.get`
325,"@@ -0,0 +1,46 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor.wordSelection
+
+import com.intellij.codeInsight.editorActions.ExtendWordSelectionHandlerBase
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElement
+import org.jetbrains.kotlin.psi.KtTypeReference
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class KotlinFunctionReturnTypeSelectioner : ExtendWordSelectionHandlerBase() {
+
+    override fun canSelect(e: PsiElement?): Boolean {
+        return e is KtTypeReference
+    }
+
+    override fun select(e: PsiElement?, editorText: CharSequence?, cursorOffset: Int, editor: Editor): List<TextRange>? {
+        e ?: return null
+        editorText ?: return null
+        val position = getColonPosition(e, editorText)
+        if (position < 0) return null
+        return listOf(TextRange(position, e.endOffset))
+    }
+
+    private fun getColonPosition(e: PsiElement, editorText: CharSequence): Int {
+        val colonIndex = editorText.filterIndexed { i, c -> i < e.startOffset }.indexOfLast { it == ':' }","Please do not use the text or regular expressions to perform the action. All the necessary information is available in the PSI; please do use it.
",I don't think you need to override this method.
326,"@@ -0,0 +1,46 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtForExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.createExpressionByPattern
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+
+class ConvertRangeCheckToTwoComparisonsIntention : SelfTargetingOffsetIndependentIntention<KtBinaryExpression>(KtBinaryExpression::class.java, ""Convert to comparisons"") {
+    override fun applyTo(element: KtBinaryExpression, editor: Editor?) {
+        if (element.operationToken != KtTokens.IN_KEYWORD) return
+        val rangeExpression = element.right as? KtBinaryExpression ?: return
+        val min = rangeExpression.left?.text ?: return
+        val arg = element.left?.text ?: return
+        val max: Any = rangeExpression.right?.text ?: return",Why do you need `Any` here?,I don't think we need to check for `IN_KEYWORD` here.
327,"@@ -0,0 +1,46 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtForExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.createExpressionByPattern
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+
+class ConvertRangeCheckToTwoComparisonsIntention : SelfTargetingOffsetIndependentIntention<KtBinaryExpression>(KtBinaryExpression::class.java, ""Convert to comparisons"") {
+    override fun applyTo(element: KtBinaryExpression, editor: Editor?) {
+        if (element.operationToken != KtTokens.IN_KEYWORD) return
+        val rangeExpression = element.right as? KtBinaryExpression ?: return
+        val min = rangeExpression.left?.text ?: return
+        val arg = element.left?.text ?: return
+        val max: Any = rangeExpression.right?.text ?: return
+        val comparisonsExpression = KtPsiFactory(element).createExpressionByPattern(""$0 <= $1 && $1 <= $2"", min, arg, max)
+        element.replace(comparisonsExpression)
+    }
+
+    override fun isApplicableTo(element: KtBinaryExpression): Boolean {
+        if (element.operationToken != KtTokens.IN_KEYWORD) return false
+        // ignore for-loop. for(x in 1..2) should not be convert to for(1<=x && x<=2)
+        if (element.getStrictParentOfType<KtForExpression>() != null) return false","I'd say this condition is too strict. E.g. your intention will not work for code like

```
for (element in list) {
    if (element in 1..4) { ... }
}
```",I'm not sure if this is the right way to do this. I think it would be better to use `KtForExpr
328,"@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.codegen.intrinsics
+
+import org.jetbrains.kotlin.codegen.ExpressionCodegen
+import org.jetbrains.kotlin.codegen.StackValue
+import org.jetbrains.kotlin.descriptors.ConstructorDescriptor
+import org.jetbrains.kotlin.psi.KtCallableReferenceExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
+import org.jetbrains.kotlin.resolve.jvm.AsmTypes
+import org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver
+import org.jetbrains.org.objectweb.asm.Type
+
+class KCallableNameProperty : IntrinsicPropertyGetter() {
+    override fun generate(resolvedCall: ResolvedCall<*>?, codegen: ExpressionCodegen, returnType: Type, receiver: StackValue): StackValue? {
+        val expressionReceiver = resolvedCall!!.dispatchReceiver as? ExpressionReceiver ?: return null
+        val expression = expressionReceiver.expression as? KtCallableReferenceExpression ?: return null
+        val callableReference = expression.callableReference
+        val descriptor = callableReference.getResolvedCall(codegen.bindingContext)?.resultingDescriptor ?: return null
+
+        val name = if (descriptor is ConstructorDescriptor) {","`descriptor.name.asString()`
",I'm not sure if this is the right place to put this. I think it should be in the `IntrinsicPro
329,"@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.load.java
+
+import org.jetbrains.kotlin.load.java.structure.impl.JavaPackageImpl
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.jvm.KotlinJavaPsiFacade
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+
+import javax.annotation.PostConstruct
+
+class JavaClassFinderImpl : AbstractJavaClassFinder() {
+
+    private lateinit var javaFacade: KotlinJavaPsiFacade
+
+    @PostConstruct
+    fun initialize(trace: BindingTrace, codeAnalyzer: KotlinCodeAnalyzer) {
+        javaSearchScope = FilterOutKotlinSourceFilesScope(baseScope)",Please extract the first and the third line of this method into `AbstractJavaClassFinder.initialize` and call it here and in `JavacBasedClassFinder.initialize`,I don't think we need the `@PostConstruct` annotation.
330,"@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.load.java
+
+import org.jetbrains.kotlin.load.java.structure.impl.JavaPackageImpl
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.jvm.KotlinJavaPsiFacade
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+
+import javax.annotation.PostConstruct
+
+class JavaClassFinderImpl : AbstractJavaClassFinder() {
+
+    private lateinit var javaFacade: KotlinJavaPsiFacade
+
+    @PostConstruct
+    fun initialize(trace: BindingTrace, codeAnalyzer: KotlinCodeAnalyzer) {
+        javaSearchScope = FilterOutKotlinSourceFilesScope(baseScope)
+        javaFacade = KotlinJavaPsiFacade.getInstance(proj)
+        CodeAnalyzerInitializer.getInstance(proj).initialize(trace, codeAnalyzer.moduleDescriptor, codeAnalyzer)
+    }
+
+
+    override fun findClass(classId: ClassId) = javaFacade.findClass(classId, javaSearchScope)",Please do not omit return types at least where inspections are reported (there's an inspection about platform type here).,I think it would be better to move this class to `org.jetbrains.kotlin.resolve.java`
331,"@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.inspections.UnusedSymbolInspection
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.idea.util.findAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtNamedFunction
+import org.jetbrains.kotlin.psi.KtObjectDeclaration
+
+class AddJvmStaticIntention : SelfTargetingIntention<KtNamedFunction>(
+    KtNamedFunction::class.java,
+    ""Add '@JvmStatic' annotation""
+), LowPriorityAction {
+
+    private val annotationFqName = FqName(""kotlin.jvm.JvmStatic"")
+
+    override fun isApplicableTo(element: KtNamedFunction, caretOffset: Int): Boolean {
+        if (element.findAnnotation(annotationFqName) != null) return false
+        if (!UnusedSymbolInspection.isEntryPoint(element)) return false",See `KotlinRunLineMarkerContributor` for the correct way to check that a function is `main`.,I don't think we need to override `isApplicableTo` here.
332,"@@ -0,0 +1,47 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.inspections.UnusedSymbolInspection
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.idea.util.findAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtNamedFunction
+import org.jetbrains.kotlin.psi.KtObjectDeclaration
+
+class AddJvmStaticIntention : SelfTargetingIntention<KtNamedFunction>(
+    KtNamedFunction::class.java,
+    ""Add '@JvmStatic' annotation""
+), LowPriorityAction {
+
+    private val annotationFqName = FqName(""kotlin.jvm.JvmStatic"")
+
+    override fun isApplicableTo(element: KtNamedFunction, caretOffset: Int): Boolean {
+        if (element.findAnnotation(annotationFqName) != null) return false
+        if (!UnusedSymbolInspection.isEntryPoint(element)) return false
+        element.parent.parent.run {",Please use `KtDeclaration.containingClassOrObject`.,I think this should be `KtObjectDeclaration`
333,"@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.io.IOException
+import java.io.Serializable
+import java.net.InetAddress
+import java.net.ServerSocket
+import java.net.Socket
+import java.rmi.server.RMIClientSocketFactory
+import java.rmi.server.RMIServerSocketFactory
+
+
+// TODO switch to InetAddress.getLoopbackAddress on java 7+
+val loopbackAddrName by lazy { if (java.net.InetAddress.getLocalHost() is java.net.Inet6Address) ""::1"" else ""127.0.0.1"" }","`java.net.InetAddress.getLocalHost()` may crash with IOException (actually, UnknownHostException) on some machines due to strange network configuration. Notice that it is not a wrong machine configuration but Java's limitation. In some cases it couldn't be fixed on some corporate machines. I faced it few times in different companies. It is possible at least on Linux and Solaris machines
",I think we can remove this TODO.
334,"@@ -0,0 +1,48 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.load.java.structure.JavaValueParameter
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+
+class JCValueParameter<out T : JCTree.JCVariableDecl>(tree: T,
+                                                      treePath: TreePath,
+                                                      javac: Javac) : JCElement<T>(tree, treePath, javac), JavaValueParameter {
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = emptyList()",Value parameter in Java can have annotations,I think it would be better to use `List` instead of `Collection`.
335,"@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor.wordSelection
+
+import com.intellij.codeInsight.editorActions.ExtendWordSelectionHandlerBase
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElement
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.KtSuperTypeList
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class KotlinSuperTypeSelectioner : ExtendWordSelectionHandlerBase() {
+    override fun canSelect(e: PsiElement?): Boolean {
+        return e is KtSuperTypeList
+    }
+
+    override fun select(e: PsiElement?, editorText: CharSequence?, cursorOffset: Int, editor: Editor): List<TextRange>? {
+        e ?: return null","Those parameters are actually non-null. You don't need the null checks here and in the other selectioner.
",I don't think this is needed.
336,"@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.editor.wordSelection
+
+import com.intellij.codeInsight.editorActions.ExtendWordSelectionHandlerBase
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElement
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.KtSuperTypeList
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class KotlinSuperTypeSelectioner : ExtendWordSelectionHandlerBase() {
+    override fun canSelect(e: PsiElement?): Boolean {
+        return e is KtSuperTypeList
+    }
+
+    override fun select(e: PsiElement?, editorText: CharSequence?, cursorOffset: Int, editor: Editor): List<TextRange>? {
+        e ?: return null
+        editorText ?: return null
+        val colonPosition = getColonPosition(e)
+        if (colonPosition < 0) return null
+        return listOf(TextRange(colonPosition, e.endOffset))
+    }
+
+    private fun getColonPosition(e: PsiElement): Int {
+        var parent = e.parent","You can use the `PsiElement.getParentOfType()` extension function to do this with less code.
",I don't think we need to return null here.
337,"@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaTypeParameter
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedTypeParameter<out T : JCTree.JCTypeParameter>(tree: T,
+                                                             treePath: TreePath,
+                                                             javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaTypeParameter {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.name.toString())",`Name.identifier`,I don't think we need this class.
338,"@@ -0,0 +1,49 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaTypeParameter
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.SpecialNames
+
+class TreeBasedTypeParameter<out T : JCTree.JCTypeParameter>(tree: T,
+                                                             treePath: TreePath,
+                                                             javac: JavacWrapper) : TreeBasedElement<T>(tree, treePath, javac), JavaTypeParameter {
+
+    override val name
+        get() = SpecialNames.safeIdentifier(tree.name.toString())
+
+    override val annotations by lazy { tree.annotations().map { TreeBasedAnnotation(it, treePath, javac) } }
+
+    override fun findAnnotation(fqName: FqName) = annotations.firstOrNull { it.classId?.asSingleFqName() == fqName }
+
+    override val isDeprecatedInJavaDoc
+        get() = findAnnotation(FqName(""java.lang.Deprecated"")) != null",You should return `false` here and in other implementations of `isDeprecatedInJavaDoc`. The call site looks for the annotation itself if needed,I'm not sure if this is the best way to do
339,"@@ -0,0 +1,5 @@
+// ERROR: Unresolved reference: array","I don't understand this error.
",
340,"@@ -0,0 +1,5 @@
+<html>
+<body>
+    This intention detects 'Math.max' calls that can be safely replaced with 'coerceAtLeast'","This intention replaces 'Math.max' calls with safe 'coerceAtLeast' ... or something like. Inspection detects, but inspection does some change.
",I think this should be `<html>`.
341,"@@ -0,0 +1,5 @@
+<html>
+<body>
+Reports unnecessary java usage.","This is not clear. A better description would be ""Use of Java API that has a Kotlin equivalent"" or something like that.
",I don't think this is needed.
342,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This inspection remove an empty class body","reports and offers to remove
",Why do we need this?
343,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This inspection reports unused equals expression.",expression**s**,Why do we need this?
344,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention detects 'Math.max' calls that can be safely replaced with 'coerceAtLeast'","inspection
",I think this should be `<html>`.
345,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention detects 'Math.min' calls that can be safely replaced with 'coerceAtMost'","inspection
",I think this should be `<html>` instead of
346,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention detects an empty class body.","removes
",I don't think we need this.
347,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention makes types explicit in a lambda expression.","A little elaboration won't hurt: `types of parameters, receiver and return type`
",Why do we need this?
348,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention makes types implicit in a lambda expression","Ditto
",Why is this necessary?
349,"@@ -0,0 +1,5 @@
+<html>
+<body>
+This intention take a qualified call to any function ""get"" which has some arguments and converts it to square brackets.","""takes""
",I don't think this is necessary.
350,"@@ -0,0 +1,5 @@
+fun box(): String {
+    val sub = Box<Long>(-1)
+    println(sub.value == 1L)","replace 'println' with if check
",What is the purpose of this test?
351,"@@ -0,0 +1,5 @@
+if (<spot>foo()</spot>) {
+    bar()
+} else {
+    baz()
+}","The branches aren't swapped in the after-template
",I don't think you need the `<msg>`<msg>`<m
352,"@@ -0,0 +1,5 @@
+package org.junit
+
+@Deprecated(""Use 'Ignore' from kotlin.test package"", replaceWith = ReplaceWith(""Ignore"", imports = ""kotlin.test.Ignore""))
+@Suppress(""HEADER_WITHOUT_IMPLEMENTATION"")
+header annotation class Ignore",I'm working on not needing this...,Why do we need this annotation?
353,"@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.AbstractJavaClassFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+import javax.annotation.PostConstruct
+
+class JavacBasedClassFinder : AbstractJavaClassFinder() {
+
+    private lateinit var javac: JavacWrapper
+
+    @PostConstruct
+    fun initialize(trace: BindingTrace, codeAnalyzer: KotlinCodeAnalyzer) {
+        javaSearchScope = FilterOutKotlinSourceFilesScope(baseScope)
+        javac = JavacWrapper.getInstance(proj)
+        CodeAnalyzerInitializer.getInstance(proj).initialize(trace, codeAnalyzer.moduleDescriptor, codeAnalyzer)
+    }
+
+    override fun findClass(classId: ClassId) = javac.findClass(classId.asSingleFqName(), javaSearchScope)","Note that `ClassId.asSingleFqName` is an operation that loses some information, namely where package name in the `FqName` ends and where the class name starts. For example, `FqName` ""a.b.c"" might mean class c nested in class b in package a, or it might mean class c in package a.b.

Please consider either using `ClassId` when possible, or at least destructuring it into package FQ name and relative class name and using them, to avoid problems related to resolution of nested classes.",I think it would be better to m
354,"@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.AbstractJavaClassFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+import javax.annotation.PostConstruct
+
+class JavacBasedClassFinder : AbstractJavaClassFinder() {
+
+    private lateinit var javac: JavacWrapper
+
+    @PostConstruct
+    fun initialize(trace: BindingTrace, codeAnalyzer: KotlinCodeAnalyzer) {
+        javaSearchScope = FilterOutKotlinSourceFilesScope(baseScope)
+        javac = JavacWrapper.getInstance(proj)
+        CodeAnalyzerInitializer.getInstance(proj).initialize(trace, codeAnalyzer.moduleDescriptor, codeAnalyzer)
+    }
+
+    override fun findClass(classId: ClassId) = javac.findClass(classId.asSingleFqName(), javaSearchScope)
+
+    override fun findPackage(fqName: FqName) = javac.findPackage(fqName, javaSearchScope)
+
+    override fun knownClassNamesInPackage(packageFqName: FqName): Set<String> = javac.findClassesFromPackage(packageFqName)
+            .mapNotNullTo(hashSetOf()) {
+                it.fqName?.let {
+                    if (it.isRoot) it.asString() else it.shortName().asString()","Multiple `it`s in nested lambdas are dangerous and confusing, please rename at least one of them",I don't think we need to overri
355,"@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.psi.*
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitCallExpression(expression: KtCallExpression) {","Why is this limited to call expressions? Backticks can be used around any occurrence of identifier in Kotlin code, and the inspection should detect those in any context.",I don't think we need this clas
356,"@@ -0,0 +1,50 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.psi.*
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitCallExpression(expression: KtCallExpression) {
+                super.visitCallExpression(expression)
+                val calleeExpression = expression.calleeExpression ?: return
+                if (calleeExpression.text.contains(""^`.+`$"".toRegex())) {","This detects any backticks, not just redundant backticks. Backticks are redundant only if they enclose a valid identifier (not a keyword and not containing any invalid characters).",I don't think you need the `?:`
357,"@@ -0,0 +1,51 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.AbstractJavaClassFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+import javax.annotation.PostConstruct
+
+class JavacBasedClassFinder : AbstractJavaClassFinder() {
+
+    private lateinit var javac: JavacWrapper
+
+    @PostConstruct
+    fun initialize(trace: BindingTrace, codeAnalyzer: KotlinCodeAnalyzer) {
+        javaSearchScope = FilterOutKotlinSourceFilesScope(baseScope)
+        javac = JavacWrapper.getInstance(proj)
+        CodeAnalyzerInitializer.getInstance(proj).initialize(trace, codeAnalyzer.moduleDescriptor, codeAnalyzer)
+    }
+
+    override fun findClass(classId: ClassId) = javac.findClass(classId.asSingleFqName(), javaSearchScope)
+
+    override fun findPackage(fqName: FqName) = javac.findPackage(fqName, javaSearchScope)
+
+    override fun knownClassNamesInPackage(packageFqName: FqName) = javac.findClassesFromPackage(packageFqName)
+            .mapNotNull {","Here you can use `mapNotNullTo` without `toSet` at the end, it may be a bit faster",I don't think we need to overri
358,"@@ -0,0 +1,51 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.util.PsiTreeUtil
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
+
+class RemoveUselessIsCheckFixForWhen(element: KtWhenConditionIsPattern) : KotlinQuickFixAction<KtWhenConditionIsPattern>(element) {
+    override fun getFamilyName() = ""Remove useless is check""
+
+    override fun getText(): String = familyName
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val condition = element ?: return
+        val whenEntry = condition.parent as KtWhenEntry
+        val whenExpression = whenEntry.parent as KtWhenExpression
+
+        if (condition.isNegated) {
+            condition.parent.delete()
+        } else {
+            whenExpression.entries.forEach { it.delete() }","You should not delete all entries here, but only subsequent ones. E.g.

```
val something: Base = ...
when (something) {
    is Derived -> forDerived()
    is Base /* always true */ -> forBase()
    is Any /* unreachable */ -> forAny()
    is SomethingWrong /* also unreachable */ forWrong()
    else -> forElse()
}
```

Here `is Base` branch must be left intact.",I don't think you need to do th
359,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package kotlin.collections","Why not `package kotlin`?
",Why is this file needed?
360,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.refactoring.rename.RenameProcessor
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
+
+class ValToObjectIntention : SelfTargetingIntention<KtProperty>(KtProperty::class.java, ""Convert to object declaration"") {
+
+    override fun isApplicableTo(element: KtProperty, caretOffset: Int): Boolean {
+        if (element.isVar) return false
+        if (!element.isTopLevel) return false
+        if (element.initializer !is KtObjectLiteralExpression) return false
+        if (element.getter != null) return false
+
+        return true
+    }
+
+    override fun applyTo(element: KtProperty, editor: Editor?) {
+        val modifier = element.visibilityModifier()","You're losing all annotations on the original property. (I think that it would be best not to offer the intention if the property has any, because the semantics of annotations on a `val` and an `object` is significantly different.)
",I don't think we need to overri
361,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.refactoring.rename.RenameProcessor
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
+
+class ValToObjectIntention : SelfTargetingIntention<KtProperty>(KtProperty::class.java, ""Convert to object declaration"") {
+
+    override fun isApplicableTo(element: KtProperty, caretOffset: Int): Boolean {
+        if (element.isVar) return false
+        if (!element.isTopLevel) return false
+        if (element.initializer !is KtObjectLiteralExpression) return false
+        if (element.getter != null) return false
+
+        return true
+    }
+
+    override fun applyTo(element: KtProperty, editor: Editor?) {
+        val modifier = element.visibilityModifier()
+        val name = element.name ?: return
+        val o = element.initializer as? KtObjectLiteralExpression ?: return
+        val od = o.objectDeclaration
+        val superTypeList = od.getSuperTypeList() ?: return","I think you should check the supertype list in `isApplicableTo` as well, so that you don't end up with an intention which is enabled and does nothing.
",I don't think we need to overri
362,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.refactoring.rename.RenameProcessor
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
+
+class ValToObjectIntention : SelfTargetingIntention<KtProperty>(KtProperty::class.java, ""Convert to object declaration"") {
+
+    override fun isApplicableTo(element: KtProperty, caretOffset: Int): Boolean {
+        if (element.isVar) return false
+        if (!element.isTopLevel) return false
+        if (element.initializer !is KtObjectLiteralExpression) return false
+        if (element.getter != null) return false
+
+        return true
+    }
+
+    override fun applyTo(element: KtProperty, editor: Editor?) {
+        val modifier = element.visibilityModifier()
+        val name = element.name ?: return
+        val o = element.initializer as? KtObjectLiteralExpression ?: return
+        val od = o.objectDeclaration
+        val superTypeList = od.getSuperTypeList() ?: return
+        val body = od.getBody() ?: return
+
+        val prefix = modifier?.text?.plus("" "") ?: """"
+        val replacementText = ""${prefix}object $name: ${superTypeList.text} ${body.text}""
+        val replaced = element.replaced(KtPsiFactory(element).createDeclarationByPattern<KtObjectDeclaration>(replacementText))
+
+        RenameProcessor(element.project, replaced, name.capitalize(), false, false).doRun()","I think that automatically changing the name without user input is not a very good idea. It's better to trigger a rename refactoring where the user inputs the name, initialized with the capitalized version of the old name.
",I don't think we need to overri
363,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+
+class ReplaceMathMaxWithCoerceAtLeastInspection : IntentionBasedInspection<KtCallExpression>(ReplaceMathMaxWithCoerceAtLeastIntention::class)
+
+class ReplaceMathMaxWithCoerceAtLeastIntention() : SelfTargetingOffsetIndependentIntention<KtCallExpression>(","I think abstract class should be extracted from this intention and the next one. Too many similar code inside
",I don't think we need this clas
364,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe
+
+class ReplaceMathMaxWithCoerceAtLeastInspection : IntentionBasedInspection<KtCallExpression>(ReplaceMathMaxWithCoerceAtLeastIntention::class)
+
+class ReplaceMathMaxWithCoerceAtLeastIntention() : SelfTargetingOffsetIndependentIntention<KtCallExpression>(
+        KtCallExpression::class.java, ""Replace Math.max with coerceAtLeast"") {
+
+    override fun applyTo(element: KtCallExpression, editor: Editor?) {
+        val target = element.getStrictParentOfType<KtDotQualifiedExpression>() ?: element
+        val valueArguments = element.valueArguments
+        val newExpression = KtPsiFactory(element).createExpression(""${valueArguments[0].text}.coerceAtLeast(${valueArguments[1].text})"")
+        target.replaced(newExpression)
+    }
+
+    override fun isApplicableTo(element: KtCallExpression) = isMaxMethod(element)
+
+    private fun isMaxMethod(element: KtCallExpression) =
+            element.calleeExpression?.text == ""max"" && element.valueArguments.size == 2 && element.isMethodCall(""java.lang.Math.max"")
+
+    private fun KtCallExpression.isMethodCall(fqMethodName: String): Boolean {","You have the same method in `ReplaceMathMinWithCoerceAtMostIntention`. It would make more sense to pull it out in a Utils class.
",I think it would be better to u
365,"@@ -0,0 +1,52 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationArgument
+import org.jetbrains.kotlin.load.java.structure.JavaArrayAnnotationArgument
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.AnnotationMirror
+import javax.lang.model.element.AnnotationValue
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.TypeMirror
+
+open class SymbolBasedAnnotationArgument(private val fqName: FqName,","Annotation argument has no FQ name, a `Name` should be enough",I don't think we need the `open
366,"@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+
+open class JavacType<out T : TypeMirror>(val typeMirror: T,
+                                         val javac: Javac) : JavaType, JavaAnnotationOwner {
+
+    companion object {
+        fun <TM : TypeMirror> create(t: TM, javac: Javac) = when {
+            t.kind.isPrimitive || t.toString() == ""void"" -> JavacPrimitiveType(t, javac)",Why the second part is needed? Looks like `TypeMirror` for `void` also should be primitive? You can also consider extracting this condition as `if` and continue with `when (t.kind)`.,I don't think we need the `when
367,"@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+
+open class JavacType<out T : TypeMirror>(val typeMirror: T,
+                                         val javac: Javac) : JavaType, JavaAnnotationOwner {
+
+    companion object {
+        fun <TM : TypeMirror> create(t: TM, javac: Javac) = when {
+            t.kind.isPrimitive || t.toString() == ""void"" -> JavacPrimitiveType(t, javac)
+            t.kind == TypeKind.DECLARED || t.kind == TypeKind.TYPEVAR -> JavacClassifierType(t, javac)
+            t.kind == TypeKind.WILDCARD -> JavacWildcardType(t, javac)
+            t.kind == TypeKind.ARRAY -> JavacArrayType(t, javac)
+            else -> throw UnsupportedOperationException(""Unsupported type: $t"")
+        }
+    }
+
+    override val annotations: Collection<JavaAnnotation> = emptyList()
+
+    override val isDeprecatedInJavaDoc
+            get() = false
+
+    override fun findAnnotation(fqName: FqName) = null",`annotations` and `findAnnotation` are implemented in a different way in NB plugin,I don't think this is the right
368,"@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaConstructor
+import org.jetbrains.kotlin.name.Name
+
+class JCConstructor<out T : JCTree.JCMethodDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 containingClass: JavaClass,
+                                                 javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaConstructor {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract",Constructor never can be abstract,I don't think we need to override `get()` here.
369,"@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaConstructor
+import org.jetbrains.kotlin.name.Name
+
+class JCConstructor<out T : JCTree.JCMethodDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 containingClass: JavaClass,
+                                                 javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaConstructor {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic",Constructor never can be static,I don't think we need to override these getters
370,"@@ -0,0 +1,53 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaConstructor
+import org.jetbrains.kotlin.name.Name
+
+class JCConstructor<out T : JCTree.JCMethodDecl>(tree: T,
+                                                 treePath: TreePath,
+                                                 containingClass: JavaClass,
+                                                 javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaConstructor {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal",Also it never can be overridable. Not sure should it be considered as `final` or not.,I think it would be better to use `TreePath` he
371,"@@ -0,0 +1,54 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.Name
+
+class JCField<out T : JCTree.JCVariableDecl>(tree: T,
+                                             treePath: TreePath,
+                                             containingClass: JavaClass,
+                                             javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaField {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = if (containingClass.isInterface) true else tree.modifiers.isStatic",`containingClass.isInterface || tree.modifiers.isStatic`,I don't think we need to override these getters
372,"@@ -0,0 +1,54 @@
+package test
+
+public final annotation class AByte : kotlin.Annotation {
+    public constructor AByte(/*0*/ kotlin.Byte)
+    public final val value: kotlin.Byte
+}
+
+public final annotation class AChar : kotlin.Annotation {
+    public constructor AChar(/*0*/ kotlin.Char)
+    public final val value: kotlin.Char
+}
+
+public final annotation class ADouble : kotlin.Annotation {
+    public constructor ADouble(/*0*/ kotlin.Double)
+    public final val value: kotlin.Double
+}
+
+public final annotation class AFloat : kotlin.Annotation {
+    public constructor AFloat(/*0*/ kotlin.Float)
+    public final val value: kotlin.Float
+}
+
+public final annotation class AInt : kotlin.Annotation {
+    public constructor AInt(/*0*/ kotlin.Int)
+    public final val value: kotlin.Int
+}
+
+public final annotation class ALong : kotlin.Annotation {
+    public constructor ALong(/*0*/ kotlin.Long)
+    public final val value: kotlin.Long
+}
+
+public final annotation class AString : kotlin.Annotation {
+    public constructor AString(/*0*/ kotlin.String)
+    public final val value: kotlin.String
+}
+
+@test.AString(value = ""Test"") @test.AChar(value = \u0063 ('c')) @test.AInt(value = 10) @test.AByte(value = 11.toByte()) @test.ALong(value = 12.toLong()) @test.ADouble(value = 1.2.toDouble()) @test.AFloat(value = 1.3.toFloat()) public open class AnnotationTrait {",Ditto (`@test.AByte(value = 11.toByte())` vs `@test.AByte(value = 11)`),"`@test.AString(value = ""Test"") @test.AChar(valu"
373,"@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinValVar
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtNameReferenceExpression
+import org.jetbrains.kotlin.psi.KtParameter
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.getAssignmentByLHS
+import org.jetbrains.kotlin.psi.psiUtil.getPrimaryConstructorParameterWithSameName
+
+class MakeConstructorParameterPropertyFix(element: KtParameter, private val kotlinValVar: KotlinValVar) : KotlinQuickFixAction<KtParameter>(element) {
+    override fun getFamilyName() = ""Make primary constructor parameter a property""
+    override fun getText() = ""Make primary constructor parameter '${element.name}' a property""","In the case when we're updating an outer class, it'd be better to show the name of that class in the inspection text.
",I don't think you need to override this method.
374,"@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.load.java
+
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.search.DelegatingGlobalSearchScope
+import com.intellij.psi.search.GlobalSearchScope
+import org.jetbrains.kotlin.idea.KotlinFileType
+import javax.inject.Inject
+
+abstract class AbstractJavaClassFinder : JavaClassFinder {
+
+    protected lateinit var proj: Project",Please rename to `project`,Why do we need this abstract class?
375,"@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.FqName
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+
+open class SymbolBasedType<out T : TypeMirror>(val typeMirror: T,
+                                               val javac: JavacWrapper) : JavaType, JavaAnnotationOwner {
+
+    companion object {
+        fun <TM : TypeMirror> create(t: TM, javac: JavacWrapper) = when {
+            t.kind.isPrimitive || t.toString() == ""void"" -> SymbolBasedPrimitiveType(t, javac)",`t.kind.isPrimitive || t.kind == TypeKind.VOID -> ...`,I don't think we need the `when` keyword here.
376,"@@ -0,0 +1,55 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotationOwner
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.FqName
+
+abstract class JCType<out T : JCTree>(val tree: T,
+                                      val treePath: TreePath,
+                                      val javac: JavacWrapper) : JavaType, JavaAnnotationOwner {
+
+    companion object {
+        fun <Type : JCTree> create(tree: Type, treePath: TreePath, javac: JavacWrapper) = when (tree) {
+            is JCTree.JCPrimitiveTypeTree -> JCPrimitiveType(tree, TreePath(treePath, tree), javac)
+            is JCTree.JCArrayTypeTree -> JCArrayType(tree, TreePath(treePath, tree), javac)
+            is JCTree.JCWildcard -> JCWildcardType(tree, TreePath(treePath, tree), javac)
+            is JCTree.JCTypeApply -> JCClassifierTypeWithTypeArgument(tree, TreePath(treePath, tree), javac)
+            is JCTree.JCExpression -> JCClassifierType(tree, TreePath(treePath, tree), javac)
+            else -> throw UnsupportedOperationException(""Unsupported type: $tree"")
+        }
+    }
+
+    override val annotations
+        get() = emptyList<JCAnnotation>()",Are you sure this list should be empty? In `JavaTypeImpl` it's not so,I think it would be better to use `java.lang.Ty
377,"@@ -0,0 +1,55 @@
+package test
+
+public final annotation class AByte : kotlin.Annotation {
+    public constructor AByte(/*0*/ kotlin.Byte)
+    public final val value: kotlin.Byte
+}
+
+public final annotation class AChar : kotlin.Annotation {
+    public constructor AChar(/*0*/ kotlin.Char)
+    public final val value: kotlin.Char
+}
+
+public final annotation class ADouble : kotlin.Annotation {
+    public constructor ADouble(/*0*/ kotlin.Double)
+    public final val value: kotlin.Double
+}
+
+public final annotation class AFloat : kotlin.Annotation {
+    public constructor AFloat(/*0*/ kotlin.Float)
+    public final val value: kotlin.Float
+}
+
+public final annotation class AInt : kotlin.Annotation {
+    public constructor AInt(/*0*/ kotlin.Int)
+    public final val value: kotlin.Int
+}
+
+public final annotation class ALong : kotlin.Annotation {
+    public constructor ALong(/*0*/ kotlin.Long)
+    public final val value: kotlin.Long
+}
+
+public final annotation class AString : kotlin.Annotation {
+    public constructor AString(/*0*/ kotlin.String)
+    public final val value: kotlin.String
+}
+
+@test.AString(value = ""Test"") @test.AChar(value = \u0063 ('c')) @test.AInt(value = 10) @test.AByte(value = 11.toByte()) @test.ALong(value = 12.toLong()) @test.ADouble(value = 1.2.toDouble()) @test.AFloat(value = 1.3.toFloat()) public open class AnnotationClass {","Why is there `@test.AByte(value = 11.toByte())`, but only `@test.AByte(value = 11)` in the main test data, is worth investigating, I think. Loading annotation arguments with different types than what is done now might break some invariants in the compiler",I think it would be better to use `@kotlin.Anno
378,"@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)","Obviously, won't work for `else`
",I think this should be `JetPsiExpression`
379,"@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$conditionText' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyElement = when (element) {","""bodyNode"" would be a better name
",Please add a new line after this line.
380,"@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$conditionText' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyElement = when (element) {
+            is JetIfExpression -> element.getNode().findChildByType(JetNodeTypes.THEN)
+            else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+        }
+        val bodyText = bodyElement?.getText()
+        val newElement = bodyElement?.getPsi()?.getPrevSibling()?.replace(JetPsiFactory.createExpression(element.getProject(), ""{\n $bodyText \n}""))","You are replace element before expression with block, and then add whitespace. Why not replace expression with block directly? Also, this works incorrectly for `if (true)println()`
",Please add a new line after this line.
381,"@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$conditionText' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyElement = when (element) {
+            is JetIfExpression -> element.getNode().findChildByType(JetNodeTypes.THEN)
+            else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+        }
+        val bodyText = bodyElement?.getText()
+        val newElement = bodyElement?.getPsi()?.getPrevSibling()?.replace(JetPsiFactory.createExpression(element.getProject(), ""{\n $bodyText \n}""))
+        newElement?.getParent()?.addBefore(JetPsiFactory.createWhiteSpace(element.getProject()), newElement)
+        bodyElement?.getPsi()?.delete()","Am I right that this sequence of safe calls is only because bodyElement can be null? Shouldn't it be checked in `isApplicable`? Otherwise there can be case when intention is available i UI, but will have no effect, which is confusing.
Side note: if some condition is to hard to check in isApplicable, it's a good idea to show error message.
",Please add a new line after this line.
382,"@@ -0,0 +1,57 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }","Duplicate code.
",I don't think you need the `else` here.
383,"@@ -0,0 +1,57 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)
+        if (jetBlockElement == null) return false
+
+        if (jetBlockElement.getStatements().size == 1) {
+            setText(""Remove braces from '$conditionText' statement"")
+            return true
+        }
+        return false
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val jetBlockElement = element.findBlockInExpression(element)
+        val newElement = jetBlockElement?.replace(JetPsiFactory.createExpression(element.getProject(), jetBlockElement?.getStatements()?.first?.getText()))","Safe call is redundant: we already checked for null in `isApplicable`.
",I think this should be `remove.braces`
384,"@@ -0,0 +1,57 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        val conditionText = when (element) {
+            is JetIfExpression -> ""if""
+            is JetWhileExpression -> ""while""
+            is JetDoWhileExpression -> ""do...while""
+            is JetForExpression -> ""for""
+            else -> return false
+        }
+        val jetBlockElement = element.findBlockInExpression(element)
+        if (jetBlockElement == null) return false
+
+        if (jetBlockElement.getStatements().size == 1) {
+            setText(""Remove braces from '$conditionText' statement"")
+            return true
+        }
+        return false
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val jetBlockElement = element.findBlockInExpression(element)
+        val newElement = jetBlockElement?.replace(JetPsiFactory.createExpression(element.getProject(), jetBlockElement?.getStatements()?.first?.getText()))
+        if (element is JetDoWhileExpression) {
+            newElement?.getParent()?.addAfter(JetPsiFactory.createNewLine(element.getProject()), newElement)
+        }","Redundant safe calls again
",I think this should be `remove.braces`
385,"@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi
+
+import java.rmi.Remote
+import java.rmi.RemoteException
+
+public interface CompileService : Remote {
+
+    public enum class OutputFormat : java.io.Serializable {
+        PLAIN,
+        XML
+    }
+
+    public interface RemoteIncrementalCache : Remote {
+        throws(RemoteException::class)","Do we really need all those `throws` annotations?
",Why do we need this interface?
386,"@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiNameIdentifierOwner
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.idea.core.deleteElementAndCleanParent
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
+
+/**",Please don't add `@author` tags to the code,I don't think we need this file.
387,"@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiNameIdentifierOwner
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.idea.core.deleteElementAndCleanParent
+import org.jetbrains.kotlin.psi.KtDeclaration
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtProperty
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
+
+/**
+ * @author Andrius Semionovas
+ * @since 2017-07-31
+ */
+class ReplaceInitializerWithGetterFix(element: KtProperty): KotlinQuickFixAction<KtProperty>(element) {",We already have `ConvertPropertyInitializerToGetterIntention` which is offered as an intention action in this context; you should be able to reuse it directly.,I don't think we need the `@author` ta
388,"@@ -0,0 +1,58 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaMember
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.Element
+import javax.lang.model.element.TypeElement
+
+abstract class SymbolBasedMember<out T : Element>(element: T,
+                                                  javac: JavacWrapper) : SymbolBasedElement<T>(element, javac), JavaMember {
+
+    override val containingClass
+        get() = SymbolBasedClass((element.enclosingElement as TypeElement), javac)
+
+    override val annotations
+        get() = element.annotationMirrors
+                .map { SymbolBasedAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName) = element.annotationMirrors
+            .find { it.toString() == ""@${fqName.asString()}"" }","Please deduplicate this with `SymbolBasedClassifier.findAnnotation`, `SymbolBasedValueParameter.findAnnotation`, `SymbolBasedType.findAnnotation`",I don't think we need the `out` parame
389,"@@ -0,0 +1,59 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.psi.KtAnnotationEntry
+import org.jetbrains.kotlin.psi.KtCallableDeclaration
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+
+class MoveReceiverAnnotationFix(element: KtAnnotationEntry) : KotlinQuickFixAction<KtAnnotationEntry>(element) {
+
+    override fun getFamilyName() = ""Move annotation to receiver type""
+    override fun getText() = familyName
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val element = element ?: return
+
+        val declaration = element.getParentOfType<KtCallableDeclaration>(true) ?: return
+        val receiverTypeRef = declaration.receiverTypeReference ?: return
+
+        receiverTypeRef.addAnnotationEntry(element)
+        element.delete()
+    }
+
+    companion object Factory : KotlinSingleIntentionActionFactory() {
+        override fun createAction(diagnostic: Diagnostic): IntentionAction? {
+            val diag = Errors.INAPPLICABLE_RECEIVER_TARGET.cast(diagnostic)
+            val entry = diag.psiElement as? KtAnnotationEntry ?: return null
+
+            val declaration = entry.getParentOfType<KtCallableDeclaration>(true) ?: return null
+            if (declaration.receiverTypeReference == null) return null
+
+            return MoveReceiverAnnotationFix(entry)
+        }
+    }
+}
+
+fun String.foo() {",Looks like not-deleted trash. I'll remove it.,I don't think you need the `?:` here.
390,"@@ -0,0 +1,59 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.name.Name
+
+class JCMethod<out T : JCTree.JCMethodDecl>(tree: T,
+                                            treePath: TreePath,
+                                            containingClass: JavaClass,
+                                            javac: JavacWrapper) : JCMember<T>(tree, treePath, containingClass, javac), JavaMethod {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract",What about interface members? (not sure it's important),I think it would be better to use `Nam
391,"@@ -0,0 +1,6 @@
+// ""Add 'run' before the lambda expression"" ""true""
+// ERROR: Unresolved reference: run","You can add WITH_RUNTIME directive so that the `run` function will be resolved correctly.
",
392,"@@ -0,0 +1,6 @@
+// ""Remove useless is check"" ""false""
+fun foo(a: String) {
+    when (1) {
+        <caret>is Int -> { }","Well, it's an exceptional case but here we can also do something :). If a condition in when branch is definitely true, we can replace the condition with `else` and delete all subsequent branches because they are unreachable anyway. If the condition is definitely false (add test for this case), we can delete this when branch.",I think this should be `<caret>`
393,"@@ -0,0 +1,6 @@
+// WITH_RUNTIME
+// IS_APPLICABLE: true
+
+fun Int.foo() {
+    +1","This transformation does not look correct for me. I would expect `this + 1` as a result here,
",Why is this needed?
394,"@@ -0,0 +1,6 @@
+//ERROR: Unresolved reference: SortedMap
+fun a(b: SortedMap<Int, String>) {
+    for ((index, c) in b.withIndices()) {","I'm not sure what's happening here because `SortedMap` is not an iterable/stream/array, so it doesn't have `withIndices` extension and the intention should not be applicable on it as well as on `Map`
",
395,"@@ -0,0 +1,6 @@
+public class Foo {
+    private native final void nativeMethod()","Please avoid irrelevant syntax errors in testdata. Java does require semicolons :)
",
396,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.Name
+
+class JCMethod<out T : JCTree.JCMethodDecl>(tree: T,
+                                            treePath: TreePath,
+                                            containingClass: JavaClass,
+                                            javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaMethod {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())",This can be extracted into `JCMember`,I don't think we need this class.
397,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.Name
+
+class JCMethod<out T : JCTree.JCMethodDecl>(tree: T,
+                                            treePath: TreePath,
+                                            containingClass: JavaClass,
+                                            javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaMethod {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract","Non-static methods in interface are `abstract` by default. However in Java 1.8+ they are not abstract if `default` modifier exists. Here we have complex logic, so be accurate, please.",I think it would be better to use `Nam
398,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.Name
+
+class JCMethod<out T : JCTree.JCMethodDecl>(tree: T,
+                                            treePath: TreePath,
+                                            containingClass: JavaClass,
+                                            javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaMethod {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal",I think interface methods are never `final`,I don't think we need to override thes
399,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.load.java.structure.JavaType
+import org.jetbrains.kotlin.name.Name
+
+class JCMethod<out T : JCTree.JCMethodDecl>(tree: T,
+                                            treePath: TreePath,
+                                            containingClass: JavaClass,
+                                            javac: Javac) : JCMember<T>(tree, treePath, containingClass, javac), JavaMethod {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = tree.modifiers.isStatic
+
+    override val isFinal
+        get() = tree.modifiers.isFinal
+
+    override val visibility",This can be extracted into `JCMember`,I don't think we need to override thes
400,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.project.ProjectStructureUtil
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.idea.util.findAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+
+private val annotationFqName = FqName(""kotlin.jvm.JvmOverloads"")
+
+class AddJvmOverloadsIntention : SelfTargetingIntention<KtParameterList>(
+        KtParameterList::class.java, ""Add '@JvmOverloads' annotation""","I think that all intentions that modify the declaration of a function need to be available on the function name. Showing this only on the parameter list is confusing
",I don't think we need this.
401,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.project.ProjectStructureUtil
+import org.jetbrains.kotlin.idea.util.addAnnotation
+import org.jetbrains.kotlin.idea.util.findAnnotation
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.*
+
+private val annotationFqName = FqName(""kotlin.jvm.JvmOverloads"")
+
+class AddJvmOverloadsIntention : SelfTargetingIntention<KtParameterList>(
+        KtParameterList::class.java, ""Add '@JvmOverloads' annotation""
+), LowPriorityAction {
+
+    override fun isApplicableTo(element: KtParameterList, caretOffset: Int): Boolean {
+        val parent = element.parent as? KtModifierListOwner ?: return false
+        val target = when (parent) {
+            is KtNamedFunction -> ""function '${parent.name}'""
+            is KtPrimaryConstructor -> ""primary constructor""
+            is KtSecondaryConstructor -> ""secondary constructor""
+            else -> return false
+        }
+        text = ""Add '@JvmOverloads' annotation to $target""
+
+        return !ProjectStructureUtil.isJsKotlinModule(element.getContainingKtFile())","If a constructor has one parameter with a default value, adding @JvmOverloads won't modify the resulting bytecode in any way, so the intention shouldn't be displayed.
",I think this should be `KtM
402,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.KtWhenExpression
+import org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression
+
+class WhenWithOnlyElseInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitWhenExpression(expression: KtWhenExpression) {
+                super.visitWhenExpression(expression)",You don't actually need the `super` call here.,I don't think we need the `
403,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.KtWhenExpression
+import org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression
+
+class WhenWithOnlyElseInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitWhenExpression(expression: KtWhenExpression) {
+                super.visitWhenExpression(expression)
+
+                val singleEntry = expression.entries.singleOrNull()
+                if (singleEntry?.isElse != true) return
+
+                val usedAsExpression = expression.isUsedAsExpression(expression.analyze())
+
+                holder.registerProblem(expression,
+                                       ""'when' has only 'else' branch and can be simplified"",
+                                       SimplifyFix(usedAsExpression)
+                )
+            }
+        }
+    }
+
+    private class SimplifyFix(
+            private val isUsedAsExpression: Boolean
+    ) : LocalQuickFix {
+        override fun getFamilyName() = name
+
+        override fun getName() = ""Simplify expression""
+
+        override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+            val whenExpression = descriptor.psiElement as? KtWhenExpression ?: return",Please don't forget `FileModificationService.getInstance().preparePsiElementForWrite()`,I don't think we need the `
404,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.JavaVisibilities
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.*
+
+val Element.isAbstract",Please mark such declarations as `internal` (those that are only used from this module). Also in the other `utils.kt`,I don't think we need this 
405,"@@ -0,0 +1,61 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.JavaVisibilities
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.*
+
+val Element.isAbstract
+    get() = modifiers.contains(Modifier.ABSTRACT)
+
+val Element.isStatic
+    get() = modifiers.contains(Modifier.STATIC)
+
+val Element.isFinal
+    get() = modifiers.contains(Modifier.FINAL)
+
+fun Element.getVisibility() = when {
+    Modifier.PUBLIC in modifiers -> Visibilities.PUBLIC
+    Modifier.PRIVATE in modifiers -> Visibilities.PRIVATE
+    Modifier.PROTECTED in modifiers -> {
+        if (Modifier.STATIC in modifiers) {
+            JavaVisibilities.PROTECTED_STATIC_VISIBILITY
+        }
+        else {
+            JavaVisibilities.PROTECTED_AND_PACKAGE
+        }
+    }
+    else -> JavaVisibilities.PACKAGE_VISIBILITY
+}
+
+fun TypeElement.computeClassId(): ClassId? {
+    if (enclosingElement.kind != ElementKind.PACKAGE) {
+        val parentClassId = (enclosingElement as TypeElement).computeClassId() ?: return null
+        return parentClassId.createNestedClassId(Name.identifier(simpleName.toString()))
+    }
+
+    return ClassId.topLevel(FqName(qualifiedName.toString()))
+}
+
+fun ExecutableElement.valueParameters(javac: JavacWrapper) = parameters.mapIndexed { index, it ->
+    SymbolBasedValueParameter(it, it.simpleName.toString(), (index == parameters.size - 1) && isVarArgs, javac)",`index == parameters.lastIndex`,I don't think we need `when
406,"@@ -0,0 +1,63 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard
+
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.collectDescendantsOfType
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+
+class ConcatenatedStringGenerator {
+    fun create(element: KtBinaryExpression): String {
+        val binaryExpression = getBinaryParentExpression(element)
+        val stringBuilder = StringBuilder()
+        create(binaryExpression, stringBuilder)
+        return stringBuilder.toString()
+    }
+
+    private fun getBinaryParentExpression(element: KtBinaryExpression): KtBinaryExpression {
+        var binaryExpression = element.getStrictParentOfType<KtBinaryExpression>() ?: return element","There is `getTopmostParentOfTypes`, I think it should work here
",Why do we need this class? 
407,"@@ -0,0 +1,63 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard
+
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.collectDescendantsOfType
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+
+class ConcatenatedStringGenerator {
+    fun create(element: KtBinaryExpression): String {
+        val binaryExpression = getBinaryParentExpression(element)
+        val stringBuilder = StringBuilder()
+        create(binaryExpression, stringBuilder)
+        return stringBuilder.toString()
+    }
+
+    private fun getBinaryParentExpression(element: KtBinaryExpression): KtBinaryExpression {
+        var binaryExpression = element.getStrictParentOfType<KtBinaryExpression>() ?: return element
+        while (binaryExpression != null) {
+            binaryExpression = binaryExpression.getStrictParentOfType<KtBinaryExpression>() ?: return element
+        }
+        return element
+    }
+
+    private fun create(element: KtBinaryExpression, sb: StringBuilder) {","I'd declare it as something like `private fun KtBinaryExpression.appendTo(sb: StringBuilder)`. And the same for the next function.
",I don't think you need the 
408,"@@ -0,0 +1,63 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.IntentionWrapper
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.AddNamesToCallArgumentsIntention
+import org.jetbrains.kotlin.psi.KtCallExpression
+import org.jetbrains.kotlin.psi.KtNameReferenceExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.referenceExpression
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.DataClassDescriptorResolver
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class CopyWithoutNamedArgumentsInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitCallExpression(expression: KtCallExpression) {
+                super.visitCallExpression(expression)
+
+                val reference = expression.referenceExpression() as? KtNameReferenceExpression ?: return
+                if (reference.getReferencedNameAsName() != DataClassDescriptorResolver.COPY_METHOD_NAME) return
+                if (expression.valueArguments.none { !it.isNamed() }) return",`.all { it.isNamed() }` is easier to read.,I don't think we need the `
409,"@@ -0,0 +1,64 @@
+# Enums
+
+Goals:
+* Better syntax for passing constructor parameters when defining enum constants
+* Resolve issues with annotation syntax for enum constants
+
+## Example
+
+Simple enum:
+``` kotlin
+enum class Foo {
+    A
+    B
+    C {
+        override fun foo() { ... }
+    }
+  
+    open fun foo() {}
+}
+```
+
+Enum with constructor:
+``` kotlin
+enum class Foo(val s: String) {
+    A(""a"")
+    B(""b"")
+    C(""c"") {
+        override fun foo() { ... }
+    }
+  
+    open fun foo() {}
+}
+```
+
+Issues
+* Enum literals syntax clash with annotation syntax
+    * Option 1.1: Forbid short annotation syntax in enums. **downside**: cannot annotate functions/properties/classes in this enum
+    * Option 1.2: Add a separator between enum constants and members, and forbid short annotation syntax only on enum entriesc themselves. **downside**: separator is not intuitive, hard to think of when doign this for the first time (the error message will be rather clear and instructive, though)","Spelling: doign -> doing
",`val` is not used.
410,"@@ -0,0 +1,64 @@
+# Enums
+
+Goals:
+* Better syntax for passing constructor parameters when defining enum constants
+* Resolve issues with annotation syntax for enum constants
+
+## Example
+
+Simple enum:
+``` kotlin
+enum class Foo {
+    A
+    B
+    C {
+        override fun foo() { ... }
+    }
+  
+    open fun foo() {}
+}
+```
+
+Enum with constructor:
+``` kotlin
+enum class Foo(val s: String) {
+    A(""a"")
+    B(""b"")
+    C(""c"") {
+        override fun foo() { ... }
+    }
+  
+    open fun foo() {}
+}
+```
+
+Issues
+* Enum literals syntax clash with annotation syntax
+    * Option 1.1: Forbid short annotation syntax in enums. **downside**: cannot annotate functions/properties/classes in this enum
+    * Option 1.2: Add a separator between enum constants and members, and forbid short annotation syntax only on enum entriesc themselves. **downside**: separator is not intuitive, hard to think of when doing this for the first time (the error message will be rather clear and instructive, though)
+    * Option 1.3: prefix each entry with a soft-keyword, e.g. `entry`. **downside**: verbosity
+* How do we specify other supertypes for a constant (if any)
+    * Option 2.1: Leave unsupported, use cases are very few, and Java does not support it
+    * Option 2.2: `A(""s""): OtherType`
+
+Example for option 1.2:
+
+``` kotlin
+enum class Foo(val s: String) {
+    A(""a"") // semicolon CAN NOT be used here!
+    B(""b"")
+    C(""c"") {
+        override fun foo() { ... }
+    }; // semicolon is MANDATORY here, if a member follows
+  
+    // if no semicolon was provided, `open` is another enum entry
+    open fun foo() {}
+}
+```
+
+Notes:
+* No overhead in the most common case of no members at all: `enum class E {A B C}","Missing backtick?
",I don't think this is true.
411,"@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.openapi.vfs.LocalFileSystem;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.testFramework.PsiTestUtil;
+import org.jetbrains.jet.JetTestCaseBuilder;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class FinalJavaSupertypeTest extends JetQuickFixMultiFileTest {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        String path = getTestDataPath();
+        VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);
+        if (virtualFile != null) {
+            virtualFile.getChildren();
+            virtualFile.refresh(false, true);
+        }","This piece of code occurs at least three times in the code base, it probably means that we should create a utility method for it.
",I don't think this is neede
412,"@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.openapi.vfs.LocalFileSystem;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiDocumentManager;
+import com.intellij.testFramework.PsiTestUtil;
+import org.jetbrains.jet.JetTestCaseBuilder;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class FinalJavaSupertypeTest extends JetQuickFixMultiFileTest {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        String path = getTestDataPath();
+        VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);
+        if (virtualFile != null) {
+            virtualFile.getChildren();
+            virtualFile.refresh(false, true);
+        }
+    }
+
+    public void testFinalJavaSupertype() throws Exception {
+        String path = getTestDataPath() + ""/../javaCode/"";
+        final VirtualFile rootDir = PsiTestUtil.createTestProjectStructure(myProject, myModule, path, myFilesToDelete, false);
+        addSourceContentToRoots(myModule, rootDir);
+        PsiDocumentManager.getInstance(myProject).commitAllDocuments();
+        doTest();
+    }
+
+    @Override
+    protected String getCheckFileName() {
+        assert false;","It's a lot better to explicitly throw an exception here + provide a comprehensible message that tells me why this behavior is not legitimate
",Why is this assert false?
413,"@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.psi.*
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    val patterns = mapOf(
+            ""System.out.println($0)"" to ""println($0)"",
+            ""System.out.print($0)"" to ""print($0)"",
+            ""Collections.sort($0)"" to ""$0.sort()""
+    )
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
+                super.visitQualifiedExpression(expression)
+
+                val selectorExpression = expression.selectorExpression ?: return
+                if (selectorExpression !is KtCallExpression) return
+                if (selectorExpression.valueArguments.size != 1) return
+                val value = selectorExpression.valueArguments[0].text
+                val pattern = expression.text.replace(value, ""$0"")","This is not good enough. You need to resolve the call to make sure that it points to the correct method, and not to a method of a different class that also happens to be called `Collections`.
",I don't think we need this 
414,"@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.psi.*
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    val patterns = mapOf(
+            ""System.out.println($0)"" to ""println($0)"",
+            ""System.out.print($0)"" to ""print($0)"",
+            ""Collections.sort($0)"" to ""$0.sort()""
+    )
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
+                super.visitQualifiedExpression(expression)
+
+                val selectorExpression = expression.selectorExpression ?: return
+                if (selectorExpression !is KtCallExpression) return
+                if (selectorExpression.valueArguments.size != 1) return
+                val value = selectorExpression.valueArguments[0].text
+                val pattern = expression.text.replace(value, ""$0"")
+                if (!patterns.containsKey(pattern)) return
+
+                holder.registerProblem(expression,
+                                       ""Unnecessary java usage"",
+                                       ProblemHighlightType.LIKE_UNUSED_SYMBOL,","LIKE_UNUSED_SYMBOL highlighting is applied to code fragments that can be removed entirely. In this case, the quick fix is not removing the code, but is replacing it with different code.
",I don't think we need this 
415,"@@ -0,0 +1,64 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.codeInsight.intention.LowPriorityAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.core.moveCaret
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.createExpressionByPattern
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameOrNull
+
+class SwapStringEqualsIgnoreCaseIntention : SelfTargetingRangeIntention<KtDotQualifiedExpression>(KtDotQualifiedExpression::class.java, ""Flip 'equals'""), LowPriorityAction {
+
+    override fun applicabilityRange(element: KtDotQualifiedExpression): TextRange? {
+        val descriptor = element.getCallableDescriptor() ?: return null
+
+        val fqName: FqName = descriptor.fqNameOrNull() ?: return null
+        if (fqName.asString() != ""kotlin.text.equals"") return null
+
+        val valueParameters = descriptor.valueParameters.takeIf { it.size == 2 } ?: return null
+        if (!KotlinBuiltIns.isStringOrNullableString(valueParameters[0].type)) return null
+        if (!KotlinBuiltIns.isBoolean(valueParameters[1].type)) return null
+
+        return element.callExpression?.calleeExpression?.textRange
+    }
+
+    override fun applyTo(element: KtDotQualifiedExpression, editor: Editor?) {
+        val callExpression = element.callExpression ?: return
+        val offset = (editor?.caretModel?.offset ?: 0) - (callExpression.calleeExpression?.startOffset ?: 0)
+        val receiverExpression = element.receiverExpression
+        val valueArguments = callExpression.valueArguments.takeIf { it.size == 2 } ?: return
+        val newElement = KtPsiFactory(element).createExpressionByPattern(
+                ""$0.equals($1, $2)"",
+                valueArguments[0].text,",It's better to use here expressions and not their text,I don't think we need to ov
416,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.kotlin.lexer.KtTokens.*
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class ConvertClassToSealedClassIntention : SelfTargetingRangeIntention<KtClass>(KtClass::class.java, ""Convert to sealed class"") {
+
+    override fun applicabilityRange(element: KtClass): TextRange? {
+        if (element.modifierList == null) return null
+        if (!element.hasModifier(OPEN_KEYWORD) && !element.hasModifier(ABSTRACT_KEYWORD)) return null
+
+        val constructors = listOfNotNull(element.primaryConstructor) + element.secondaryConstructors
+        if (constructors.isEmpty()) return null
+        if (constructors.any { !it.hasModifier(PRIVATE_KEYWORD) }) return null",Please use `none` instead of `any` with a negative condition.,I don't think we need to check for `OPEN_KEYWORD` and `ABSTRACT_KEYWORD` here.
417,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.kotlin.lexer.KtTokens.*
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class ConvertClassToSealedClassIntention : SelfTargetingRangeIntention<KtClass>(KtClass::class.java, ""Convert to sealed class"") {
+
+    override fun applicabilityRange(element: KtClass): TextRange? {
+        if (element.modifierList == null) return null
+        if (!element.hasModifier(OPEN_KEYWORD) && !element.hasModifier(ABSTRACT_KEYWORD)) return null
+
+        val constructors = listOfNotNull(element.primaryConstructor) + element.secondaryConstructors
+        if (constructors.isEmpty()) return null
+        if (constructors.any { !it.hasModifier(PRIVATE_KEYWORD) }) return null
+
+        val nameIdentifier = element.nameIdentifier ?: return null
+        return TextRange(element.startOffset, nameIdentifier.endOffset)
+    }
+
+    override fun applyTo(element: KtClass, editor: Editor?) {
+        val newElement = element.copy() as KtClass",It doesn't seem necessary to create a copy; you should be able to apply all the changes to the original `KtClass` directly.,I don't think we need to override `applyTo` here.
418,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.kotlin.lexer.KtTokens.*
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class ConvertClassToSealedClassIntention : SelfTargetingRangeIntention<KtClass>(KtClass::class.java, ""Convert to sealed class"") {
+
+    override fun applicabilityRange(element: KtClass): TextRange? {
+        if (element.modifierList == null) return null
+        if (!element.hasModifier(OPEN_KEYWORD) && !element.hasModifier(ABSTRACT_KEYWORD)) return null
+
+        val constructors = listOfNotNull(element.primaryConstructor) + element.secondaryConstructors
+        if (constructors.isEmpty()) return null
+        if (constructors.any { !it.hasModifier(PRIVATE_KEYWORD) }) return null
+
+        val nameIdentifier = element.nameIdentifier ?: return null
+        return TextRange(element.startOffset, nameIdentifier.endOffset)
+    }
+
+    override fun applyTo(element: KtClass, editor: Editor?) {
+        val newElement = element.copy() as KtClass
+
+        newElement.modifierList?.run {
+            getModifier(OPEN_KEYWORD)?.delete()
+            getModifier(ABSTRACT_KEYWORD)?.delete()
+            newElement.addModifier(SEALED_KEYWORD)",It's better to move this line out of the `run` block.,I don't think we need to override `applyTo` here.
419,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.kotlin.lexer.KtTokens.*
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class ConvertClassToSealedClassIntention : SelfTargetingRangeIntention<KtClass>(KtClass::class.java, ""Convert to sealed class"") {
+
+    override fun applicabilityRange(element: KtClass): TextRange? {
+        if (element.modifierList == null) return null
+        if (!element.hasModifier(OPEN_KEYWORD) && !element.hasModifier(ABSTRACT_KEYWORD)) return null
+
+        val constructors = listOfNotNull(element.primaryConstructor) + element.secondaryConstructors
+        if (constructors.isEmpty()) return null
+        if (constructors.any { !it.hasModifier(PRIVATE_KEYWORD) }) return null
+
+        val nameIdentifier = element.nameIdentifier ?: return null
+        return TextRange(element.startOffset, nameIdentifier.endOffset)
+    }
+
+    override fun applyTo(element: KtClass, editor: Editor?) {
+        val newElement = element.copy() as KtClass
+
+        newElement.modifierList?.run {
+            getModifier(OPEN_KEYWORD)?.delete()
+            getModifier(ABSTRACT_KEYWORD)?.delete()
+            newElement.addModifier(SEALED_KEYWORD)
+        }
+
+        newElement.primaryConstructor?.run {
+            modifierList?.getModifier(PRIVATE_KEYWORD)?.delete()
+            getConstructorKeyword()?.delete()",The `constructor` keyword can only be deleted if there are no annotations or other modifiers on the constructor. Please add a test for the case with annotations.,I don't think we need to override `applyTo` here.
420,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiWhiteSpace
+import org.jetbrains.kotlin.lexer.KtTokens.*
+import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+
+class ConvertClassToSealedClassIntention : SelfTargetingRangeIntention<KtClass>(KtClass::class.java, ""Convert to sealed class"") {
+
+    override fun applicabilityRange(element: KtClass): TextRange? {
+        if (element.modifierList == null) return null
+        if (!element.hasModifier(OPEN_KEYWORD) && !element.hasModifier(ABSTRACT_KEYWORD)) return null
+
+        val constructors = listOfNotNull(element.primaryConstructor) + element.secondaryConstructors
+        if (constructors.isEmpty()) return null
+        if (constructors.any { !it.hasModifier(PRIVATE_KEYWORD) }) return null
+
+        val nameIdentifier = element.nameIdentifier ?: return null
+        return TextRange(element.startOffset, nameIdentifier.endOffset)
+    }
+
+    override fun applyTo(element: KtClass, editor: Editor?) {
+        val newElement = element.copy() as KtClass
+
+        newElement.modifierList?.run {
+            getModifier(OPEN_KEYWORD)?.delete()
+            getModifier(ABSTRACT_KEYWORD)?.delete()
+            newElement.addModifier(SEALED_KEYWORD)
+        }
+
+        newElement.primaryConstructor?.run {
+            modifierList?.getModifier(PRIVATE_KEYWORD)?.delete()
+            getConstructorKeyword()?.delete()
+            if (newElement.secondaryConstructors.isEmpty() && valueParameters.isEmpty()) valueParameterList?.delete()
+            (newElement.nameIdentifier?.prevSibling as? PsiWhiteSpace)?.delete()",It should never be necessary to do that manually; the formatter should take care of whitespaces.,I don't think we need to override `applyTo` here.
421,"@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.javac
+
+import com.sun.tools.javac.util.Context
+import com.sun.tools.javac.util.Log
+import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
+import org.jetbrains.kotlin.cli.common.messages.GroupingMessageCollector
+import org.jetbrains.kotlin.cli.common.messages.MessageCollector
+import java.io.PrintWriter
+import java.io.Writer
+
+class JavacLogger(context: Context,
+               errorWriter: PrintWriter,
+               warningWriter: PrintWriter,
+               infoWriter: PrintWriter) : Log(context, errorWriter, warningWriter, infoWriter) {
+    init {
+        context.put(Log.outKey, infoWriter)
+    }
+
+    override fun printLines(kind: WriterKind, message: String, vararg args: Any?) {}
+
+    companion object {
+        fun preRegister(context: Context, messageCollector: MessageCollector) {
+            context.put(Log.logKey, Context.Factory<Log> {
+                JavacLogger(it,
+                            PrintWriter(MessageCollectorAdapter(messageCollector, CompilerMessageSeverity.ERROR)),
+                            PrintWriter(MessageCollectorAdapter(messageCollector, CompilerMessageSeverity.WARNING)),
+                            PrintWriter(MessageCollectorAdapter(messageCollector, CompilerMessageSeverity.INFO)))
+            })
+        }
+    }
+
+}
+
+private class MessageCollectorAdapter(private val messageCollector: MessageCollector,
+                                      private val severity: CompilerMessageSeverity) : Writer() {
+
+    override fun write(buffer: CharArray, offset: Int, length: Int) {
+        if (length > 1) {",Why? A comment would be helpful here,I don't think we need this class. It's only used in one place.
422,"@@ -0,0 +1,66 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.PropertyDescriptor
+import org.jetbrains.kotlin.load.java.components.JavaPropertyInitializerEvaluator
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.resolve.constants.ConstantValueFactory
+import org.jetbrains.kotlin.resolve.descriptorUtil.builtIns
+import org.jetbrains.kotlin.wrappers.symbols.JavacField
+import org.jetbrains.kotlin.wrappers.trees.JCClassifierType
+import org.jetbrains.kotlin.wrappers.trees.JCField
+import org.jetbrains.kotlin.wrappers.trees.JCPrimitiveType
+
+class JavacBasedPropertyInitializerEvaluator : JavaPropertyInitializerEvaluator {
+
+    override fun getInitializerConstant(field: JavaField, descriptor: PropertyDescriptor) = when (field) {
+        is JavacField<*> -> field.constant(descriptor)
+        is JCField<*> -> field.constant(descriptor)
+        else -> null
+    }
+
+    override fun isNotNullCompileTimeConstant(field: JavaField) = when(field) {
+        is JavacField<*> -> field.isCompileTimeConstant()
+        is JCField<*> -> field.isCompileTimeConstant()
+        else -> false
+    }
+
+    private fun JavacField<*>.constant(descriptor: PropertyDescriptor) = value?.let {
+        ConstantValueFactory(descriptor.builtIns).createConstantValue(it)
+    }
+
+    private fun JCField<*>.constant(descriptor: PropertyDescriptor) = value?.let {
+        if (isCompileTimeConstant() && it is JCTree.JCLiteral) {
+            ConstantValueFactory(descriptor.builtIns).createConstantValue(it.value)
+        } else null
+    }
+
+    private fun JavacField<*>.isCompileTimeConstant() = value?.let {
+        val typeMirror = type.typeMirror
+
+        (typeMirror.kind.isPrimitive || typeMirror.toString() == ""java.lang.String"")","It would be better to avoid `toString()` call here, if possible. Does this `typeMirror` have something like `name` or `fqName`?",I don't think we need to override this method.
423,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.impl.source.tree.LeafPsiElement;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class RemoveSpreadFix extends JetIntentionAction<LeafPsiElement>{
+    private final LeafPsiElement spreadSign;
+
+    public RemoveSpreadFix(@NotNull LeafPsiElement element) {
+        super(element);
+        spreadSign = element;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""remove.spread.sign"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""remove.spread.sign"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        spreadSign.delete();
+    }
+
+    public static JetIntentionActionFactory createFactory() {
+        return new JetIntentionActionFactory() {
+            @Override
+            public JetIntentionAction<LeafPsiElement> createAction(Diagnostic diagnostic) {
+                PsiElement element = diagnostic.getPsiElement();
+                if (!(element instanceof LeafPsiElement)) return null;","Almost right, but here's the way to do it without constant:

```
if (leaf instanceof LeafPsiElement && ((LeafPsiElement)leaf).getElementType() == JetTokens.MUL) {
}
```
",I don't think you need to override this.
424,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.functors
+
+import org.jetbrains.kotlin.effectsystem.impls.or
+import org.jetbrains.kotlin.effectsystem.factories.lift
+import org.jetbrains.kotlin.effectsystem.structure.*
+
+/**
+ * Applies [operation] to [first] and [second] if both not-null, otherwise returns null
+ */
+internal fun <F, S, R> applyIfBothNotNull(first: F?, second: S?, operation: (F, S) -> R): R? =
+        if (first == null || second == null) null else operation(first, second)
+
+/**
+ * If both [first] and [second] are null, then return null
+ * If only one of [first] and [second] is null, then return other one
+ * Otherwise, return result of [operation]
+ */
+internal fun <F : R, S : R, R> applyWithDefault(first: F?, second: S?, operation: (F, S) -> R): R? = when {
+    first == null && second == null -> null
+    first == null -> second
+    second == null -> first
+    else -> operation(first, second)
+}
+
+internal fun foldConditionsWithOr(list: List<ESClause>): ESBooleanExpression? =
+        if (list.isEmpty())
+            null
+        else
+            list.map { it.condition }.reduce { acc, condition -> acc.or(condition) }
+
+/**
+ * Places all clauses that equal to `firstModel` into first list, and all clauses that equal to `secondModel` into second list
+ */
+internal fun List<ESClause>.strictPartition(firstModel: ESEffect, secondModel: ESEffect): Pair<List<ESClause>, List<ESClause>> {","May be it's better to return here just lists of conditions, not lists of clauses. Then you can accept list of conditions in `foldConditionsWithOr`.",I don't think we need the `.reduce` here.
425,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtParenthesizedExpression
+import org.jetbrains.kotlin.psi.KtPrefixExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import org.jetbrains.kotlin.types.typeUtil.isBoolean
+
+class DoubleNegationInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitPrefixExpression(expression: KtPrefixExpression) {
+                    if (expression.operationToken != KtTokens.EXCL || expression.baseExpression?.getType(expression.analyze())?.isBoolean() != true) {
+                        return
+                    }
+                    var parent = expression.parent
+                    while (parent is KtParenthesizedExpression) {
+                        parent = parent.parent
+                    }
+                    if (parent is KtPrefixExpression && parent.operationToken == KtTokens.EXCL) {
+                        holder.registerProblem(expression,
+                                               ""Redundant double negation"",
+                                               ProblemHighlightType.WEAK_WARNING,","For future: use here `GENERIC_ERROR_OR_WARNING` if you want to get highlight type depending on inspection severity level (by default, from plugin.xml, or configured by user). Explicitly given `WEAK_WARNING` enforces this severiry level making it unconfigurable by user (will fix myself).",I don't think we need the `isOnTheFly` parameter.
426,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.CleanupLocalInspectionTool
+import com.intellij.codeInspection.LocalInspectionToolSession
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import java.util.*
+
+class SuspiciousEqualsCombination : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                    if (expression.parent is KtBinaryExpression) return
+                    val (first, second) = expression.parseBinary()
+                    val eqeq = first.map { it.text }
+                    val eqeqeq = second.map { it.text }
+                    if (eqeq.fold(false) { acc, it -> acc || eqeqeq.contains(it) }) {
+                        holder.registerProblem(expression, ""Suspicious combination of == and ==="",
+                                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING)
+                    }
+                }
+            }
+
+    private fun KtBinaryExpression.parseBinary(pair: Pair<MutableList<KtExpression>, MutableList<KtExpression>>","I think the intent of this code will be much clearer if you used an explicit class instead of a Pair:

```
data class ComparisonOperands(val eqEqOperands: MutableList<KtExpression>, val eqEqEqOperands: MutableList<KtExpression>)",I don't think we need the `isOnTheFly` parameter.
427,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.CleanupLocalInspectionTool
+import com.intellij.codeInspection.LocalInspectionToolSession
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import java.util.*
+
+class SuspiciousEqualsCombination : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                    if (expression.parent is KtBinaryExpression) return
+                    val (first, second) = expression.parseBinary()
+                    val eqeq = first.map { it.text }
+                    val eqeqeq = second.map { it.text }
+                    if (eqeq.fold(false) { acc, it -> acc || eqeqeq.contains(it) }) {
+                        holder.registerProblem(expression, ""Suspicious combination of == and ==="",
+                                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING)
+                    }
+                }
+            }
+
+    private fun KtBinaryExpression.parseBinary(pair: Pair<MutableList<KtExpression>, MutableList<KtExpression>>
+                                               = Pair(LinkedList(), LinkedList())): Pair<MutableList<KtExpression>, MutableList<KtExpression>> {",Please don't use `LinkedList` for anything ever. :),I don't think we need the `isOnTheFly` parameter.
428,"@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.CleanupLocalInspectionTool
+import com.intellij.codeInspection.LocalInspectionToolSession
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import java.util.*
+
+class SuspiciousEqualsCombination : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                    if (expression.parent is KtBinaryExpression) return
+                    val (first, second) = expression.parseBinary()
+                    val eqeq = first.map { it.text }
+                    val eqeqeq = second.map { it.text }
+                    if (eqeq.fold(false) { acc, it -> acc || eqeqeq.contains(it) }) {
+                        holder.registerProblem(expression, ""Suspicious combination of == and ==="",
+                                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING)
+                    }
+                }
+            }
+
+    private fun KtBinaryExpression.parseBinary(pair: Pair<MutableList<KtExpression>, MutableList<KtExpression>>
+                                               = Pair(LinkedList(), LinkedList())): Pair<MutableList<KtExpression>, MutableList<KtExpression>> {
+        when (operationToken) {
+            KtTokens.EQEQ, KtTokens.EXCLEQ -> {
+                left?.let(pair.first::add)","I'd check that the operands are `KtNameReferenceExpression`'s, to make the behavior more predictable.",I don't think we need the `isOnTheFly` parameter.
429,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import java.util.*
+
+class RemoveRedundantCallsOfConversionMethodsInspection : IntentionBasedInspection<KtDotQualifiedExpression>(RemoveRedundantCallsOfConversionMethodsIntention::class)","I think these redundant calls should be highlighted as unused symbols.
",I don't think we need this.
430,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import java.util.*
+
+class RemoveRedundantCallsOfConversionMethodsInspection : IntentionBasedInspection<KtDotQualifiedExpression>(RemoveRedundantCallsOfConversionMethodsIntention::class)
+
+class RemoveRedundantCallsOfConversionMethodsIntention : SelfTargetingOffsetIndependentIntention<KtDotQualifiedExpression>(KtDotQualifiedExpression::class.java, ""Remove redundant calls of the conversion method"") {
+
+    private val targetClassMap = mapOf(""toList()"" to List::class.qualifiedName,
+                                       ""toSet()"" to Set::class.qualifiedName,
+                                       ""toMap()"" to Map::class.qualifiedName,
+                                       ""toMutableList()"" to ""kotlin.collections.MutableList"",
+                                       ""toMutableSet()"" to ""kotlin.collections.MutableSet"",
+                                       ""toMutableMap()"" to ""kotlin.collections.MutableMap"",
+                                       ""toSortedSet()"" to SortedSet::class.qualifiedName,
+                                       ""toSortedMap()"" to SortedMap::class.qualifiedName,
+                                       ""toString()"" to String::class.qualifiedName,
+                                       ""toDouble()"" to Double::class.qualifiedName,
+                                       ""toFloat()"" to Float::class.qualifiedName,
+                                       ""toLong()"" to Long::class.qualifiedName,
+                                       ""toInt()"" to Int::class.qualifiedName,
+                                       ""toChar()"" to Char::class.qualifiedName,
+                                       ""toShort()"" to Short::class.qualifiedName,
+                                       ""toByte()"" to Byte::class.qualifiedName)
+
+
+    override fun applyTo(element: KtDotQualifiedExpression, editor: Editor?) {
+        element.replaced(element.receiverExpression)
+
+        mutableMapOf(1 to 1).toMutableMap()","What is it? Looks like it's not needed here :)
",I don't think we need the `*` imports.
431,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import java.util.*
+
+class RemoveRedundantCallsOfConversionMethodsInspection : IntentionBasedInspection<KtDotQualifiedExpression>(RemoveRedundantCallsOfConversionMethodsIntention::class)
+
+class RemoveRedundantCallsOfConversionMethodsIntention : SelfTargetingOffsetIndependentIntention<KtDotQualifiedExpression>(KtDotQualifiedExpression::class.java, ""Remove redundant calls of the conversion method"") {
+
+    private val targetClassMap = mapOf(""toList()"" to List::class.qualifiedName,
+                                       ""toSet()"" to Set::class.qualifiedName,
+                                       ""toMap()"" to Map::class.qualifiedName,
+                                       ""toMutableList()"" to ""kotlin.collections.MutableList"",
+                                       ""toMutableSet()"" to ""kotlin.collections.MutableSet"",
+                                       ""toMutableMap()"" to ""kotlin.collections.MutableMap"",
+                                       ""toSortedSet()"" to SortedSet::class.qualifiedName,
+                                       ""toSortedMap()"" to SortedMap::class.qualifiedName,
+                                       ""toString()"" to String::class.qualifiedName,
+                                       ""toDouble()"" to Double::class.qualifiedName,
+                                       ""toFloat()"" to Float::class.qualifiedName,
+                                       ""toLong()"" to Long::class.qualifiedName,
+                                       ""toInt()"" to Int::class.qualifiedName,
+                                       ""toChar()"" to Char::class.qualifiedName,
+                                       ""toShort()"" to Short::class.qualifiedName,
+                                       ""toByte()"" to Byte::class.qualifiedName)
+
+
+    override fun applyTo(element: KtDotQualifiedExpression, editor: Editor?) {
+        element.replaced(element.receiverExpression)
+
+        mutableMapOf(1 to 1).toMutableMap()
+    }
+
+    override fun isApplicableTo(element: KtDotQualifiedExpression): Boolean {","Looks like we can apply this intention for all qualified expressions, not only unsafe ones.
",I don't think we need the `*` imports.
432,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection
+import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtStringTemplateExpression
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+import java.util.*
+
+class RemoveRedundantCallsOfConversionMethodsInspection : IntentionBasedInspection<KtDotQualifiedExpression>(RemoveRedundantCallsOfConversionMethodsIntention::class)
+
+class RemoveRedundantCallsOfConversionMethodsIntention : SelfTargetingOffsetIndependentIntention<KtDotQualifiedExpression>(KtDotQualifiedExpression::class.java, ""Remove redundant calls of the conversion method"") {
+
+    private val targetClassMap = mapOf(""toList()"" to List::class.qualifiedName,
+                                       ""toSet()"" to Set::class.qualifiedName,
+                                       ""toMap()"" to Map::class.qualifiedName,
+                                       ""toMutableList()"" to ""kotlin.collections.MutableList"",
+                                       ""toMutableSet()"" to ""kotlin.collections.MutableSet"",
+                                       ""toMutableMap()"" to ""kotlin.collections.MutableMap"",
+                                       ""toSortedSet()"" to SortedSet::class.qualifiedName,
+                                       ""toSortedMap()"" to SortedMap::class.qualifiedName,
+                                       ""toString()"" to String::class.qualifiedName,
+                                       ""toDouble()"" to Double::class.qualifiedName,
+                                       ""toFloat()"" to Float::class.qualifiedName,
+                                       ""toLong()"" to Long::class.qualifiedName,
+                                       ""toInt()"" to Int::class.qualifiedName,
+                                       ""toChar()"" to Char::class.qualifiedName,
+                                       ""toShort()"" to Short::class.qualifiedName,
+                                       ""toByte()"" to Byte::class.qualifiedName)
+
+
+    override fun applyTo(element: KtDotQualifiedExpression, editor: Editor?) {
+        element.replaced(element.receiverExpression)
+
+        mutableMapOf(1 to 1).toMutableMap()
+    }
+
+    override fun isApplicableTo(element: KtDotQualifiedExpression): Boolean {
+        val selectorExpressionText = element.selectorExpression?.text
+        val qualifiedName = targetClassMap[selectorExpressionText] ?: return false
+        val receiverExpression = element.receiverExpression
+        return when (receiverExpression) {
+            is KtStringTemplateExpression -> String::class.qualifiedName
+            is KtConstantExpression -> receiverExpression.getType(receiverExpression.analyze())?.getJetTypeFqName(false)
+            else -> receiverExpression.getResolvedCall(receiverExpression.analyze())?.candidateDescriptor?.returnType?.getJetTypeFqName(false)
+        } == qualifiedName","I'm not sure here what will be happened if somebody defines custom `toType()` function. Probably it's not too important, because it's expected that `toType()` has result of `Type` anyway.
",I don't think we need the `*` imports.
433,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.builtins.getReturnTypeFromFunctionType
+import org.jetbrains.kotlin.builtins.isExtensionFunctionType
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.KtTypeReference
+import org.jetbrains.kotlin.renderer.DescriptorRenderer
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+
+class ConvertExtensionToFunctionTypeFix(element: KtTypeReference, type: KotlinType) : KotlinQuickFixAction<KtTypeReference>(element) {
+
+    private val targetTypeStringShort = type.renderType(IdeDescriptorRenderers.SOURCE_CODE_SHORT_NAMES_IN_TYPES)
+    private val targetTypeStringLong = type.renderType(IdeDescriptorRenderers.SOURCE_CODE)
+
+    override fun getText() = ""Convert supertype to '$targetTypeStringShort'""
+    override fun getFamilyName() = ""Convert extension function type to regular function type.""","No period here please
",I don't think we need this import.
434,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.builtins.getReturnTypeFromFunctionType
+import org.jetbrains.kotlin.builtins.isExtensionFunctionType
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.KtTypeReference
+import org.jetbrains.kotlin.renderer.DescriptorRenderer
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+
+class ConvertExtensionToFunctionTypeFix(element: KtTypeReference, type: KotlinType) : KotlinQuickFixAction<KtTypeReference>(element) {
+
+    private val targetTypeStringShort = type.renderType(IdeDescriptorRenderers.SOURCE_CODE_SHORT_NAMES_IN_TYPES)
+    private val targetTypeStringLong = type.renderType(IdeDescriptorRenderers.SOURCE_CODE)
+
+    override fun getText() = ""Convert supertype to '$targetTypeStringShort'""
+    override fun getFamilyName() = ""Convert extension function type to regular function type.""
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val replaced = element.replaced(KtPsiFactory(project).createType(targetTypeStringLong))
+        ShortenReferences.DEFAULT.process(replaced)
+    }
+
+    private fun KotlinType.renderType(renderer: DescriptorRenderer) = buildString {
+        append('(')
+        arguments.dropLast(1).map { renderer.renderType(it.type) }.joinTo(this@buildString, "", "")","I'd add a test for more than one argument, and/or for type with type parameters
",I don't think we need this import.
435,"@@ -0,0 +1,69 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.CleanupLocalInspectionTool
+import com.intellij.codeInspection.LocalInspectionToolSession
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+
+class SuspiciousEqualsCombination : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                    if (expression.parent is KtBinaryExpression) return
+                    val operands = expression.parseBinary()
+                    val eqeq = operands.eqEqOperands.map { it.text }
+                    val eqeqeq = operands.eqEqEqOperands.map { it.text }
+                    if (eqeq.fold(false) { acc, it -> acc || eqeqeq.contains(it) }) {",This can actually be expressed as `eqeq.intersect(eqeqeq).isNotEmpty()`,I don't think you need the `isOnTheFly
436,"@@ -0,0 +1,7 @@
+// ""Replace initializer with getter"" ""true""
+
+fun String.foo() = ""bar""
+
+interface A {
+    val name = <caret>""The quick brown fox jumps over the lazy dog"".foo()",Neither the existing intention action nor your suggested quickfix handle `var` properties correctly. They should create a stub for the setter with no implementation.,I think this should be `<caret>`
437,"@@ -0,0 +1,7 @@
+// ERROR: Unresolved reference: listOf
+fun a() {
+    val b = listOf(1,2,3,4,5)","You should use `// WITH_RUNTIME` directive in this and all other tests where you use standard library functions to avoid errors
",
438,"@@ -0,0 +1,7 @@
+// IS_APPLICABLE: false
+fun foo() {
+    if (true) {
+        println(""test"")
+        println(""test2"")
+        <caret>}
+}","Typo in file name.
",Why is this needed?
439,"@@ -0,0 +1,7 @@
+class KotlinClass(): JavaClass({}) {","Please make function literal here non-trivial.
",
440,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredParamsType || hasDeclaredReturnType || hasDeclaredReceiverType) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val paramList = element.getFunctionLiteral().getValueParameterList()","Ditto (`element.getFunctionLiteral()` deserves to be extracted into a variable)
",Please add a copyright header to this 
441,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredParamsType || hasDeclaredReturnType || hasDeclaredReceiverType) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val paramList = element.getFunctionLiteral().getValueParameterList()
+        val params = paramList?.getParameters()
+
+        if (element.hasDeclaredReturnType()) {
+            val childAfterParamList = paramList?.getNextSibling()
+            val arrow = element.getFunctionLiteral().getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            element.getFunctionLiteral().deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            element.getFunctionLiteral().addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredReceiverType) {
+            val childAfterBrace = element.getFunctionLiteral().getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = paramList?.getPrevSibling()
+            element.getFunctionLiteral().deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        if (params != null && params!!.size() == 1 && params[0].getNameIdentifier() != null) {","There's a warning about a useless `!!` here
",I don't think this is the right place 
442,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.ErrorUtils
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredParamsType || hasDeclaredReturnType || hasDeclaredReceiverType) return true
+
+        return false
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val paramList = element.getFunctionLiteral().getValueParameterList()
+        val params = paramList?.getParameters()
+
+        if (element.hasDeclaredReturnType()) {
+            val childAfterParamList = paramList?.getNextSibling()
+            val arrow = element.getFunctionLiteral().getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            element.getFunctionLiteral().deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            element.getFunctionLiteral().addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredReceiverType) {
+            val childAfterBrace = element.getFunctionLiteral().getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = paramList?.getPrevSibling()
+            element.getFunctionLiteral().deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        if (params != null && params!!.size() == 1 && params[0].getNameIdentifier() != null) {
+            paramList!!.replace(params[0].getNameIdentifier()!!)
+        }
+        else {
+            params?.forEach{","Missing a space before `{`
",I don't think this is the right place 
443,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        }
+        else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        val multiParameter = element.getMultiParameter() ?: return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() as? JetCallExpression ?: return false
+
+        if (!selector.textMatches(""withIndices()"")) return false","This is a nice optimization, but I'd check if `selector` is a call expression with a callee named `withIndices`. People can have different weird code style settings, for example ones requiring spaces before parentheses; it would be a pity if this intention wouldn't work in that case (`withIndices ()`)
",I don't think you need the `!!` here
444,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        }
+        else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        val multiParameter = element.getMultiParameter() ?: return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() as? JetCallExpression ?: return false
+
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val bindingContext = AnalyzerFacadeWithCache.getContextForElement(element)
+        val callResolution = bindingContext[BindingContext.RESOLVED_CALL, selector.getCalleeExpression()!!] ?: return false
+        val fqName = DescriptorUtils.getFqNameSafe(callResolution.getCandidateDescriptor())","Ditto (`getFqNameSafe`)
",I don't think you need the `!!` here
445,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        }
+        else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        val multiParameter = element.getMultiParameter() ?: return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() as? JetCallExpression ?: return false
+
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val bindingContext = AnalyzerFacadeWithCache.getContextForElement(element)
+        val callResolution = bindingContext[BindingContext.RESOLVED_CALL, selector.getCalleeExpression()!!] ?: return false
+        val fqName = DescriptorUtils.getFqNameSafe(callResolution.getCandidateDescriptor())
+        if (fqName.toString() != ""kotlin.withIndices"") return false
+
+        val indexVar = multiParameter.getEntries()[0]","You should check if there are any entries. Otherwise your intention fails with the exception on the following test case:

``` kotlin
        for (() in listOf(1).withIndices()) {
        }
```
",I don't think you need the `!!` here
446,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        }
+        else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        val multiParameter = element.getMultiParameter() ?: return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() as? JetCallExpression ?: return false
+
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val bindingContext = AnalyzerFacadeWithCache.getContextForElement(element)
+        val callResolution = bindingContext[BindingContext.RESOLVED_CALL, selector.getCalleeExpression()!!] ?: return false
+        val fqName = DescriptorUtils.getFqNameSafe(callResolution.getCandidateDescriptor())
+        if (fqName.toString() != ""kotlin.withIndices"") return false
+
+        val indexVar = multiParameter.getEntries()[0]
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar, false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        var usageCount = 0","As I mentioned earlier, this should be a boolean flag, rather than an integer variable
",I don't think you need the `!!` here
447,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMember
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.Element
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+
+abstract class JavacMember<out T : Element>(element: T,
+                                            javac: Javac) : JavacElement<T>(element, javac), JavaMember {
+    override val containingClass: JavaClass
+        get() = JavacClass((element.enclosingElement as TypeElement), javac)
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = element.annotationMirrors
+                .map { JavacAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName): JavaAnnotation? = element.annotationMirrors
+            .filter { it.toString() == fqName.asString() }
+            .firstOrNull()
+            ?.let { JavacAnnotation(it, javac) }
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val name
+        get() = Name.identifier(element.simpleName.toString())
+
+    override val isDeprecatedInJavaDoc = false","Again, why false?",I don't think we need to override `fin
448,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMember
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.Element
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+
+abstract class JavacMember<out T : Element>(element: T,
+                                            javac: Javac) : JavacElement<T>(element, javac), JavaMember {
+    override val containingClass: JavaClass
+        get() = JavacClass((element.enclosingElement as TypeElement), javac)
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = element.annotationMirrors
+                .map { JavacAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName): JavaAnnotation? = element.annotationMirrors
+            .filter { it.toString() == fqName.asString() }
+            .firstOrNull()
+            ?.let { JavacAnnotation(it, javac) }
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val name
+        get() = Name.identifier(element.simpleName.toString())
+
+    override val isDeprecatedInJavaDoc = false
+
+    override val isAbstract
+        get() = element.isAbstract
+
+    override val isStatic
+        get() = element.isStatic
+
+    override val isFinal
+        get() = element.isFinal
+
+}
+
+fun ExecutableElement.valueParameters(javac: Javac) = let {",May be create separate file like `JavacElementUtils.kt` for such things.,I don't think we need to override `findAnnotation` here.
449,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.symbols
+
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.load.java.structure.JavaAnnotation
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaMember
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.Name
+import javax.lang.model.element.Element
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+
+abstract class JavacMember<out T : Element>(element: T,
+                                            javac: Javac) : JavacElement<T>(element, javac), JavaMember {
+    override val containingClass: JavaClass
+        get() = JavacClass((element.enclosingElement as TypeElement), javac)
+
+    override val annotations: Collection<JavaAnnotation>
+        get() = element.annotationMirrors
+                .map { JavacAnnotation(it, javac) }
+
+    override fun findAnnotation(fqName: FqName): JavaAnnotation? = element.annotationMirrors
+            .filter { it.toString() == fqName.asString() }
+            .firstOrNull()
+            ?.let { JavacAnnotation(it, javac) }
+
+    override val visibility
+        get() = element.getVisibility()
+
+    override val name
+        get() = Name.identifier(element.simpleName.toString())
+
+    override val isDeprecatedInJavaDoc = false
+
+    override val isAbstract
+        get() = element.isAbstract
+
+    override val isStatic
+        get() = element.isStatic
+
+    override val isFinal
+        get() = element.isFinal
+
+}
+
+fun ExecutableElement.valueParameters(javac: Javac) = let {
+    val parameterTypesCount = parameters.size
+
+    parameters.mapIndexed { index, it ->
+        val isLastParameter = index == parameterTypesCount - 1
+        val parameterName = it.simpleName.toString()
+        JavacValueParameter(it, parameterName, if (isLastParameter) isVarArgs else false, javac)",`isLastParameter && isVarArgs`,I don't think we need to override `findAnnotation` here.
450,"@@ -0,0 +1,70 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.code.Flags
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.descriptors.Visibilities
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.name.Name
+
+class TreeBasedField<out T : JCTree.JCVariableDecl>(tree: T,
+                                                    treePath: TreePath,
+                                                    containingClass: JavaClass,
+                                                    javac: JavacWrapper) : TreeBasedMember<T>(tree, treePath, containingClass, javac), JavaField {
+
+    override val name
+        get() = Name.identifier(tree.name.toString())
+
+    override val isAbstract
+        get() = tree.modifiers.isAbstract
+
+    override val isStatic
+        get() = containingClass.isInterface || tree.modifiers.isStatic",Please ensure there's a test on static fields in annotations,I don't think this is needed.
451,"@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.references.mainReference
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    val patterns = mapOf(
+            ""java.io.PrintStream.println"" to ""println($0)"",
+            ""java.io.PrintStream.print"" to ""print($0)"",
+            ""java.util.Collections.sort"" to ""$0.sort()""
+    )
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
+                super.visitQualifiedExpression(expression)
+
+                val selectorExpression = expression.selectorExpression ?: return
+                if (selectorExpression !is KtCallExpression) return
+                val value = selectorExpression.valueArguments.singleOrNull() ?: return
+
+                val calleeExpression = selectorExpression.calleeExpression as KtSimpleNameExpression
+                val bindingContext = calleeExpression.analyze(BodyResolveMode.PARTIAL)
+                val target = calleeExpression.mainReference.resolveToDescriptors(bindingContext).singleOrNull() ?: return
+                val pattern = target.fqNameSafe.asString()","I tryed use `importableFqName` but it's was giving null for me. I am a bit confused with this. 
",I don't think we need this class.
452,"@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.idea.refactoring.getLineNumber
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtBlockExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.lastBlockStatementOrThis
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class UnusedEqualsInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                super.visitBinaryExpression(expression)
+                if (expression.operationToken != KtTokens.EQEQ) return
+                val parent = expression.parent as? KtBlockExpression ?: return
+                val lastBlockStatement = parent.lastBlockStatementOrThis()
+                when {
+                    expression.evaluatesTo(lastBlockStatement) && expression.getLineNumber() == lastBlockStatement.getLineNumber() ->
+                        expression.getStrictParentOfType<KtLambdaExpression>()?.visitLambdaExpression(holder, expression) ?: holder.registerUnusedEqualsProblem(expression)",All of this looks too nasty and unsafe. Please use `KtExpression.isUsedAsExpression` from `BindingContextUtils.kt` to determine whether your `equals` result is used or not.,I don't think we need this class.
453,"@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.idea.refactoring.getLineNumber
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtBlockExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.lastBlockStatementOrThis
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class UnusedEqualsInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                super.visitBinaryExpression(expression)
+                if (expression.operationToken != KtTokens.EQEQ) return
+                val parent = expression.parent as? KtBlockExpression ?: return
+                val lastBlockStatement = parent.lastBlockStatementOrThis()
+                when {
+                    expression.evaluatesTo(lastBlockStatement) && expression.getLineNumber() == lastBlockStatement.getLineNumber() ->
+                        expression.getStrictParentOfType<KtLambdaExpression>()?.visitLambdaExpression(holder, expression) ?: holder.registerUnusedEqualsProblem(expression)
+                    else -> holder.registerUnusedEqualsProblem(expression)
+                }
+            }
+
+            private fun KtLambdaExpression.visitLambdaExpression(holder: ProblemsHolder, expression: KtBinaryExpression) {
+                val lambdaTypeArguments = getType(analyze())?.arguments ?: return
+                if (lambdaTypeArguments.size != 1) return
+                when {
+                    KotlinBuiltIns.isBoolean(lambdaTypeArguments[0].type) -> {
+                        val lastBlockStatementOrThis = bodyExpression?.lastBlockStatementOrThis() ?: return
+                        if (!expression.evaluatesTo(lastBlockStatementOrThis)) holder.registerUnusedEqualsProblem(expression)
+                    }
+                    else -> holder.registerUnusedEqualsProblem(expression)
+                }
+            }
+
+            private fun ProblemsHolder.registerUnusedEqualsProblem(expression: KtBinaryExpression) {
+                registerProblem(expression,",I'd say it's better to provide also text range here and highlight `==` only as unused.,I don't think we need this class.
454,"@@ -0,0 +1,71 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.intentions.branchedTransformations.evaluatesTo
+import org.jetbrains.kotlin.idea.refactoring.getLineNumber
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtBlockExpression
+import org.jetbrains.kotlin.psi.KtLambdaExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.lastBlockStatementOrThis
+import org.jetbrains.kotlin.resolve.calls.callUtil.getType
+
+class UnusedEqualsInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                super.visitBinaryExpression(expression)
+                if (expression.operationToken != KtTokens.EQEQ) return
+                val parent = expression.parent as? KtBlockExpression ?: return
+                val lastBlockStatement = parent.lastBlockStatementOrThis()
+                when {
+                    expression.evaluatesTo(lastBlockStatement) && expression.getLineNumber() == lastBlockStatement.getLineNumber() ->
+                        expression.getStrictParentOfType<KtLambdaExpression>()?.visitLambdaExpression(holder, expression) ?: holder.registerUnusedEqualsProblem(expression)
+                    else -> holder.registerUnusedEqualsProblem(expression)
+                }
+            }
+
+            private fun KtLambdaExpression.visitLambdaExpression(holder: ProblemsHolder, expression: KtBinaryExpression) {
+                val lambdaTypeArguments = getType(analyze())?.arguments ?: return
+                if (lambdaTypeArguments.size != 1) return
+                when {
+                    KotlinBuiltIns.isBoolean(lambdaTypeArguments[0].type) -> {
+                        val lastBlockStatementOrThis = bodyExpression?.lastBlockStatementOrThis() ?: return
+                        if (!expression.evaluatesTo(lastBlockStatementOrThis)) holder.registerUnusedEqualsProblem(expression)
+                    }
+                    else -> holder.registerUnusedEqualsProblem(expression)
+                }
+            }
+
+            private fun ProblemsHolder.registerUnusedEqualsProblem(expression: KtBinaryExpression) {
+                registerProblem(expression,
+                                ""Unused equals expression"",
+                                ProblemHighlightType.LIKE_UNUSED_SYMBOL)","Should we provide some quick fix? I'd say that in simple cases with local variables or constants binary expression could be completely deleted, but in cases like `foo() == bar()` we should get

```
foo()
bar()
```

instead",I don't think we need this class.
455,"@@ -0,0 +1,72 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.lang.ASTNode;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.impl.PsiImplUtil;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.JetDelegationSpecifier;
+import org.jetbrains.jet.lexer.JetTokens;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class RemoveSupertypeFix extends JetIntentionAction<JetDelegationSpecifier> {
+    private final JetDelegationSpecifier superClass;
+
+    public RemoveSupertypeFix(@NotNull JetDelegationSpecifier superClass) {
+        super(superClass);
+        this.superClass = superClass;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""remove.supertype"", superClass.getText());
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""remove.supertype.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        // Find the preceding comma and delete it as well.
+        // We must ignore whitespaces and comments when looking for the comma.
+        ASTNode prev = PsiImplUtil.skipWhitespaceAndCommentsBack(superClass.getPrevSibling().getNode());","Possible NullPointerException if superClass has no previous sibling??? But will it ever have no previous sibling?
",I don't think you need to override this.
456,"@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2012 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.impl.source.tree.LeafPsiElement;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.lang.psi.JetFile;
+import org.jetbrains.jet.lexer.JetTokens;
+import org.jetbrains.jet.plugin.JetBundle;
+
+/**
+ * @author slukjanov aka Frostman
+ */
+public class UnnecessaryNotNullAssertionFix implements IntentionAction {","I understand why you decided to create another class for that task but still think that there should be another logic in UnnecessaryNotNullAssertionFix and ReplaceCallFix. I propose ReplaceCallFix could also be used for replacing !!. call to something else as it can be used for introducing such calls now. And this class can could be responsible only for introducing and removing a!! postfix operation.
What do you think?
",I don't think we need this class.
457,"@@ -0,0 +1,73 @@
+/*
+ * Copyright 2010-2012 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.impl.source.tree.LeafPsiElement;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.jet.lang.psi.JetFile;
+import org.jetbrains.jet.lexer.JetTokens;
+import org.jetbrains.jet.plugin.JetBundle;
+
+/**
+ * @author slukjanov aka Frostman
+ */
+public class UnnecessaryNotNullAssertionFix implements IntentionAction {
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""remove.unnecessary.non.null.assertion"");
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return getText();
+    }
+
+    @Override
+    public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
+        return file instanceof JetFile && getExclExclElement(editor, file) != null;
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        final PsiElement exclExcl = getExclExclElement(editor, file);
+        assert exclExcl != null;
+
+        exclExcl.delete();","There's a problem with removing PSI element this way. It looks like IDEA can't handle the region for update correctly. I'm going to debug and fix it. It can be reproduced with this chunk of code. After applying the fix idea shows errors in internal mode (with -Didea.is.internal=true in javac string).
fun test(value : String) : String {
  return value!!
}
",I don't think you need to check for `null` here.
458,"@@ -0,0 +1,74 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.javac.MockKotlinClassifier
+import org.jetbrains.kotlin.load.java.structure.*
+
+sealed class ClassifierType<out T : JCTree>(tree: T,
+                                              treePath: TreePath,
+                                              javac: JavacWrapper) : JCType<T>(tree, treePath, javac), JavaClassifierType {
+
+    override val classifier by lazy { treePath.resolve(javac) }
+
+    override val canonicalText
+        get() = (classifier as? JavaClass)?.fqName?.asString() ?: treePath.leaf.toString()
+
+    override val presentableText
+        get() = canonicalText
+
+    private val typeParameter
+        get() = treePath.filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+                .flatMap {
+                    when (it) {
+                        is JCTree.JCClassDecl -> it.typarams
+                        is JCTree.JCMethodDecl -> it.typarams
+                        else -> throw UnsupportedOperationException(""${it.kind} cannot have a type parameter"")
+                    }
+                }
+                .find { it.toString().substringBefore("" "") == treePath.leaf.toString() }
+
+}
+
+class JCClassifierType<out T : JCTree.JCExpression>(tree: T,
+                                                    treePath: TreePath,
+                                                    javac: JavacWrapper) : ClassifierType<T>(tree, treePath, javac) {
+
+    override val typeArguments: List<JavaType>
+        get() = emptyList()
+
+    override val isRaw
+        get() = (classifier as? MockKotlinClassifier)?.hasTypeParameters
+                ?: (classifier as? JavaClass)?.typeParameters?.isNotEmpty()
+                ?: false
+
+}
+
+class JCClassifierTypeWithTypeArgument<out T : JCTree.JCTypeApply>(tree: T,","May be it's not the best name. For me it's more or less obvious, that `JCClassifierTypeWithTypeArgument` is an inheritor of `JCClassifierType`, but in fact it's not so. I'd change one of these two names.",I'm not sure if this is the best way to do this. I'm not
459,"@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.javac.MockKotlinClassifier
+import org.jetbrains.kotlin.load.java.structure.*
+
+sealed class TreeBasedClassifierType<out T : JCTree>(tree: T,
+                                                     treePath: TreePath,
+                                                     javac: JavacWrapper) : TreeBasedType<T>(tree, treePath, javac), JavaClassifierType {
+
+    override val classifier
+        get() = javac.resolve(treePath)
+
+    override val classifierQualifiedName
+        get() = (classifier as? JavaClass)?.fqName?.asString() ?: treePath.leaf.toString()
+
+    override val presentableText
+        get() = classifierQualifiedName
+
+    private val typeParameter
+        get() = treePath.filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+                .flatMap {
+                    when (it) {
+                        is JCTree.JCClassDecl -> it.typarams
+                        is JCTree.JCMethodDecl -> it.typarams
+                        else -> throw UnsupportedOperationException(""${it.kind} cannot have a type parameter"")","You can remove `.filter { ... }` above, and use `else -> emptyList()` here",I don't think we need to override `get()` here.
460,"@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.wrappers.trees
+
+import com.sun.source.util.TreePath
+import com.sun.tools.javac.tree.JCTree
+import org.jetbrains.kotlin.javac.JavacWrapper
+import org.jetbrains.kotlin.javac.MockKotlinClassifier
+import org.jetbrains.kotlin.load.java.structure.*
+
+sealed class TreeBasedClassifierType<out T : JCTree>(tree: T,
+                                                     treePath: TreePath,
+                                                     javac: JavacWrapper) : TreeBasedType<T>(tree, treePath, javac), JavaClassifierType {
+
+    override val classifier
+        get() = javac.resolve(treePath)
+
+    override val classifierQualifiedName
+        get() = (classifier as? JavaClass)?.fqName?.asString() ?: treePath.leaf.toString()
+
+    override val presentableText
+        get() = classifierQualifiedName
+
+    private val typeParameter
+        get() = treePath.filter { it is JCTree.JCClassDecl || it is JCTree.JCMethodDecl }
+                .flatMap {
+                    when (it) {
+                        is JCTree.JCClassDecl -> it.typarams
+                        is JCTree.JCMethodDecl -> it.typarams
+                        else -> throw UnsupportedOperationException(""${it.kind} cannot have a type parameter"")
+                    }
+                }
+                .find { it.toString().substringBefore("" "") == treePath.leaf.toString() }
+
+}
+
+class TreeBasedClassifierTypeWithoutTypeArgument<out T : JCTree.JCExpression>(tree: T,",Consider renaming to `TreeBasedNonGenericClassifierType` and `TreeBasedGenericClassifierType`,I don't think we need to override `get()` here.
461,"@@ -0,0 +1,77 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.plugin.JetBundle
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFile
+import com.intellij.psi.PsiFile
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.psi.PsiElement
+import com.intellij.refactoring.changeSignature.PsiCallReference
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import com.intellij.psi.PsiArrayAccessExpression
+import com.intellij.psi.impl.source.tree.java.PsiArrayAccessExpressionImpl
+import org.jetbrains.jet.lang.psi.JetVisitorVoid
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.plugin.quickfix.JetIntentionAction
+
+public class GetCallReplacementIntention : JetSelfTargetingIntention<JetDotQualifiedExpression>(""get.call.replacement"", javaClass()) {
+    var project : Project? = null
+
+    override fun invoke(project: Project, editor: Editor, file: PsiFile) {
+        this.project = project
+        super<JetSelfTargetingIntention>.invoke(project, editor, file)
+    }
+
+    override fun isApplicableTo(element: JetDotQualifiedExpression): Boolean {
+        val selector : JetCallExpression? = element.getSelectorExpression() as? JetCallExpression","Code formatting is inconsistent.
",I don't think we need these imports.
462,"@@ -0,0 +1,77 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.plugin.JetBundle
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFile
+import com.intellij.psi.PsiFile
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import com.intellij.psi.PsiElement
+import com.intellij.refactoring.changeSignature.PsiCallReference
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import com.intellij.psi.PsiArrayAccessExpression
+import com.intellij.psi.impl.source.tree.java.PsiArrayAccessExpressionImpl
+import org.jetbrains.jet.lang.psi.JetVisitorVoid
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.plugin.quickfix.JetIntentionAction
+
+public class GetCallReplacementIntention : JetSelfTargetingIntention<JetDotQualifiedExpression>(""get.call.replacement"", javaClass()) {
+    var project : Project? = null
+
+    override fun invoke(project: Project, editor: Editor, file: PsiFile) {
+        this.project = project
+        super<JetSelfTargetingIntention>.invoke(project, editor, file)
+    }
+
+    override fun isApplicableTo(element: JetDotQualifiedExpression): Boolean {
+        val selector : JetCallExpression? = element.getSelectorExpression() as? JetCallExpression
+        val callee : JetExpression? = selector?.getCalleeExpression()
+
+        return callee != null && callee.textMatches(""get"")
+    }
+
+    override fun applyTo(element: JetDotQualifiedExpression, editor: Editor) {
+        val selector : JetCallExpression? = element.getSelectorExpression() as? JetCallExpression
+        val callee : JetExpression? = selector?.getCalleeExpression()
+        val arguments = selector?.getValueArgumentList()
+        assert(arguments != null)
+        val argumentsText = arguments!!.getText()
+        assert(argumentsText != null)
+        val receiver : JetExpression = element.getReceiverExpression()
+        var arrayArgumentsText = """"
+
+        for (i in 0..argumentsText!!.length() - 1) {
+            when (i) {
+                0 -> arrayArgumentsText += ""[""
+                argumentsText.length() - 1 -> arrayArgumentsText += ""]""
+                else -> arrayArgumentsText += argumentsText[i]
+            }
+        }
+
+        if (project == null) {","No need to save project to local property: it can be obtained from `element`
",I don't think we need these imports.
463,"@@ -0,0 +1,78 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+import org.jetbrains.jet.lang.psi.JetCallableReferenceExpression
+
+public class ConvertAssertToIfWithThrowIntention : JetSelfTargetingIntention<JetCallExpression>(
+        ""convert.assert.to.if.with.throw"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        if (element.getCalleeExpression()?.getText() != ""assert"") return false
+        val arguments = element.getValueArguments().size
+        val lambdas = element.getFunctionLiteralArguments().size
+        if (!(arguments == 1 && (lambdas == 1 || lambdas == 0)) && arguments != 2) return false
+        val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        val resolvedCall = context[BindingContext.RESOLVED_CALL, element.getCalleeExpression()]
+        return resolvedCall?.getResultingDescriptor()?.getContainingDeclaration()?.getName().toString() == ""kotlin""
+    }
+
+    override fun applyTo(element: JetCallExpression, editor: Editor) {
+        val args = element.getValueArguments()
+        val condition = args[0]?.getArgumentExpression()
+        val lambdas = element.getFunctionLiteralArguments()
+
+        val messageExpr = if (args.size == 2) {
+            args[1]?.getArgumentExpression()
+        } else if (!lambdas.isEmpty()) {
+            element.getFunctionLiteralArguments()[0]
+        } else {
+            JetPsiFactory.createExpression(element.getProject(), ""\""Assertion failed\"""")","not sure on this line, basically i just want that string, but later i use messageExpr as an expression, so i was debating whether to create an expression with the string and then have easier handling at line 62, or i thought maybe setting messageExpr to be Any and then just assigning the string and adding a special check for String in line 62, probably more efficient but less readable.
Ended up going for readability
",I don't think we need to check for `lambdas == 0` here. 
464,"@@ -0,0 +1,78 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class ReplaceWithOperatorAssignIntention : JetSelfTargetingIntention<JetBinaryExpression>(""replace.with.operator.assign.intention"", javaClass()) {
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        fun checkForNullSafety(element : JetBinaryExpression): Boolean {
+            val rightExpression = element.getRight()
+
+            return element.getLeft() != null &&
+                    element.getRight() != null &&
+                    element.getLeft() is JetSimpleNameExpression &&
+                    element.getOperationToken() == JetTokens.EQ &&
+                    rightExpression is JetBinaryExpression &&
+                    rightExpression.getLeft() != null &&
+                    rightExpression.getRight() != null","1) Extract `element.getLeft()` just like you did for `element.getRight()` (let's call it leftExpression)
2) There is no point in using `element.getRight()`/`element.getLeft()` in comparisons since they are/will be extracted to variables
3) `leftExpression !=null` is redundant (it's implied by `leftExpression is JetSimpleNameExpression`)
The same goes for `element.getRight() != null`
4) Also I'd change the function name since it doesn't just check for null safety. Something like `isWellFormedAssignment`, for example.
",I think it would be better to use `JetTokens.EQUAL` here.
465,"@@ -0,0 +1,78 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class ReplaceWithOperatorAssignIntention : JetSelfTargetingIntention<JetBinaryExpression>(""replace.with.operator.assign.intention"", javaClass()) {
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        fun checkForNullSafety(element : JetBinaryExpression): Boolean {
+            val rightExpression = element.getRight()
+
+            return element.getLeft() != null &&
+                    element.getRight() != null &&
+                    element.getLeft() is JetSimpleNameExpression &&
+                    element.getOperationToken() == JetTokens.EQ &&
+                    rightExpression is JetBinaryExpression &&
+                    rightExpression.getLeft() != null &&
+                    rightExpression.getRight() != null
+        }
+
+        fun checkExpressionRepeat(variableExpression: JetSimpleNameExpression, expression: JetBinaryExpression): Boolean {
+            if (variableExpression.getText().equals(expression.getLeft()!!.getText()))
+                return expression.getOperationToken() == JetTokens.PLUS ||
+                        expression.getOperationToken() == JetTokens.MINUS ||
+                        expression.getOperationToken() == JetTokens.MUL ||
+                        expression.getOperationToken() == JetTokens.DIV ||
+                        expression.getOperationToken() == JetTokens.PERC
+            else if (variableExpression.getText().equals(expression.getRight()!!.getText()))
+                return expression.getOperationToken() == JetTokens.PLUS ||
+                        expression.getOperationToken() == JetTokens.MUL
+            else if (expression.getLeft() is JetBinaryExpression)
+                return checkExpressionRepeat(variableExpression, expression.getLeft() as JetBinaryExpression)
+            else
+                return false
+        }
+","1) JetPsiMatcher class provides more reliable and generic way to compare PSI elements. Please, use it instead of comparing element text directly. For example, `JetPsiMatcher.checkElementMatch(variableExpression, expression.getLeft())`
2) I suggest to use when expression instead of nested ""ifs"". Like this:

```
return when {
    JetPsiMatcher.checkElementMatch(variableExpression, expression.getLeft()) -> ...
    ...
}
```

3) This function is tail-recursive, so it's worth annotating it with `tailRecursive`. Then compiler can apply tail-call optimization to it.
",I don't think you need the `!!` here.
466,"@@ -0,0 +1,78 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lexer.JetTokens
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class ReplaceWithOperatorAssignIntention : JetSelfTargetingIntention<JetBinaryExpression>(""replace.with.operator.assign.intention"", javaClass()) {
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        fun checkForNullSafety(element : JetBinaryExpression): Boolean {
+            val rightExpression = element.getRight()
+
+            return element.getLeft() != null &&
+                    element.getRight() != null &&
+                    element.getLeft() is JetSimpleNameExpression &&
+                    element.getOperationToken() == JetTokens.EQ &&
+                    rightExpression is JetBinaryExpression &&
+                    rightExpression.getLeft() != null &&
+                    rightExpression.getRight() != null
+        }
+
+        fun checkExpressionRepeat(variableExpression: JetSimpleNameExpression, expression: JetBinaryExpression): Boolean {
+            if (variableExpression.getText().equals(expression.getLeft()!!.getText()))
+                return expression.getOperationToken() == JetTokens.PLUS ||
+                        expression.getOperationToken() == JetTokens.MINUS ||
+                        expression.getOperationToken() == JetTokens.MUL ||
+                        expression.getOperationToken() == JetTokens.DIV ||
+                        expression.getOperationToken() == JetTokens.PERC
+            else if (variableExpression.getText().equals(expression.getRight()!!.getText()))
+                return expression.getOperationToken() == JetTokens.PLUS ||
+                        expression.getOperationToken() == JetTokens.MUL
+            else if (expression.getLeft() is JetBinaryExpression)
+                return checkExpressionRepeat(variableExpression, expression.getLeft() as JetBinaryExpression)
+            else
+                return false
+        }
+
+        if (checkForNullSafety(element)) {
+            return checkExpressionRepeat(element.getLeft() as JetSimpleNameExpression, element.getRight() as JetBinaryExpression)
+        } else {
+            return false
+        }
+    }
+
+    override fun applyTo(element: JetBinaryExpression, editor: Editor) {
+        fun buildReplacement(variableExpression: JetSimpleNameExpression, expression: JetBinaryExpression, replacementBuilder: StringBuilder): String {","This function is also tail-recursive, so please add [tailRecursive] annotation.
",I don't think you need the `!!` here.
467,"@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.descriptors.ConstructorDescriptor
+import org.jetbrains.kotlin.descriptors.PropertyDescriptor
+import org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor
+import org.jetbrains.kotlin.load.java.components.JavaResolverCache
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.tail
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.lazy.ResolveSession
+import org.jetbrains.kotlin.resolve.lazy.ResolveSessionUtils
+import javax.inject.Inject
+
+class JavacJavaResolverCache : JavaResolverCache {",Here we also could extract `AbstractJavaResolverCache`,I think we can remove this class. It is not used.
468,"@@ -0,0 +1,79 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.descriptors.ConstructorDescriptor
+import org.jetbrains.kotlin.descriptors.PropertyDescriptor
+import org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor
+import org.jetbrains.kotlin.load.java.components.JavaResolverCache
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.JavaElement
+import org.jetbrains.kotlin.load.java.structure.JavaField
+import org.jetbrains.kotlin.load.java.structure.JavaMethod
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.name.tail
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.lazy.ResolveSession
+import org.jetbrains.kotlin.resolve.lazy.ResolveSessionUtils
+import javax.inject.Inject
+
+class JavacJavaResolverCache : JavaResolverCache {
+
+    private lateinit var trace: BindingTrace
+    private lateinit var resolveSession: ResolveSession","In `LazyJavaResolverCache` both of them are `val`, why we do not want the same behaviour here?",I don't think we need this class.
469,"@@ -0,0 +1,8 @@
+// ""Create method 'get' from usage"" ""true""
+import java.util.ArrayList
+
+class Foo<T> {","Isn't it better to remove type parameter of class to avoid confusing when reading test? Or is it intentional?
",This file is missing the license header.
470,"@@ -0,0 +1,8 @@
+enum class E {
+FOO
+fun foo() : Unit {
+FOO.toString()
+}
+public fun name() : String { return """" }
+public fun order() : Int { return 0 }
+}
\ No newline at end of file","The same: code formatting is wrong
",Please add a newline at the end of file.
471,"@@ -0,0 +1,8 @@
+var status: String = ""fail""","I beleive it would be good to add comment explaining why ""status"" here is top-level property instead of local variable.
",
472,"@@ -0,0 +1,80 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+import org.jetbrains.jet.lang.psi.JetCallableReferenceExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class ConvertAssertToIfWithThrowIntention : JetSelfTargetingIntention<JetCallExpression>(
+        ""convert.assert.to.if.with.throw"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        if (element.getCalleeExpression()?.getText() != ""assert"") return false
+        val arguments = element.getValueArguments().size
+        val lambdas = element.getFunctionLiteralArguments().size
+        if (!(arguments == 1 && (lambdas == 1 || lambdas == 0)) && arguments != 2) return false
+        val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        val resolvedCall = context[BindingContext.RESOLVED_CALL, element.getCalleeExpression()]
+        if (resolvedCall == null) return false
+        return DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()).toString() == ""kotlin.assert""","fixed to use DescriptorUtils.getFqName
",I don't think we need to check for null here.
473,"@@ -0,0 +1,80 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.plugin.codeInsight.ShortenReferences
+import org.jetbrains.jet.lang.psi.JetCallableReferenceExpression
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+
+public class ConvertAssertToIfWithThrowIntention : JetSelfTargetingIntention<JetCallExpression>(
+        ""convert.assert.to.if.with.throw"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        if (element.getCalleeExpression()?.getText() != ""assert"") return false
+        val arguments = element.getValueArguments().size
+        val lambdas = element.getFunctionLiteralArguments().size
+        if (!(arguments == 1 && (lambdas == 1 || lambdas == 0)) && arguments != 2) return false
+        val context = AnalyzerFacadeWithCache.getContextForElement(element)
+        val resolvedCall = context[BindingContext.RESOLVED_CALL, element.getCalleeExpression()]
+        if (resolvedCall == null) return false
+        return DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()).toString() == ""kotlin.assert""
+    }
+
+    override fun applyTo(element: JetCallExpression, editor: Editor) {
+        val args = element.getValueArguments()
+        val condition = args[0]?.getArgumentExpression()
+        val lambdas = element.getFunctionLiteralArguments()
+
+        val messageExpr = if (args.size == 2) {
+            args[1]?.getArgumentExpression()
+        } else if (lambdas.isNotEmpty()) {","!lambdas.isEmpty changed to lambdas.isNotEmpty()
",I don't think we need to check for null here.
474,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {","Ditto (`paramsTextRange != null && caretLocation in paramsTextRange` or `paramsTextRange?.contains(caretLocation) ?: false`)
",This should be `isApplicableTo(element: JetFunctionLitera
475,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false","Ditto
",This should be `isApplicableTo(element: JetFunctionLitera
476,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val paramsTextRange = element.getFunctionLiteral().getValueParameterList()?.getTextRange()
+        val caretIsInParams = if (paramsTextRange != null) {
+            caretLocation in paramsTextRange
+        }
+        else false
+        if (!(caretLocation == openBraceOffset + 1 || caretLocation == closeBraceOffset || caretIsInParams)) return false
+
+        val params = element.getValueParameters()
+        val hasDeclaredParamsType = params.any { it.getTypeReference() != null }
+        val hasDeclaredReturnType = element.hasDeclaredReturnType()
+        val hasDeclaredReceiverType = element.getFunctionLiteral().getReceiverTypeRef() != null
+        if (hasDeclaredParamsType || hasDeclaredReturnType || hasDeclaredReceiverType) return true","I think I noticed the first time: such code creates a false sense that the applicability of the intention here depends on all three of these variables. Your code should look more like this:
1. if has declared params type, return true
2. if has declared return type, return true
3. if has declared receiver type, return true
4. return false

Once you refactor your code to look like this, you'll notice that these variables are no longer needed since they can be inlined. This will make the code shorter. Please do this.
",This should be `isApplicableTo(element: JetFunctionLitera
477,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.KtNodeTypes
+import org.jetbrains.kotlin.psi.*
+
+class RedundantIfInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitIfExpression(expression: KtIfExpression) {
+                super.visitIfExpression(expression)
+
+                if (expression.condition != null && isRedundant(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Redundant 'if' statement"",
+                                           ProblemHighlightType.LIKE_UNUSED_SYMBOL,
+                                           RemoveRedundantIf)
+                }
+            }
+        }
+    }
+
+    private fun isRedundant(expression: KtIfExpression): Boolean {
+        val thenReturn = getReturnedExpression(expression.then) ?: return false
+        val elseReturn = getReturnedExpression(expression.`else`) ?: return false
+
+        if (KtPsiUtil.isTrueConstant(thenReturn) && !KtPsiUtil.isTrueConstant(elseReturn)) {","I find it somewhat confusing that the KtNodeTypes.BOOLEAN_CONSTANT check is separate from the value check. It would be clearer to add the corresponding `isFalseConstant()` method to `KtPsiUtil` and to remove the node type check from `getReturnedExpression()`.
",I don't think you need the `?:` here.
478,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.KtNodeTypes
+import org.jetbrains.kotlin.psi.*
+
+class RedundantIfInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitIfExpression(expression: KtIfExpression) {
+                super.visitIfExpression(expression)
+
+                if (expression.condition != null && isRedundant(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Redundant 'if' statement"",
+                                           ProblemHighlightType.LIKE_UNUSED_SYMBOL,
+                                           RemoveRedundantIf)
+                }
+            }
+        }
+    }
+
+    private fun isRedundant(expression: KtIfExpression): Boolean {
+        val thenReturn = getReturnedExpression(expression.then) ?: return false
+        val elseReturn = getReturnedExpression(expression.`else`) ?: return false
+
+        if (KtPsiUtil.isTrueConstant(thenReturn) && !KtPsiUtil.isTrueConstant(elseReturn)) {
+            return true
+        }
+
+        if (!KtPsiUtil.isTrueConstant(thenReturn) && KtPsiUtil.isTrueConstant(elseReturn)) {
+            return true
+        }
+
+        return false
+    }
+
+    private fun getReturnedExpression(expression: KtExpression?) : KtExpression? {
+        if (expression == null) return null
+        if (expression !is KtBlockExpression) return null","This check isn't necessary: a statement where `return` is not enclosed in braces is no less trivial.
",I don't think we need to check for `thenReturn` and `else
479,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.KtNodeTypes
+import org.jetbrains.kotlin.psi.*
+
+class RedundantIfInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitIfExpression(expression: KtIfExpression) {
+                super.visitIfExpression(expression)
+
+                if (expression.condition != null && isRedundant(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Redundant 'if' statement"",
+                                           ProblemHighlightType.LIKE_UNUSED_SYMBOL,
+                                           RemoveRedundantIf)
+                }
+            }
+        }
+    }
+
+    private fun isRedundant(expression: KtIfExpression): Boolean {
+        val thenReturn = getReturnedExpression(expression.then) ?: return false
+        val elseReturn = getReturnedExpression(expression.`else`) ?: return false
+
+        if (KtPsiUtil.isTrueConstant(thenReturn) && !KtPsiUtil.isTrueConstant(elseReturn)) {
+            return true
+        }
+
+        if (!KtPsiUtil.isTrueConstant(thenReturn) && KtPsiUtil.isTrueConstant(elseReturn)) {
+            return true
+        }
+
+        return false
+    }
+
+    private fun getReturnedExpression(expression: KtExpression?) : KtExpression? {
+        if (expression == null) return null
+        if (expression !is KtBlockExpression) return null
+        if (expression.statements.size != 1) return null
+
+        val statement = expression.statements[0]","`expression.statements.singleOrNull() as? KtReturnExpression ?: return null`
",I don't think we need to check for `thenReturn` and `else
480,"@@ -0,0 +1,81 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
+import org.jetbrains.kotlin.idea.util.ShortenReferences
+import org.jetbrains.kotlin.psi.KtClassOrObject
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.resolve.DescriptorToSourceUtils
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.isInterface
+import org.jetbrains.kotlin.types.typeUtil.supertypes
+
+private fun KotlinType.renderShort() = IdeDescriptorRenderers.SOURCE_CODE_SHORT_NAMES_IN_TYPES.renderType(this)
+
+private fun KotlinType.getSuperTypesRecursive() = constructor.supertypes.let { it + it.flatMap { it.supertypes() } }","BTW, this is exponential; please use `TypeUtils#getAllSupertypes` instead
",I don't think we need this.
481,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.references.mainReference
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    private val patterns = mapOf(
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", ConversionType.METHOD),","What about other usages of  `PrintStream.println` outside of `System.out`, e.g. `System.err`? This will produce a lot of false positives.
",I don't think we need this 
482,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.references.mainReference
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    private val patterns = mapOf(
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", ConversionType.METHOD),
+            ""java.io.PrintStream.print"" to Pair(""print($0)"", ConversionType.METHOD),
+            ""java.util.Collections.sort"" to Pair(""$0.sort()"", ConversionType.METHOD),
+            ""java.util.HashMap.put"" to Pair(""$0[$1] = $2"", ConversionType.ASSIGNMENT)","Why limit to `HashMap`?
",I don't think we need the `
483,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.references.mainReference
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+
+class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+
+    private val patterns = mapOf(
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", ConversionType.METHOD),
+            ""java.io.PrintStream.print"" to Pair(""print($0)"", ConversionType.METHOD),
+            ""java.util.Collections.sort"" to Pair(""$0.sort()"", ConversionType.METHOD),
+            ""java.util.HashMap.put"" to Pair(""$0[$1] = $2"", ConversionType.ASSIGNMENT)
+    )
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
+                super.visitQualifiedExpression(expression)
+
+                val selectorExpression = expression.selectorExpression
+                if(selectorExpression !is KtCallExpression) return
+                val args = selectorExpression.valueArguments
+                if(args.isEmpty()) return
+
+                val calleeExpression = selectorExpression.calleeExpression as? KtSimpleNameExpression ?: return
+                val bindingContext = calleeExpression.analyze(BodyResolveMode.PARTIAL)
+                val target = calleeExpression.mainReference.resolveToDescriptors(bindingContext).singleOrNull() ?: return","You can use `findOriginalTopMostOverriddenDescriptors` e.g. to to get `MutableMap.put` instead of `HashMap.put`
",I don't think we need this 
484,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
+
+private val JAVA_LANG_CLASS_FQ_NAME = FqName(""java.lang.Class"")
+
+private fun KotlinType.isJClass(): Boolean {
+    val expressionTypeFqName = constructor.declarationDescriptor?.fqNameSafe ?: return false
+    return expressionTypeFqName == JAVA_LANG_CLASS_FQ_NAME
+}
+
+class ConvertClassToKClassFix(element: KtDotQualifiedExpression, private val type: KotlinType) : KotlinQuickFixAction<KtDotQualifiedExpression>(element) {
+    override fun getText() = ""Remove '.${element.children.lastOrNull()?.text}'""
+    override fun getFamilyName() = ""Remove conversion from 'KClass' to 'Class'""
+
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (!super.isAvailable(project, editor, file)) return false
+
+        val expressionType = element.analyze(BodyResolveMode.PARTIAL).getType(element) ?: return false
+        if (!expressionType.isJClass()) return false
+
+        val children = element.children
+        if (children.size != 2) return false
+
+        val firstChild = children.first() as? KtExpression ?: return false
+        val firstChildType = firstChild.analyze(BodyResolveMode.PARTIAL).getType(firstChild) ?: return false","You should reuse the BindingContext from the first analyze() call.
",I don't think you need this
485,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.codeInsight.intention.IntentionAction
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.descriptors.ClassDescriptor
+import org.jetbrains.kotlin.diagnostics.Diagnostic
+import org.jetbrains.kotlin.diagnostics.Errors
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+import org.jetbrains.kotlin.types.typeUtil.isSubtypeOf
+
+private val JAVA_LANG_CLASS_FQ_NAME = FqName(""java.lang.Class"")
+
+private fun KotlinType.isJClass(): Boolean {
+    val expressionTypeFqName = constructor.declarationDescriptor?.fqNameSafe ?: return false
+    return expressionTypeFqName == JAVA_LANG_CLASS_FQ_NAME
+}
+
+class ConvertClassToKClassFix(element: KtDotQualifiedExpression, private val type: KotlinType) : KotlinQuickFixAction<KtDotQualifiedExpression>(element) {
+    override fun getText() = ""Remove '.${element.children.lastOrNull()?.text}'""
+    override fun getFamilyName() = ""Remove conversion from 'KClass' to 'Class'""
+
+
+    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean {
+        if (!super.isAvailable(project, editor, file)) return false
+
+        val expressionType = element.analyze(BodyResolveMode.PARTIAL).getType(element) ?: return false
+        if (!expressionType.isJClass()) return false
+
+        val children = element.children
+        if (children.size != 2) return false
+
+        val firstChild = children.first() as? KtExpression ?: return false
+        val firstChildType = firstChild.analyze(BodyResolveMode.PARTIAL).getType(firstChild) ?: return false
+
+        return firstChildType.isSubtypeOf(type)
+    }
+
+    override fun invoke(project: Project, editor: Editor?, file: KtFile) {
+        val lastChild = element.children.lastOrNull() ?: return
+        editor?.document?.replaceString(lastChild.startOffset - 1, lastChild.endOffset, """")","The quickfix will do nothing if there is no editor. It's possible to perform the change through the PSI, and it's better to do it that way.
",I don't think you need this
486,"@@ -0,0 +1,82 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.components
+
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.vfs.VirtualFile
+import com.intellij.psi.search.DelegatingGlobalSearchScope
+import com.intellij.psi.search.GlobalSearchScope
+import org.jetbrains.kotlin.javac.Javac
+import org.jetbrains.kotlin.idea.KotlinFileType
+import org.jetbrains.kotlin.load.java.JavaClassFinder
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.FqName
+import org.jetbrains.kotlin.resolve.BindingTrace
+import org.jetbrains.kotlin.resolve.CodeAnalyzerInitializer
+import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
+import javax.annotation.PostConstruct
+import javax.inject.Inject
+
+class JavacClassFinder : JavaClassFinder {",JavacBasedClassFinder?,I don't think we need this 
487,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.util.PsiTreeUtil
+import com.intellij.psi.PsiDocumentManager
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import com.intellij.codeInsight.template.TemplateBuilderImpl
+import com.intellij.codeInsight.template.impl.TemplateManagerImpl
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import org.jetbrains.jet.analyzer.analyzeInContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+
+public class AddForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""add.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val loopRange = element.getLoopRange()!!
+        val newRangeText = ""${loopRange.getText()}.withIndices()""
+        val newRange = JetPsiFactory.createExpression(editor.getProject(), newRangeText)
+
+        //Roundabout way to create new multiparameter element so as not to incorrectly trigger syntax error highlighting
+        val loopParameter = element.getLoopParameter()!!
+        val parenthesizedParam = JetPsiFactory.createExpression(editor.getProject(), ""(index)"") as JetParenthesizedExpression
+        val indexElement = parenthesizedParam.getExpression()!!
+        val comma = JetPsiFactory.createComma(editor.getProject())
+        val newParamElement = JetPsiFactory.createExpression(editor.getProject(), "" ${loopParameter.getText()}"")
+        parenthesizedParam.addAfter(newParamElement, indexElement)
+        parenthesizedParam.addAfter(comma, indexElement)
+
+        loopParameter.replace(parenthesizedParam)
+        loopRange.replace(newRange)
+
+        val multiParameter = PsiTreeUtil.findChildOfType(element, indexElement.javaClass)!!
+
+        editor.getCaretModel().moveToOffset(multiParameter.getTextOffset())
+        val templateBuilder = TemplateBuilderImpl(multiParameter)
+        templateBuilder.replaceElement(multiParameter, ""index"")
+        val manager = TemplateManagerImpl(editor.getProject())
+        PsiDocumentManager.getInstance(editor.getProject()!!).doPostponedOperationsAndUnblockDocument(editor.getDocument())
+        manager.startTemplate(editor, templateBuilder.buildInlineTemplate()!!)
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getLoopParameter() == null) return false
+        val range = element.getLoopRange() ?: return false
+        if (range is JetDotQualifiedExpression) {
+            val selector = range.getSelectorExpression() ?: return true
+            if (selector.getText() == ""withIndices()"") return false","The same here, I wouldn't want **add withIndices** intention to be applicable where I've typed `withIndices ()`
",I don't think you need to o
488,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.util.PsiTreeUtil
+import com.intellij.psi.PsiDocumentManager
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import com.intellij.codeInsight.template.TemplateBuilderImpl
+import com.intellij.codeInsight.template.impl.TemplateManagerImpl
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import org.jetbrains.jet.analyzer.analyzeInContext
+import org.jetbrains.jet.lang.psi.JetCallExpression
+
+public class AddForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""add.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val loopRange = element.getLoopRange()!!
+        val newRangeText = ""${loopRange.getText()}.withIndices()""
+        val newRange = JetPsiFactory.createExpression(editor.getProject(), newRangeText)
+
+        //Roundabout way to create new multiparameter element so as not to incorrectly trigger syntax error highlighting
+        val loopParameter = element.getLoopParameter()!!
+        val parenthesizedParam = JetPsiFactory.createExpression(editor.getProject(), ""(index)"") as JetParenthesizedExpression
+        val indexElement = parenthesizedParam.getExpression()!!
+        val comma = JetPsiFactory.createComma(editor.getProject())
+        val newParamElement = JetPsiFactory.createExpression(editor.getProject(), "" ${loopParameter.getText()}"")
+        parenthesizedParam.addAfter(newParamElement, indexElement)
+        parenthesizedParam.addAfter(comma, indexElement)
+
+        loopParameter.replace(parenthesizedParam)
+        loopRange.replace(newRange)
+
+        val multiParameter = PsiTreeUtil.findChildOfType(element, indexElement.javaClass)!!
+
+        editor.getCaretModel().moveToOffset(multiParameter.getTextOffset())
+        val templateBuilder = TemplateBuilderImpl(multiParameter)
+        templateBuilder.replaceElement(multiParameter, ""index"")
+        val manager = TemplateManagerImpl(editor.getProject())
+        PsiDocumentManager.getInstance(editor.getProject()!!).doPostponedOperationsAndUnblockDocument(editor.getDocument())
+        manager.startTemplate(editor, templateBuilder.buildInlineTemplate()!!)
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getLoopParameter() == null) return false
+        val range = element.getLoopRange() ?: return false
+        if (range is JetDotQualifiedExpression) {
+            val selector = range.getSelectorExpression() ?: return true
+            if (selector.getText() == ""withIndices()"") return false
+        }
+
+        val potentialExpression = JetPsiFactory.createExpression(element.getProject(),
+                                                                 ""${range.getText()}.withIndices()"") as JetDotQualifiedExpression
+
+        val bindingContext = AnalyzerFacadeWithCache.getContextForElement(element)
+        val scope = bindingContext[BindingContext.RESOLUTION_SCOPE, element] ?: return false
+        val functionSelector = potentialExpression.getSelectorExpression() as JetCallExpression
+        val updatedContext = potentialExpression.analyzeInContext(scope)
+        val callScope = updatedContext[BindingContext.RESOLVED_CALL, functionSelector.getCalleeExpression()!!] ?: return false
+        val callFqName = DescriptorUtils.getFqNameSafe(callScope.getCandidateDescriptor())","You shouldn't call `getFqNameSafe`, because FQ name can be unsafe here (consider functions in class objects)
",I don't think you need to o
489,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)","Once again experience the power of Kotlin and just use a `var` here
",I don't think you need this
490,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)
+        val usageFinderRunnable = object : Runnable {
+            override fun run() {
+                val processor = object : Processor<UsageInfo> {
+                    override fun process(t: UsageInfo?): Boolean {
+                        usageCount[0] = usageCount[0] + 1","How about `++`?
",I don't think you need this
491,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)
+        val usageFinderRunnable = object : Runnable {
+            override fun run() {
+                val processor = object : Processor<UsageInfo> {
+                    override fun process(t: UsageInfo?): Boolean {
+                        usageCount[0] = usageCount[0] + 1
+                        return true","Do you really need to continue processing all usages if you've already found one? This also means that you should just have a boolean flag instead of an integer value
",I don't think you need this
492,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)
+        val usageFinderRunnable = object : Runnable {
+            override fun run() {
+                val processor = object : Processor<UsageInfo> {
+                    override fun process(t: UsageInfo?): Boolean {
+                        usageCount[0] = usageCount[0] + 1
+                        return true
+                    }
+                }
+                findHandler.processElementUsages(indexVar,processor,options)","`Processor` is a Java interface with a single method (SAM interface), so you should be able to just pass a lambda instead of an object expression, thanks to SAM conversion in Kotlin
",I don't think you need this
493,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)
+        val usageFinderRunnable = object : Runnable {
+            override fun run() {
+                val processor = object : Processor<UsageInfo> {
+                    override fun process(t: UsageInfo?): Boolean {
+                        usageCount[0] = usageCount[0] + 1
+                        return true
+                    }
+                }
+                findHandler.processElementUsages(indexVar,processor,options)
+            }
+        }
+        usageFinderRunnable.run()","I'm not sure what's the point in creating a `Runnable` and immediately running it?
",I don't think you need this
494,"@@ -0,0 +1,83 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import org.jetbrains.jet.lang.cfg.PseudocodeVariablesData.VariableUseState
+import org.jetbrains.jet.lang.cfg.pseudocode.PseudocodeUtil
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.lang.psi.JetFile
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.cfg.JetFlowInformationProvider
+import org.jetbrains.jet.lang.cfg.JetControlFlowProcessor
+import com.intellij.debugger.jdi.LocalVariablesUtil
+import com.siyeh.ig.psiutils.VariableAccessUtils
+import com.google.dart.compiler.util.AstUtil
+import com.intellij.find.FindManager
+import com.intellij.find.impl.FindManagerImpl
+import com.intellij.usageView.UsageInfo
+import com.intellij.util.Processor
+import org.jetbrains.jet.plugin.findUsages.KotlinPropertyFindUsagesOptions
+
+public class RemoveForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""remove.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val parameter = element.getMultiParameter()!!
+        val range = element.getLoopRange() as JetDotQualifiedExpression
+        val parameters = parameter.getEntries()
+        if (parameters.size() == 2) {
+            parameter.replace(parameters[1])
+        } else {
+            JetPsiUtil.deleteElementWithDelimiters(parameters[0])
+        }
+
+        range.replace(range.getReceiverExpression())
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getMultiParameter() == null) return false
+        val range = element.getLoopRange() as? JetDotQualifiedExpression ?: return false
+        val selector = range.getSelectorExpression() ?: return false
+        if (!selector.textMatches(""withIndices()"")) return false
+
+        val indexVar = element.getMultiParameter()!!.getEntries()[0]
+
+        val findManager = FindManager.getInstance(element.getProject()) as FindManagerImpl
+        val findHandler = findManager.getFindUsagesManager().getFindUsagesHandler(indexVar,false) ?: return false
+        val options = KotlinPropertyFindUsagesOptions(element.getProject())
+        val usageCount = array(0)
+        val usageFinderRunnable = object : Runnable {
+            override fun run() {
+                val processor = object : Processor<UsageInfo> {
+                    override fun process(t: UsageInfo?): Boolean {
+                        usageCount[0] = usageCount[0] + 1
+                        return true
+                    }
+                }
+                findHandler.processElementUsages(indexVar,processor,options)
+            }
+        }
+        usageFinderRunnable.run()
+        return usageCount[0] == 0","Similarly to the first intention, I think we should check here if `withIndices` is actually resolved to `kotlin.withIndices` (don't forget about a test)
",I don't think you need this
495,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.fileEditor.FileEditorManager;
+import com.intellij.openapi.project.Project;
+import com.intellij.openapi.vfs.VirtualFile;
+import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
+import com.intellij.psi.PsiReference;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.psi.*;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class CreateClassObjectFromUsageFix extends CreateFromUsageFixBase {
+    private final JetClass klass;
+
+    public CreateClassObjectFromUsageFix(@NotNull PsiElement element, @NotNull JetClass klass) {
+        super(element);
+        this.klass = klass;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""create.class.object.from.usage"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        PsiFile containingFile = klass.getContainingFile();
+        VirtualFile virtualFile = containingFile.getVirtualFile();
+        assert virtualFile != null;
+        FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);
+        fileEditorManager.openFile(virtualFile, true);","This piece of code can be replaced with `NavigationUtil.activateFileWithPsiElement(klass)`
",I don't think you need this
496,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.jet.plugin.intentions
+
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.ValueArgument
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class GetToSquareBracketsIntention : JetSelfTargetingIntention<JetCallExpression>(""get.to.square.brackets"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        val expression = element.getCalleeExpression() as? JetSimpleNameExpression
+
+        if (expression?.getReferencedName() != ""get"")
+            return false
+
+        if (element.getValueArguments().isEmpty())
+            return false
+
+        val arguments = element.getValueArguments()","You declare this variable here, but for some reason only use it once: in other places, you still call `element.getValueArguments()`
",I don't think this check is necessary.
497,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.jet.plugin.intentions
+
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.ValueArgument
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class GetToSquareBracketsIntention : JetSelfTargetingIntention<JetCallExpression>(""get.to.square.brackets"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        val expression = element.getCalleeExpression() as? JetSimpleNameExpression
+
+        if (expression?.getReferencedName() != ""get"")
+            return false
+
+        if (element.getValueArguments().isEmpty())
+            return false
+
+        val arguments = element.getValueArguments()
+
+        for (argument in arguments) {
+            if (argument?.getArgumentExpression().equals(null))","Note that in Kotlin `==` is equivalent to `equals`. The former looks a lot more readable, so we usually prefer it over `equals`
",I don't think this check is necessary.
498,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.jet.plugin.intentions
+
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.ValueArgument
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class GetToSquareBracketsIntention : JetSelfTargetingIntention<JetCallExpression>(""get.to.square.brackets"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        val expression = element.getCalleeExpression() as? JetSimpleNameExpression
+
+        if (expression?.getReferencedName() != ""get"")
+            return false
+
+        if (element.getValueArguments().isEmpty())
+            return false
+
+        val arguments = element.getValueArguments()
+
+        for (argument in arguments) {
+            if (argument?.getArgumentExpression().equals(null))
+                return false
+        }
+
+        if (element.getValueArguments().any() { it!!.isNamed() })","Please don't just copy-paste code without adapting it :) Here you use `any`, but a few lines earlier you use a hand-written for-loop. You should attempt to use similar constructs for similar intents: either `any` everywhere, or for-loops everywhere. You can also combine these two and save a few lines
",I don't think this check is necessary.
499,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.jet.plugin.intentions
+
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.ValueArgument
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class GetToSquareBracketsIntention : JetSelfTargetingIntention<JetCallExpression>(""get.to.square.brackets"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        val expression = element.getCalleeExpression() as? JetSimpleNameExpression
+
+        if (expression?.getReferencedName() != ""get"")
+            return false
+
+        if (element.getValueArguments().isEmpty())
+            return false
+
+        val arguments = element.getValueArguments()
+
+        for (argument in arguments) {
+            if (argument?.getArgumentExpression().equals(null))
+                return false
+        }
+
+        if (element.getValueArguments().any() { it!!.isNamed() })
+            return false
+
+        return element.getTypeArguments().isEmpty() && element.getFunctionLiteralArguments().isEmpty()
+
+    }
+
+    override fun applyTo(element: JetCallExpression, editor: Editor) {
+        val parentElement = element.getParent()
+        val parentExpression: String?
+
+        if (parentElement is JetDotQualifiedExpression) {
+            parentExpression = parentElement.getReceiverExpression().getText()
+        } else {
+            return","`return` in `applyTo` should give you a hint that's something's not right: your `isApplicableTo` should've already filtered out inapplicable usages and `applyTo` should only _apply_ the intention on a good code. Here it appears that your intention says that it **is applicable** to expressions other than `JetDotQualifiedExpression` (in `isApplicable`), but `applyTo` doesn't do anything on them. As a result, your intention is available on `get(0)` (without any receiver expression), but does nothing, which is not right for an intention
",I don't think this check is necessary.
500,"@@ -0,0 +1,84 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.jet.plugin.intentions
+
+
+import org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+import com.intellij.psi.PsiElement
+import org.jetbrains.jet.lang.psi.JetArrayAccessExpression
+import org.jetbrains.jet.lang.psi.ValueArgument
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetSimpleNameExpression
+
+public class GetToSquareBracketsIntention : JetSelfTargetingIntention<JetCallExpression>(""get.to.square.brackets"", javaClass()) {
+
+    override fun isApplicableTo(element: JetCallExpression): Boolean {
+        val expression = element.getCalleeExpression() as? JetSimpleNameExpression
+
+        if (expression?.getReferencedName() != ""get"")
+            return false
+
+        if (element.getValueArguments().isEmpty())
+            return false
+
+        val arguments = element.getValueArguments()
+
+        for (argument in arguments) {
+            if (argument?.getArgumentExpression().equals(null))
+                return false
+        }
+
+        if (element.getValueArguments().any() { it!!.isNamed() })
+            return false
+
+        return element.getTypeArguments().isEmpty() && element.getFunctionLiteralArguments().isEmpty()
+
+    }
+
+    override fun applyTo(element: JetCallExpression, editor: Editor) {
+        val parentElement = element.getParent()
+        val parentExpression: String?
+
+        if (parentElement is JetDotQualifiedExpression) {
+            parentExpression = parentElement.getReceiverExpression().getText()
+        } else {
+            return
+        }
+        var expressionString = StringBuilder()
+        expressionString.append(parentExpression)
+        expressionString.append(""["")
+        val arguments = element.getValueArguments()
+        val numberOfArguments = arguments.size()","This variable is no longer used. Please watch out for compilation warnings in your code (yellow spots on the scroll bar in IDEA)
",I don't think this check is necessary.
501,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lexer.JetTokens
+import com.intellij.psi.impl.source.tree.PsiErrorElementImpl
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+
+
+public class ConvertNegatedBooleanSequenceIntention : JetSelfTargetingIntention<JetBinaryExpression>(
+        ""convert.negated.boolean.sequence"", javaClass()) {
+
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        if (element.getParent() is JetBinaryExpression) return false // operate only on the longest sequence
+        var binaryExpression = element : JetBinaryExpression?","Maybe 'var binaryExpression : JetBinaryExpression? = element' would be best
",I don't think you need the `isApplicab
502,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lexer.JetTokens
+import com.intellij.psi.impl.source.tree.PsiErrorElementImpl
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+
+
+public class ConvertNegatedBooleanSequenceIntention : JetSelfTargetingIntention<JetBinaryExpression>(
+        ""convert.negated.boolean.sequence"", javaClass()) {
+
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        if (element.getParent() is JetBinaryExpression) return false // operate only on the longest sequence
+        var binaryExpression = element : JetBinaryExpression?
+        val originalOperator = element.getOperationToken()
+","What about Demorgan transformation here?
",I don't think you need this line.
503,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetPrefixExpression
+import org.jetbrains.jet.lexer.JetTokens
+import com.intellij.psi.impl.source.tree.PsiErrorElementImpl
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import org.jetbrains.jet.lang.psi.JetPsiUtil
+
+
+public class ConvertNegatedBooleanSequenceIntention : JetSelfTargetingIntention<JetBinaryExpression>(
+        ""convert.negated.boolean.sequence"", javaClass()) {
+
+    override fun isApplicableTo(element: JetBinaryExpression): Boolean {
+        if (element.getParent() is JetBinaryExpression) return false // operate only on the longest sequence
+        var binaryExpression = element : JetBinaryExpression?
+        val originalOperator = element.getOperationToken()
+
+        if (!(originalOperator == (JetTokens.ANDAND)) && !(originalOperator == (JetTokens.OROR))) {
+            return false
+        }
+
+        do {
+            val leftChild = binaryExpression?.getFirstChild()
+            val rightChild = binaryExpression?.getLastChild()
+            val operator = binaryExpression?.getOperationToken()
+            when {
+                rightChild !is JetPrefixExpression,
+                rightChild is PsiErrorElementImpl,","Why you need 'rightChild is PsiErrorElementImpl' check?
",I don't think you need the `?` here.
504,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {","This still handles only a random subset of PSI elements. The correct way to handle this is to override `visitKtElement` and to look for all children with element type `KtTokens.IDENTIFIER`, similar to how it's done [here](https://github.com/JetBrains/intellij-community/blob/b6dcce52194f52c921c414b7ccc01dbb3363cc7d/platform/core-impl/src/com/intellij/extapi/psi/ASTDelegatePsiElement.java#L230)",I don't think we need the `isOnTheFly`
505,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                val nameIdentifier = property.nameIdentifier ?: return
+                if (isRedundantBackticks(nameIdentifier)) {
+                    registerProblem(holder, nameIdentifier)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                function.valueParameters.map {
+                    val nameIdentifier = it.nameIdentifier ?: return@map
+                    if (isRedundantBackticks(nameIdentifier)) {
+                        registerProblem(holder, nameIdentifier)
+                    }
+                }
+            }
+
+            override fun visitReferenceExpression(expression: KtReferenceExpression) {
+                super.visitReferenceExpression(expression)
+                val bindingContext = expression.analyze()
+                expression.getResolvedCall(bindingContext) ?: return
+                if (isRedundantBackticks(expression)) {
+                    registerProblem(holder, expression)
+                }
+            }
+        }
+    }
+
+    private fun isKeyword(text: String): Boolean {",Backticks can also be used to enclose identifiers containing spaces and other characters not allowed in Java identifiers. In this case they must not be highlighted as redundant.,I don't think you need the `?:` here.
506,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                val nameIdentifier = property.nameIdentifier ?: return
+                if (isRedundantBackticks(nameIdentifier)) {
+                    registerProblem(holder, nameIdentifier)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                function.valueParameters.map {
+                    val nameIdentifier = it.nameIdentifier ?: return@map
+                    if (isRedundantBackticks(nameIdentifier)) {
+                        registerProblem(holder, nameIdentifier)
+                    }
+                }
+            }
+
+            override fun visitReferenceExpression(expression: KtReferenceExpression) {
+                super.visitReferenceExpression(expression)
+                val bindingContext = expression.analyze()
+                expression.getResolvedCall(bindingContext) ?: return
+                if (isRedundantBackticks(expression)) {
+                    registerProblem(holder, expression)
+                }
+            }
+        }
+    }
+
+    private fun isKeyword(text: String): Boolean {
+        return (KtTokens.KEYWORDS.types + KtTokens.SOFT_KEYWORDS.types).any { it.toString() == text }
+    }
+
+    private fun isRedundantBackticks(element: PsiElement): Boolean {
+        return (element.text.contains(""^`.+`$"".toRegex()) &&",Please don't use regular expressions here. Use `startsWith` and `endsWith`.,I don't think you need the `?:` here.
507,"@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiElementVisitor
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RemoveRedundantBackticksInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                val nameIdentifier = property.nameIdentifier ?: return
+                if (isRedundantBackticks(nameIdentifier)) {
+                    registerProblem(holder, nameIdentifier)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                function.valueParameters.map {
+                    val nameIdentifier = it.nameIdentifier ?: return@map
+                    if (isRedundantBackticks(nameIdentifier)) {
+                        registerProblem(holder, nameIdentifier)
+                    }
+                }
+            }
+
+            override fun visitReferenceExpression(expression: KtReferenceExpression) {
+                super.visitReferenceExpression(expression)
+                val bindingContext = expression.analyze()
+                expression.getResolvedCall(bindingContext) ?: return
+                if (isRedundantBackticks(expression)) {
+                    registerProblem(holder, expression)
+                }
+            }
+        }
+    }
+
+    private fun isKeyword(text: String): Boolean {
+        return (KtTokens.KEYWORDS.types + KtTokens.SOFT_KEYWORDS.types).any { it.toString() == text }
+    }
+
+    private fun isRedundantBackticks(element: PsiElement): Boolean {
+        return (element.text.contains(""^`.+`$"".toRegex()) &&
+                !isKeyword(element.text.removePrefix(""`"").removeSuffix(""`"")))
+    }
+
+    private fun registerProblem(holder: ProblemsHolder, element: PsiElement) {
+        holder.registerProblem(element,
+                               ""Remove redundant backticks"",
+                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING,
+                               RemoveRedundantBackticksQuickFix())
+    }
+}
+
+class RemoveRedundantBackticksQuickFix : LocalQuickFix {
+    override fun getName() = ""Remove redundant backticks""
+    override fun getFamilyName() = name
+
+    override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+        val element = descriptor.psiElement
+        val factory = KtPsiFactory(project)
+        element.replace(factory.createExpression(element.text.removePrefix(""`"").removeSuffix(""`"")))","If you replace an arbitrary element in a PSI tree (such as the name identifier of a property) with an expression, this will create an invalid PSI structure and will break other code insight features until the file contents is reparsed. You need to always replace an element with another element of the same type (in this case, an identifier with an identifier). Use `KtPsiFactory.createIdentifier()`.",I don't think you need the `?:` here.
508,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.JetParameter;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.lang.psi.JetTypeReference;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class ChangeTypeFix extends JetIntentionAction<JetTypeReference> {
+    private JetType type;","Field may be 'final'
",I don't think you need this class.
509,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.JetParameter;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.lang.psi.JetTypeReference;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class ChangeTypeFix extends JetIntentionAction<JetTypeReference> {
+    private JetType type;
+
+    public ChangeTypeFix(@NotNull JetTypeReference element, JetType type) {
+        super(element);
+        this.type = type;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""change.type"", element.getText(), type);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""change.type.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        element.replace(JetPsiFactory.createType(project, type.toString()));
+    }
+
+    @NotNull
+    public static JetIntentionActionFactory createFactoryForExpectedParameterTypeMismatch() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetParameter property = QuickFixUtil.getParentElementOfType(diagnostic, JetParameter.class);","Add please checking for diagnostic factory. Look like line 91 in `idea/src/org/jetbrains/jet/plugin/quickfix/AddStarProjectionsFix.java`
",I don't think you need this annotation
510,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.JetParameter;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.lang.psi.JetTypeReference;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class ChangeTypeFix extends JetIntentionAction<JetTypeReference> {
+    private JetType type;
+
+    public ChangeTypeFix(@NotNull JetTypeReference element, JetType type) {
+        super(element);
+        this.type = type;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""change.type"", element.getText(), type);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""change.type.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        element.replace(JetPsiFactory.createType(project, type.toString()));
+    }
+
+    @NotNull
+    public static JetIntentionActionFactory createFactoryForExpectedParameterTypeMismatch() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetParameter property = QuickFixUtil.getParentElementOfType(diagnostic, JetParameter.class);
+                assert property != null : ""EXPECTED_PARAMETER_TYPE_MISMATCH reported on element that is not within any property"";
+                JetTypeReference typeReference = property.getTypeReference();
+                JetType type = ((DiagnosticWithParameters1<JetParameter, JetType>) diagnostic).getA();","Use SuppressWarnings, please, like line 92-95 in `idea/src/org/jetbrains/jet/plugin/quickfix/AddStarProjectionsFix.java`
",I don't think you need this annotation
511,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.JetParameter;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.lang.psi.JetTypeReference;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class ChangeTypeFix extends JetIntentionAction<JetTypeReference> {
+    private JetType type;
+
+    public ChangeTypeFix(@NotNull JetTypeReference element, JetType type) {
+        super(element);
+        this.type = type;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""change.type"", element.getText(), type);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""change.type.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        element.replace(JetPsiFactory.createType(project, type.toString()));
+    }
+
+    @NotNull
+    public static JetIntentionActionFactory createFactoryForExpectedParameterTypeMismatch() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetParameter property = QuickFixUtil.getParentElementOfType(diagnostic, JetParameter.class);
+                assert property != null : ""EXPECTED_PARAMETER_TYPE_MISMATCH reported on element that is not within any property"";
+                JetTypeReference typeReference = property.getTypeReference();
+                JetType type = ((DiagnosticWithParameters1<JetParameter, JetType>) diagnostic).getA();
+                return typeReference == null ? null : new ChangeTypeFix(typeReference, type);","Maybe `typeReference == null` should be just `assert`
",I don't think you need this annotation
512,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2013 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.quickfix;
+
+import com.intellij.codeInsight.intention.IntentionAction;
+import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.project.Project;
+import com.intellij.psi.PsiFile;
+import com.intellij.util.IncorrectOperationException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.jet.lang.diagnostics.Diagnostic;
+import org.jetbrains.jet.lang.diagnostics.DiagnosticWithParameters1;
+import org.jetbrains.jet.lang.psi.JetParameter;
+import org.jetbrains.jet.lang.psi.JetPsiFactory;
+import org.jetbrains.jet.lang.psi.JetTypeReference;
+import org.jetbrains.jet.lang.types.JetType;
+import org.jetbrains.jet.plugin.JetBundle;
+
+public class ChangeTypeFix extends JetIntentionAction<JetTypeReference> {
+    private JetType type;
+
+    public ChangeTypeFix(@NotNull JetTypeReference element, JetType type) {
+        super(element);
+        this.type = type;
+    }
+
+    @NotNull
+    @Override
+    public String getText() {
+        return JetBundle.message(""change.type"", element.getText(), type);
+    }
+
+    @NotNull
+    @Override
+    public String getFamilyName() {
+        return JetBundle.message(""change.type.family"");
+    }
+
+    @Override
+    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {
+        element.replace(JetPsiFactory.createType(project, type.toString()));
+    }
+
+    @NotNull
+    public static JetIntentionActionFactory createFactoryForExpectedParameterTypeMismatch() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetParameter property = QuickFixUtil.getParentElementOfType(diagnostic, JetParameter.class);
+                assert property != null : ""EXPECTED_PARAMETER_TYPE_MISMATCH reported on element that is not within any property"";
+                JetTypeReference typeReference = property.getTypeReference();
+                JetType type = ((DiagnosticWithParameters1<JetParameter, JetType>) diagnostic).getA();
+                return typeReference == null ? null : new ChangeTypeFix(typeReference, type);
+            }
+        };
+    }
+
+    @NotNull
+    public static JetIntentionActionFactory createFactoryForExpectedReturnTypeMismatch() {
+        return new JetIntentionActionFactory() {
+            @Nullable
+            @Override
+            public IntentionAction createAction(Diagnostic diagnostic) {
+                JetTypeReference typeReference = QuickFixUtil.getParentElementOfType(diagnostic, JetTypeReference.class);
+                assert typeReference != null : ""EXPECTED_RETURN_TYPE_MISMATCH reported on element that is not a type reference"";
+                JetType type = ((DiagnosticWithParameters1<JetTypeReference, JetType>) diagnostic).getA();","Use SuppressWarnings, please.
",I don't think you need this annotation.
513,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.util.PsiTreeUtil
+import com.intellij.psi.PsiDocumentManager
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.di.InjectorForMacros
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.TypeUtils
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.resolve.calls.autocasts.DataFlowInfo
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import com.intellij.codeInsight.template.TemplateBuilderImpl
+import com.intellij.codeInsight.template.impl.TemplateManagerImpl
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import org.jetbrains.jet.lang.descriptors.ModuleDescriptor
+
+
+public class AddForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""add.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val loopRange = element.getLoopRange()!!
+        val newRangeText = ""${loopRange.getText()}.withIndices()""
+        val newRange = JetPsiFactory.createExpression(editor.getProject(), newRangeText)
+
+        //Roundabout way to create new multiparameter element so as not to incorrectly trigger syntax error highlighting
+        val loopParameter = element.getLoopParameter()!!
+        val parenthesizedParam = JetPsiFactory.createExpression(editor.getProject(), ""(index)"") as JetParenthesizedExpression
+        val indexElement = parenthesizedParam.getExpression()!!
+        val comma = JetPsiFactory.createComma(editor.getProject())
+        val newParamElement = JetPsiFactory.createExpression(editor.getProject(), "" ${loopParameter.getText()}"")
+        parenthesizedParam.addAfter(newParamElement, indexElement)
+        parenthesizedParam.addAfter(comma, indexElement)
+
+        loopParameter.replace(parenthesizedParam)
+        loopRange.replace(newRange)
+
+        val multiParameter = PsiTreeUtil.findChildOfType(element, indexElement.javaClass)!!
+
+        editor.getCaretModel().moveToOffset(multiParameter.getTextOffset())
+        val templateBuilder = TemplateBuilderImpl(multiParameter)
+        templateBuilder.replaceElement(multiParameter, ""index"")
+        val manager = TemplateManagerImpl(editor.getProject())
+        PsiDocumentManager.getInstance(editor.getProject()!!).doPostponedOperationsAndUnblockDocument(editor.getDocument())
+        manager.startTemplate(editor, templateBuilder.buildInlineTemplate()!!)
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getLoopParameter() == null) return false
+        val range = element.getLoopRange() ?: return false
+        if (range is JetDotQualifiedExpression) {
+            val selector = (range as JetDotQualifiedExpression).getSelectorExpression() ?: return true","You don't need this cast (experience the power of Kotlin)
",I don't think you need this import.
514,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.util.PsiTreeUtil
+import com.intellij.psi.PsiDocumentManager
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.di.InjectorForMacros
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.TypeUtils
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.resolve.calls.autocasts.DataFlowInfo
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import com.intellij.codeInsight.template.TemplateBuilderImpl
+import com.intellij.codeInsight.template.impl.TemplateManagerImpl
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import org.jetbrains.jet.lang.descriptors.ModuleDescriptor
+
+
+public class AddForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""add.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val loopRange = element.getLoopRange()!!
+        val newRangeText = ""${loopRange.getText()}.withIndices()""
+        val newRange = JetPsiFactory.createExpression(editor.getProject(), newRangeText)
+
+        //Roundabout way to create new multiparameter element so as not to incorrectly trigger syntax error highlighting
+        val loopParameter = element.getLoopParameter()!!
+        val parenthesizedParam = JetPsiFactory.createExpression(editor.getProject(), ""(index)"") as JetParenthesizedExpression
+        val indexElement = parenthesizedParam.getExpression()!!
+        val comma = JetPsiFactory.createComma(editor.getProject())
+        val newParamElement = JetPsiFactory.createExpression(editor.getProject(), "" ${loopParameter.getText()}"")
+        parenthesizedParam.addAfter(newParamElement, indexElement)
+        parenthesizedParam.addAfter(comma, indexElement)
+
+        loopParameter.replace(parenthesizedParam)
+        loopRange.replace(newRange)
+
+        val multiParameter = PsiTreeUtil.findChildOfType(element, indexElement.javaClass)!!
+
+        editor.getCaretModel().moveToOffset(multiParameter.getTextOffset())
+        val templateBuilder = TemplateBuilderImpl(multiParameter)
+        templateBuilder.replaceElement(multiParameter, ""index"")
+        val manager = TemplateManagerImpl(editor.getProject())
+        PsiDocumentManager.getInstance(editor.getProject()!!).doPostponedOperationsAndUnblockDocument(editor.getDocument())
+        manager.startTemplate(editor, templateBuilder.buildInlineTemplate()!!)
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getLoopParameter() == null) return false
+        val range = element.getLoopRange() ?: return false
+        if (range is JetDotQualifiedExpression) {
+            val selector = (range as JetDotQualifiedExpression).getSelectorExpression() ?: return true
+            if (selector.getText().equals(""withIndices()"")) return false","Please use `==` instead of `equals` in Kotlin code
",I don't think you need this import.
515,"@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import com.intellij.psi.util.PsiTreeUtil
+import com.intellij.psi.PsiDocumentManager
+import org.jetbrains.jet.plugin.project.AnalyzerFacadeWithCache
+import org.jetbrains.jet.di.InjectorForMacros
+import org.jetbrains.jet.lang.resolve.BindingContext
+import org.jetbrains.jet.lang.types.TypeUtils
+import org.jetbrains.jet.lang.resolve.ObservableBindingTrace
+import org.jetbrains.jet.lang.resolve.BindingTraceContext
+import org.jetbrains.jet.lang.resolve.calls.autocasts.DataFlowInfo
+import org.jetbrains.jet.lang.psi.JetParenthesizedExpression
+import com.intellij.codeInsight.template.TemplateBuilderImpl
+import com.intellij.codeInsight.template.impl.TemplateManagerImpl
+import org.jetbrains.jet.lang.resolve.DescriptorUtils
+import org.jetbrains.jet.lang.descriptors.ModuleDescriptor
+
+
+public class AddForLoopIndicesIntention : JetSelfTargetingIntention<JetForExpression>(
+        ""add.for.loop.indices"", javaClass()) {
+    override fun applyTo(element: JetForExpression, editor: Editor) {
+        val loopRange = element.getLoopRange()!!
+        val newRangeText = ""${loopRange.getText()}.withIndices()""
+        val newRange = JetPsiFactory.createExpression(editor.getProject(), newRangeText)
+
+        //Roundabout way to create new multiparameter element so as not to incorrectly trigger syntax error highlighting
+        val loopParameter = element.getLoopParameter()!!
+        val parenthesizedParam = JetPsiFactory.createExpression(editor.getProject(), ""(index)"") as JetParenthesizedExpression
+        val indexElement = parenthesizedParam.getExpression()!!
+        val comma = JetPsiFactory.createComma(editor.getProject())
+        val newParamElement = JetPsiFactory.createExpression(editor.getProject(), "" ${loopParameter.getText()}"")
+        parenthesizedParam.addAfter(newParamElement, indexElement)
+        parenthesizedParam.addAfter(comma, indexElement)
+
+        loopParameter.replace(parenthesizedParam)
+        loopRange.replace(newRange)
+
+        val multiParameter = PsiTreeUtil.findChildOfType(element, indexElement.javaClass)!!
+
+        editor.getCaretModel().moveToOffset(multiParameter.getTextOffset())
+        val templateBuilder = TemplateBuilderImpl(multiParameter)
+        templateBuilder.replaceElement(multiParameter, ""index"")
+        val manager = TemplateManagerImpl(editor.getProject())
+        PsiDocumentManager.getInstance(editor.getProject()!!).doPostponedOperationsAndUnblockDocument(editor.getDocument())
+        manager.startTemplate(editor, templateBuilder.buildInlineTemplate()!!)
+    }
+
+    override fun isApplicableTo(element: JetForExpression): Boolean {
+        if (element.getLoopParameter() == null) return false
+        val range = element.getLoopRange() ?: return false
+        if (range is JetDotQualifiedExpression) {
+            val selector = (range as JetDotQualifiedExpression).getSelectorExpression() ?: return true
+            if (selector.getText().equals(""withIndices()"")) return false
+        }
+
+        val potentialExpression = JetPsiFactory.createExpression(element.getProject(), ""${range.getText()}.withIndices()"")
+        val bindingContext = AnalyzerFacadeWithCache.getContextForElement(element)
+        val scope = bindingContext[BindingContext.RESOLUTION_SCOPE, element] ?: return false
+        val module = DescriptorUtils.getParentOfType(scope.getContainingDeclaration(), javaClass<ModuleDescriptor>())!!
+        val components = InjectorForMacros(element.getProject(), module)
+        val dataFlowInfo = bindingContext[BindingContext.NON_DEFAULT_EXPRESSION_DATA_FLOW, element] ?: DataFlowInfo.EMPTY
+        val bindingTrace = ObservableBindingTrace(BindingTraceContext())
+        val expressionType = components.getExpressionTypingServices()!!.getTypeInfo(scope, potentialExpression, TypeUtils.NO_EXPECTED_TYPE, dataFlowInfo, bindingTrace)
+        return expressionType.getType() != null","Do you allow to use the intention only if the resulting code will be green? In that case, I'm not sure what's wrong, but it's still applicable whenever there are errors in the initial code, e.g.

```
fun foo() {
    for (a in b) { // <-- still applicable here, although 'b' is unresolved
    }
}
```
",I don't think you need this import.
516,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.impl.source.tree.LeafPsiElement
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.imports.importableFqName
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RedundantProgressionStepInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                if (isStepOneCall(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Iteration step is redundant. Recommended to remove it."",","No need to say ""Recommended..."" in the problem description; ""redundant"" implies that already.",I don't think we need this import.
517,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.impl.source.tree.LeafPsiElement
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.imports.importableFqName
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RedundantProgressionStepInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                if (isStepOneCall(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Iteration step is redundant. Recommended to remove it."",
+                                           ProblemHighlightType.WEAK_WARNING,
+                                           TextRange(expression.operationReference.startOffsetInParent, expression.endOffset - expression.startOffset),
+                                           EliminateStepOneFix())
+                }
+            }
+        }
+    }
+
+
+    class EliminateStepOneFix : LocalQuickFix {
+        override fun getName() = ""Eliminate redundant iteration step size""
+
+        override fun getFamilyName() = name
+
+        override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+            if (!FileModificationService.getInstance().preparePsiElementForWrite(descriptor.psiElement)) return
+            val expression = descriptor.psiElement as? KtBinaryExpression ?: return","This only handles ""step"" called as an infix function; would be better to handle regular ""step"" calls too.",I don't think we need this import.
518,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.impl.source.tree.LeafPsiElement
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.imports.importableFqName
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RedundantProgressionStepInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                if (isStepOneCall(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Iteration step is redundant. Recommended to remove it."",
+                                           ProblemHighlightType.WEAK_WARNING,
+                                           TextRange(expression.operationReference.startOffsetInParent, expression.endOffset - expression.startOffset),
+                                           EliminateStepOneFix())
+                }
+            }
+        }
+    }
+
+
+    class EliminateStepOneFix : LocalQuickFix {
+        override fun getName() = ""Eliminate redundant iteration step size""
+
+        override fun getFamilyName() = name
+
+        override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+            if (!FileModificationService.getInstance().preparePsiElementForWrite(descriptor.psiElement)) return
+            val expression = descriptor.psiElement as? KtBinaryExpression ?: return
+            if (!isStepOneCall(expression)) return
+            expression.replaced(expression.left!!)
+        }
+    }
+
+    companion object {
+        private val STEP_FUNCTION_FQ_NAME = ""kotlin.ranges.step""
+
+        fun isStepOneCall(expression: KtBinaryExpression): Boolean {
+            val left = expression.left as? KtBinaryExpression ?: return false",You should use KtPsiUtil.deparenthesize() to handle the case when the range expression is in parentheses.,I don't think we need this import.
519,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import com.intellij.openapi.util.TextRange
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.impl.source.tree.LeafPsiElement
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.idea.imports.importableFqName
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.KtBinaryExpression
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtVisitorVoid
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
+import org.jetbrains.kotlin.resolve.BindingContext
+import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
+
+class RedundantProgressionStepInspection : AbstractKotlinInspection() {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitBinaryExpression(expression: KtBinaryExpression) {
+                if (isStepOneCall(expression)) {
+                    holder.registerProblem(expression,
+                                           ""Iteration step is redundant. Recommended to remove it."",
+                                           ProblemHighlightType.WEAK_WARNING,
+                                           TextRange(expression.operationReference.startOffsetInParent, expression.endOffset - expression.startOffset),
+                                           EliminateStepOneFix())
+                }
+            }
+        }
+    }
+
+
+    class EliminateStepOneFix : LocalQuickFix {
+        override fun getName() = ""Eliminate redundant iteration step size""
+
+        override fun getFamilyName() = name
+
+        override fun applyFix(project: Project, descriptor: ProblemDescriptor) {
+            if (!FileModificationService.getInstance().preparePsiElementForWrite(descriptor.psiElement)) return
+            val expression = descriptor.psiElement as? KtBinaryExpression ?: return
+            if (!isStepOneCall(expression)) return
+            expression.replaced(expression.left!!)
+        }
+    }
+
+    companion object {
+        private val STEP_FUNCTION_FQ_NAME = ""kotlin.ranges.step""
+
+        fun isStepOneCall(expression: KtBinaryExpression): Boolean {
+            val left = expression.left as? KtBinaryExpression ?: return false
+            if (left.operationToken != KtTokens.RANGE) return false
+            if (expression.operationReference.text != ""step"") return false
+            val right = expression.right as? KtConstantExpression ?: return false
+            val rightConst = right.firstChild as? LeafPsiElement ?: return false
+            if (rightConst.elementType != KtTokens.INTEGER_LITERAL) return false
+
+            if (rightConst.text !in setOf(""1"", ""1L"")) return false",Please use ConstantExpressionEvaluator.getConstant() instead.,I don't think we need this import.
520,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.addRemoveModifier.addModifier
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {","This should check val/var parameters defined in the primary constructor, too (KtParameter)",I don't think we need the `isOnTheFly` 
521,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.addRemoveModifier.addModifier
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        val modifiers = declaration.modifierList
+        if (modifiers != null && (modifiers.hasModifier(KtTokens.PRIVATE_KEYWORD) || modifiers.hasModifier(KtTokens.OVERRIDE_KEYWORD))) return false",You can use `declaration.hasModifier()` directly,I don't think we need the `isOnTheFly` 
522,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.addRemoveModifier.addModifier
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        val modifiers = declaration.modifierList
+        if (modifiers != null && (modifiers.hasModifier(KtTokens.PRIVATE_KEYWORD) || modifiers.hasModifier(KtTokens.OVERRIDE_KEYWORD))) return false
+        val klass = (declaration.parent as? KtClassBody)?.parent as? KtClass ?: return false
+        if (!klass.isInheritable() && modifiers?.hasModifier(KtTokens.PROTECTED_KEYWORD) ?: false) return false //reported by ProtectedInFinalInspection
+        if (declaration.isOverridable()) return false
+        val allUsages = ReferencesSearch.search(declaration, declaration.useScope).count()","This is very inefficient: usages search is an expensive operation and most of the cost is wasted. You should iterate over all usages and stop as soon as you find one outside the local search scope.

See also the [corresponding Java inspection](https://github.com/JetBrains/intellij-community/blob/master/java/java-analysis-impl/src/com/intellij/codeInspection/visibility/AccessCanBeTightenedInspection.java#L143) for inspiration.",I don't think we need the `isOnTheFly` 
523,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInsight.FileModificationService
+import com.intellij.codeInspection.LocalQuickFix
+import com.intellij.codeInspection.ProblemDescriptor
+import com.intellij.codeInspection.ProblemHighlightType
+import com.intellij.codeInspection.ProblemsHolder
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.addRemoveModifier.addModifier
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        val modifiers = declaration.modifierList
+        if (modifiers != null && (modifiers.hasModifier(KtTokens.PRIVATE_KEYWORD) || modifiers.hasModifier(KtTokens.OVERRIDE_KEYWORD))) return false
+        val klass = (declaration.parent as? KtClassBody)?.parent as? KtClass ?: return false
+        if (!klass.isInheritable() && modifiers?.hasModifier(KtTokens.PROTECTED_KEYWORD) ?: false) return false //reported by ProtectedInFinalInspection
+        if (declaration.isOverridable()) return false
+        val allUsages = ReferencesSearch.search(declaration, declaration.useScope).count()
+        if (allUsages == 0) return false
+        val classUsages = ReferencesSearch.search(declaration, LocalSearchScope(klass)).count()
+        if (allUsages != classUsages)
+            return false
+        return true
+    }
+
+    private fun registerProblem(holder: ProblemsHolder, declaration: KtDeclaration) {
+        holder.registerProblem(declaration,
+                               ""Can have 'private' visibility"",
+                               ProblemHighlightType.WEAK_WARNING,
+                               MakePrivateFix())
+    }
+
+    class MakePrivateFix : LocalQuickFix {",You can reuse `AddModifierFix`,I don't think we need the `isOnTheFly` 
524,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.quickfix.AddModifierFix
+import org.jetbrains.kotlin.idea.refactoring.isConstructorDeclaredProperty
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {",This is now reported on local variables (which are also KtProperty instances).,I don't think you need to override this
525,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.quickfix.AddModifierFix
+import org.jetbrains.kotlin.idea.refactoring.isConstructorDeclaredProperty
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+
+            override fun visitParameter(parameter: KtParameter) {
+                super.visitParameter(parameter)
+                if (parameter.isConstructorDeclaredProperty() && canBePrivate(parameter)) {
+                    registerProblem(holder, parameter)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        if (declaration.hasModifier(KtTokens.PRIVATE_KEYWORD) || declaration.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return false
+        val klass = declaration.containingClass() ?: return false",Wouldn't hurt to handle members of `object` declarations too.,I don't think you need to override this
526,"@@ -0,0 +1,89 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.quickfix.AddModifierFix
+import org.jetbrains.kotlin.idea.refactoring.isConstructorDeclaredProperty
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
+import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
+import org.jetbrains.kotlin.psi.psiUtil.isInheritable
+import org.jetbrains.kotlin.psi.psiUtil.isOverridable
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+
+            override fun visitParameter(parameter: KtParameter) {
+                super.visitParameter(parameter)
+                if (parameter.isConstructorDeclaredProperty() && canBePrivate(parameter)) {
+                    registerProblem(holder, parameter)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        if (declaration.hasModifier(KtTokens.PRIVATE_KEYWORD) || declaration.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return false
+        val klass = declaration.containingClass() ?: return false
+        if (!klass.isInheritable() && declaration.hasModifier(KtTokens.PROTECTED_KEYWORD)) return false //reported by ProtectedInFinalInspection
+        if (declaration.isOverridable()) return false
+        var otherUsageFound = false
+        var inClassUsageFound = false
+        ReferencesSearch.search(declaration, declaration.useScope).forEach(Processor<PsiReference> {
+            val usage = it.element
+            if (klass != usage.getParentOfType<KtClass>(false)) {
+                otherUsageFound = true
+                false
+            } else {
+                inClassUsageFound = true
+                true
+            }
+        })
+        return inClassUsageFound && !otherUsageFound
+    }
+
+    private fun registerProblem(holder: ProblemsHolder, declaration: KtDeclaration) {
+        val modifierListOwner = declaration.getParentOfType<KtModifierListOwner>(false) ?: return
+        holder.registerProblem(declaration,
+                               ""Can have 'private' visibility"",","Better to include name of declaration in the message, otherwise it's hard to understand results of a batch inspection.",I don't think you need to override this
527,"@@ -0,0 +1,9 @@
+// IS_APPLICABLE: false
+// WITH_RUNTIME
+class A(val _value: Int) {
+    operator fun compareTo(other: Int) = _value.compareTo(other)
+}
+
+fun test(a: A): Boolean {
+    return a >= 0 && a <= 100<caret>","My suggested change to KotlinType.isComparable() will break this test, but I think it's OK because this test should be red, and we make no guarantees regarding the behavior of intentions on red code.",Why do we need this?
528,"@@ -0,0 +1,9 @@
+// WITH_RUNTIME
+// IS_APPLICABLE: FALSE
+fun String.withIndices(): Int = 42
+
+fun foo(s: String) {
+    for (<caret>a in s) {
+
+    }
+}","The test is fine, the naming is not: _overridden_ function is a function declaration in a subclass with the same signature as in the superclass. There are no overridden functions here, `withIndices` is just an extension function
",I think this should be `String.withIndices()`
529,"@@ -0,0 +1,9 @@
+interface B {
+    fun c()
+}
+
+
+<spot>object A : B</spot> {",This should be `object a`,I think this should be `<msg>`<msg>`<msg>`<ms
530,"@@ -0,0 +1,91 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.service
+
+import java.io.FilePermission
+import java.net.SocketPermission
+import java.security.CodeSource
+import java.security.Permission
+import java.security.PermissionCollection
+import java.security.Policy
+import java.util.ArrayList
+import java.util.Collections
+import java.util.Enumeration
+import java.util.PropertyPermission
+
+
+public class DaemonPolicy(val port: Int) : Policy() {
+
+    private fun createPermissions(): PermissionCollection {
+        val perms = DaemonPermissionCollection()
+
+        val socketPermission = SocketPermission(""localhost:$port-"", ""connect, accept, resolve"")
+        val propertyPermission = PropertyPermission(""localhost:$port"", ""read"")
+        //val filePermission = FilePermission(""<<ALL FILES>>"", ""read"")
+
+        perms.add(socketPermission)
+        perms.add(propertyPermission)
+        //perms.add(filePermission)
+
+        return perms
+    }
+
+    private val perms: PermissionCollection by lazy { createPermissions() }
+
+    override fun getPermissions(codesource: CodeSource?): PermissionCollection {
+        return perms
+    }
+}
+
+
+class DaemonPermissionCollection : PermissionCollection() {
+    var perms = ArrayList<Permission>()","why `var`?
",Remove unused code.
531,"@@ -0,0 +1,91 @@
+/*
+ * Copyright 2010-2015 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.rmi.service
+
+import java.io.FilePermission
+import java.net.SocketPermission
+import java.security.CodeSource
+import java.security.Permission
+import java.security.PermissionCollection
+import java.security.Policy
+import java.util.ArrayList
+import java.util.Collections
+import java.util.Enumeration
+import java.util.PropertyPermission
+
+
+public class DaemonPolicy(val port: Int) : Policy() {
+
+    private fun createPermissions(): PermissionCollection {
+        val perms = DaemonPermissionCollection()
+
+        val socketPermission = SocketPermission(""localhost:$port-"", ""connect, accept, resolve"")
+        val propertyPermission = PropertyPermission(""localhost:$port"", ""read"")
+        //val filePermission = FilePermission(""<<ALL FILES>>"", ""read"")
+
+        perms.add(socketPermission)
+        perms.add(propertyPermission)
+        //perms.add(filePermission)
+
+        return perms
+    }
+
+    private val perms: PermissionCollection by lazy { createPermissions() }
+
+    override fun getPermissions(codesource: CodeSource?): PermissionCollection {
+        return perms
+    }
+}
+
+
+class DaemonPermissionCollection : PermissionCollection() {
+    var perms = ArrayList<Permission>()
+
+    override fun add(p: Permission) {
+        perms.add(p)
+    }
+
+    override fun implies(p: Permission): Boolean {
+        val i = perms.iterator()","perms.any { it.implies(p) }
",Remove unused code.
532,"@@ -0,0 +1,91 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.psi.PsiElementVisitor
+import com.intellij.psi.PsiReference
+import com.intellij.psi.search.LocalSearchScope
+import com.intellij.psi.search.searches.ReferencesSearch
+import com.intellij.util.Processor
+import org.jetbrains.kotlin.idea.quickfix.AddModifierFix
+import org.jetbrains.kotlin.idea.refactoring.isConstructorDeclaredProperty
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.*
+
+class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
+
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
+        return object : KtVisitorVoid() {
+            override fun visitProperty(property: KtProperty) {
+                super.visitProperty(property)
+                if (!property.isLocal && canBePrivate(property)) {
+                    registerProblem(holder, property)
+                }
+            }
+
+            override fun visitNamedFunction(function: KtNamedFunction) {
+                super.visitNamedFunction(function)
+                if (canBePrivate(function)) {
+                    registerProblem(holder, function)
+                }
+            }
+
+            override fun visitParameter(parameter: KtParameter) {
+                super.visitParameter(parameter)
+                if (parameter.isConstructorDeclaredProperty() && canBePrivate(parameter)) {
+                    registerProblem(holder, parameter)
+                }
+            }
+        }
+    }
+
+
+    private fun canBePrivate(declaration: KtDeclaration): Boolean {
+        if (declaration.hasModifier(KtTokens.PRIVATE_KEYWORD) || declaration.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return false
+        val classOrObject = declaration.containingClassOrObject ?: return false
+        val inheritable = classOrObject is KtClass && classOrObject.isInheritable()
+        if (!inheritable && declaration.hasModifier(KtTokens.PROTECTED_KEYWORD)) return false //reported by ProtectedInFinalInspection
+        if (declaration.isOverridable()) return false
+        var otherUsageFound = false
+        var inClassUsageFound = false
+        ReferencesSearch.search(declaration, declaration.useScope).forEach(Processor<PsiReference> {
+            val usage = it.element
+            if (classOrObject != usage.getParentOfType<KtClassOrObject>(false)) {
+                otherUsageFound = true
+                false
+            } else {
+                inClassUsageFound = true
+                true
+            }
+        })
+        return inClassUsageFound && !otherUsageFound
+    }
+
+    private fun registerProblem(holder: ProblemsHolder, declaration: KtDeclaration) {
+        val modifierListOwner = declaration.getParentOfType<KtModifierListOwner>(false) ?: return
+        val member = when (declaration) {
+            is KtNamedFunction -> ""Function""
+            else -> ""Property""
+        }
+        holder.registerProblem(declaration,","This highlights the entire declaration with a wavy underline, which is very intrusive. Should highlight only the name identifier.",I don't think we need the `isOnTheFly` param 
533,"@@ -0,0 +1,92 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.effectsystem.impls
+
+import org.jetbrains.kotlin.effectsystem.structure.ESClause
+import org.jetbrains.kotlin.effectsystem.structure.EffectSchema
+import org.jetbrains.kotlin.effectsystem.structure.ESExpressionVisitor
+
+class Printer : ESExpressionVisitor<Unit> {
+    private val builder = StringBuilder()
+
+    private fun print(string: String) {
+        builder.append(string)
+    }
+
+    private inline fun line(block: () -> Unit) {
+        block()
+    }
+
+    fun print(schema: EffectSchema) {
+        schema.clauses.forEach { visitClause(it) }
+    }
+
+    fun visitClause(clause: ESClause) {
+        line {
+            clause.condition.accept(this)
+            print("" -> "")",Looks like this arrow has the wrong direction,I think it would be better to use `print` ins
534,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()!!.getText()!!","Your intention would be helpful to make types implicit here :) I think they don't really add anything to readability
",I don't think this is the right place to put 
535,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()!!.getText()!!
+                                              }).makeString("", "", ""("", "")"")
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getNode()?.getElementType() == JetTokens.LPAR) firstChild!!.delete()
+            val lastChild = currentParamList?.getLastChild()
+            if (lastChild?.getNode()?.getElementType() == JetTokens.RPAR) lastChild!!.delete()
+        }
+    }
+
+    fun hasExplicitReturnType(element: JetFunctionLiteralExpression): Boolean {
+        return element.hasDeclaredReturnType()
+    }
+
+    fun hasExplicitReceiverType(element: JetFunctionLiteralExpression): Boolean {
+        return element.getFunctionLiteral().getReceiverTypeRef() != null
+    }
+
+    fun hasExplicitParamType(element: JetFunctionLiteralExpression): Boolean {
+        if (element.getValueParameters().any { it.getTypeReference() != null }) {
+            val parameters = element.getFunctionLiteral().getValueParameterList()?.getParameters()
+            return !(parameters?.any { it.getNameIdentifier()?.getText() == null } ?: false)","This code looks a little awkward to me.

First, consider using other standard library functions such as `none` or `all` instead of `any` to prevent at least some negations.

Second, why can't you iterate the parameter list with one simple `for` and check two conditions for each parameter in the loop body?
",I don't think this is the right place to put 
536,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        val oldParameters = oldParameterList?.getParameters()
+        if (oldParameterList != null && oldParameters != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameters.map({(parameter: JetParameter): String -> parameter.getNameIdentifier()!!.getText()!!
+                                              }).makeString("", "", ""("", "")"")
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getNode()?.getElementType() == JetTokens.LPAR) firstChild!!.delete()
+            val lastChild = currentParamList?.getLastChild()
+            if (lastChild?.getNode()?.getElementType() == JetTokens.RPAR) lastChild!!.delete()
+        }
+    }
+
+    fun hasExplicitReturnType(element: JetFunctionLiteralExpression): Boolean {
+        return element.hasDeclaredReturnType()
+    }
+
+    fun hasExplicitReceiverType(element: JetFunctionLiteralExpression): Boolean {
+        return element.getFunctionLiteral().getReceiverTypeRef() != null
+    }
+
+    fun hasExplicitParamType(element: JetFunctionLiteralExpression): Boolean {
+        if (element.getValueParameters().any { it.getTypeReference() != null }) {
+            val parameters = element.getFunctionLiteral().getValueParameterList()?.getParameters()
+            return !(parameters?.any { it.getNameIdentifier()?.getText() == null } ?: false)
+        }
+        return false;
+    }","Ditto (`private`)
",I don't think this is the right place to put 
537,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import com.intellij.lang.ASTNode
+import com.intellij.psi.PsiElement
+import com.siyeh.ig.PsiReplacementUtil
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5","Stricter way is to find ""else"" keyword directly by `element.getNode().findChildByType(JetTokens.ELSE_KEYWORD)`. And this ""minus 5"" looks very esoteric anyway :)
",I don't think you need this class. You can ju
538,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import com.intellij.lang.ASTNode
+import com.intellij.psi.PsiElement
+import com.siyeh.ig.PsiReplacementUtil
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }","This code for distinguishing ""if"" from ""else"" has two problems:
- It is duplicated (here and symmetric intention)
- It is spread among two places: first `getExpressionType` returns `else` (which actually means ""if or else, I don't know yet), and then it is recalculated for if-else case.
  Alternative it to pass caret position to `getExpressionType`, so all these calculations will be there.
",I don't think you need this class. You can ju
539,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import com.intellij.lang.ASTNode
+import com.intellij.psi.PsiElement
+import com.siyeh.ig.PsiReplacementUtil
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$expressionType' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyNode = when (expressionType) {
+            ""else"" -> element.getNode().findChildByType(JetNodeTypes.ELSE)
+            ""if"" -> element.getNode().findChildByType(JetNodeTypes.THEN)
+            else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+        }
+        generateCleanOutput(element, bodyNode)
+    }
+
+    fun generateCleanOutput(element: JetExpressionImpl, bodyNode: ASTNode?) {
+        val newElement: PsiElement?
+
+        if (element.getNextSibling()?.getText() == "";"") {
+            element.getNextSibling()!!.delete()
+        }
+        newElement = bodyNode!!.getPsi()!!.replace(JetPsiFactory.createFunctionBody(element.getProject(), bodyNode.getText()))
+
+        //handles the case of the block statement being on a new line
+        if (newElement?.getPrevSibling()?.getText() != "")"") {","Checking for `is PsiWhiteSpace` is more robust.
",I don't think you need this class. You can ju
540,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import com.intellij.lang.ASTNode
+import com.intellij.psi.PsiElement
+import com.siyeh.ig.PsiReplacementUtil
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$expressionType' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyNode = when (expressionType) {
+            ""else"" -> element.getNode().findChildByType(JetNodeTypes.ELSE)
+            ""if"" -> element.getNode().findChildByType(JetNodeTypes.THEN)
+            else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+        }
+        generateCleanOutput(element, bodyNode)
+    }
+
+    fun generateCleanOutput(element: JetExpressionImpl, bodyNode: ASTNode?) {
+        val newElement: PsiElement?
+
+        if (element.getNextSibling()?.getText() == "";"") {
+            element.getNextSibling()!!.delete()
+        }
+        newElement = bodyNode!!.getPsi()!!.replace(JetPsiFactory.createFunctionBody(element.getProject(), bodyNode.getText()))
+
+        //handles the case of the block statement being on a new line
+        if (newElement?.getPrevSibling()?.getText() != "")"") {
+            newElement!!.getPrevSibling()!!.replace(JetPsiFactory.createWhiteSpace(element.getProject()))
+        }
+        //handles the case of no space between condition and statement
+        if (newElement?.getPrevSibling()?.getText() == "")"") {","Shouldn't it be just an `else` for previous `if`?
",I don't think you need this class. You can ju
541,"@@ -0,0 +1,93 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import com.intellij.lang.ASTNode
+import com.intellij.psi.PsiElement
+import com.siyeh.ig.PsiReplacementUtil
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""add.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement != null) return false
+
+        setText(""Add braces to '$expressionType' statement"")
+        return true
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val bodyNode = when (expressionType) {
+            ""else"" -> element.getNode().findChildByType(JetNodeTypes.ELSE)
+            ""if"" -> element.getNode().findChildByType(JetNodeTypes.THEN)
+            else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+        }
+        generateCleanOutput(element, bodyNode)
+    }
+
+    fun generateCleanOutput(element: JetExpressionImpl, bodyNode: ASTNode?) {
+        val newElement: PsiElement?
+
+        if (element.getNextSibling()?.getText() == "";"") {
+            element.getNextSibling()!!.delete()
+        }
+        newElement = bodyNode!!.getPsi()!!.replace(JetPsiFactory.createFunctionBody(element.getProject(), bodyNode.getText()))
+
+        //handles the case of the block statement being on a new line
+        if (newElement?.getPrevSibling()?.getText() != "")"") {
+            newElement!!.getPrevSibling()!!.replace(JetPsiFactory.createWhiteSpace(element.getProject()))
+        }
+        //handles the case of no space between condition and statement
+        if (newElement?.getPrevSibling()?.getText() == "")"") {
+            newElement!!.addBefore(JetPsiFactory.createWhiteSpace(element.getProject()), newElement.getFirstChild())
+        }
+        if (expressionType == ""do...while"") {
+            newElement?.getNextSibling()?.delete()
+        }
+        bodyNode.getPsi()!!.delete()","What is this for? Couldn't understand without comment.
",I don't think you need this class. You can ju
542,"@@ -0,0 +1,94 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+//import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.JetNodeTypes
+import com.intellij.psi.PsiComment
+import com.intellij.psi.PsiElement
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+//import org.jetbrains.jet.lang.psi.psiUtil.getExpressionKind","Commented imports? Are you sure? :)
",Remove unused imports.
543,"@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false","Yes, our formatter fails here at the moment, but you still should indent this line manually with 4 spaces
",This should be `isApplicableTo(element: JetFu
544,"@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        if (oldParameterList?.getParameters() != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameterList!!.getParameters().map({parameter -> parameter.getNameIdentifier()!!.getText()!!
+                                              }).makeString("", "", ""("", "")"")","Formatting got screwed up while you were modifying this code. It should be:

```
val ....map({
    parameter -> ...
}).makeString(...)
```
",I don't think this is the right place to put this. It should be in `JetPsiFactory`.
545,"@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        if (oldParameterList?.getParameters() != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameterList!!.getParameters().map({parameter -> parameter.getNameIdentifier()!!.getText()!!
+                                              }).makeString("", "", ""("", "")"")
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getNode()?.getElementType() == JetTokens.LPAR) firstChild!!.delete()
+            val lastChild = currentParamList?.getLastChild()
+            if (lastChild?.getNode()?.getElementType() == JetTokens.RPAR) lastChild!!.delete()
+        }
+    }
+
+    private fun hasExplicitReturnType(element: JetFunctionLiteralExpression): Boolean {
+        return element.hasDeclaredReturnType()
+    }
+
+    private fun hasExplicitReceiverType(element: JetFunctionLiteralExpression): Boolean {
+        return element.getFunctionLiteral().getReceiverTypeRef() != null
+    }
+
+    private fun hasExplicitParamType(element: JetFunctionLiteralExpression): Boolean {
+        val parameters = element.getFunctionLiteral().getValueParameterList()?.getParameters()
+        if (parameters == null) return false
+        var numExplicitParams = 0","Better, but shouldn't it be a boolean `hasExplicitParamType`? :)
",I don't think this is the right place to put this. It should be in `JetPsiFactory`.
546,"@@ -0,0 +1,95 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetFunctionLiteralExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetParameter
+import org.jetbrains.jet.lexer.JetTokens
+
+public class MakeTypeImplicitInLambdaIntention : JetSelfTargetingIntention<JetFunctionLiteralExpression>(
+        ""make.type.implicit.in.lambda"", javaClass()) {
+    override fun isApplicableTo(element: JetFunctionLiteralExpression): Boolean {
+        throw IllegalStateException(""isApplicableTo(JetExpressionImpl, Editor) should be called instead"")
+    }
+
+    override fun isApplicableTo(element: JetFunctionLiteralExpression, editor: Editor): Boolean {
+        val openBraceOffset = element.getLeftCurlyBrace().getStartOffset()
+        val closeBraceOffset = element.getRightCurlyBrace()?.getStartOffset()
+        val caretLocation = editor.getCaretModel().getOffset()
+        val arrow = element.getFunctionLiteral().getArrowNode()
+        if (arrow != null && !(openBraceOffset < caretLocation && caretLocation < arrow.getStartOffset() + 2) &&
+        caretLocation != closeBraceOffset) return false
+        else if (arrow == null && caretLocation != openBraceOffset + 1 && caretLocation != closeBraceOffset) return false
+        return hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)
+    }
+
+    override fun applyTo(element: JetFunctionLiteralExpression, editor: Editor) {
+        val functionLiteral = element.getFunctionLiteral()
+        val oldParameterList = functionLiteral.getValueParameterList()
+
+        if (hasExplicitReturnType(element)) {
+            val childAfterParamList = oldParameterList?.getNextSibling()
+            val arrow = functionLiteral.getArrowNode()?.getPsi()
+            val childBeforeArrow = arrow?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterParamList, childBeforeArrow)
+            val whiteSpaceBeforeArrow = JetPsiFactory.createWhiteSpace(element.getProject())
+            functionLiteral.addBefore(whiteSpaceBeforeArrow, arrow)
+        }
+
+        if (hasExplicitReceiverType(element)) {
+            val childAfterBrace = functionLiteral.getOpenBraceNode().getPsi()?.getNextSibling()
+            val childBeforeParamList = oldParameterList?.getPrevSibling()
+            functionLiteral.deleteChildRange(childAfterBrace, childBeforeParamList)
+        }
+
+        if (oldParameterList?.getParameters() != null && hasExplicitParamType(element)) {
+            val parameterString = oldParameterList!!.getParameters().map({parameter -> parameter.getNameIdentifier()!!.getText()!!
+                                              }).makeString("", "", ""("", "")"")
+            val newParameterList = JetPsiFactory.createParameterList(element.getProject(), parameterString)
+            oldParameterList.replace(newParameterList)
+        }
+
+        if (!hasExplicitParamType(element)) {
+            val currentParamList = element.getFunctionLiteral().getValueParameterList()
+            val firstChild = currentParamList?.getFirstChild()
+            if (firstChild?.getNode()?.getElementType() == JetTokens.LPAR) firstChild!!.delete()
+            val lastChild = currentParamList?.getLastChild()
+            if (lastChild?.getNode()?.getElementType() == JetTokens.RPAR) lastChild!!.delete()
+        }
+    }
+
+    private fun hasExplicitReturnType(element: JetFunctionLiteralExpression): Boolean {
+        return element.hasDeclaredReturnType()
+    }
+
+    private fun hasExplicitReceiverType(element: JetFunctionLiteralExpression): Boolean {
+        return element.getFunctionLiteral().getReceiverTypeRef() != null
+    }
+
+    private fun hasExplicitParamType(element: JetFunctionLiteralExpression): Boolean {
+        val parameters = element.getFunctionLiteral().getValueParameterList()?.getParameters()
+        if (parameters == null) return false
+        var numExplicitParams = 0
+        for (param in parameters!!) {","`!!` shouldn't be needed here
",I don't think this is the right place to put this. It should be in `JetPsiFactory`.
547,"@@ -0,0 +1,96 @@
+/*
+ * Copyright 2010-2016 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.quickfix
+
+import com.intellij.openapi.editor.Editor
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+import org.jetbrains.kotlin.builtins.KotlinBuiltIns
+import org.jetbrains.kotlin.codegen.ExpressionCodegen
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
+import org.jetbrains.kotlin.idea.core.replaced
+import org.jetbrains.kotlin.psi.KtConstantExpression
+import org.jetbrains.kotlin.psi.KtExpression
+import org.jetbrains.kotlin.psi.KtFile
+import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.resolve.DescriptorUtils
+import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
+import org.jetbrains.kotlin.types.KotlinType
+
+private val valueRanges = mapOf(
+        KotlinBuiltIns.FQ_NAMES._byte to Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong(),
+        KotlinBuiltIns.FQ_NAMES._short to Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong(),
+        KotlinBuiltIns.FQ_NAMES._int to Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong(),
+        KotlinBuiltIns.FQ_NAMES._long to Long.MIN_VALUE..Long.MAX_VALUE
+)
+
+class WrongPrimitiveLiteralFix(element: KtConstantExpression, type: KotlinType) : KotlinQuickFixAction<KtExpression>(element) {
+
+    private val typeName = DescriptorUtils.getFqName(type.constructor.declarationDescriptor!!)
+    private val expectedTypeIsFloat = KotlinBuiltIns.isFloat(type)
+    private val expectedTypeIsDouble = KotlinBuiltIns.isDouble(type)
+    private val constValue
+            = ExpressionCodegen.getPrimitiveOrStringCompileTimeConstant(element, element.analyze(BodyResolveMode.PARTIAL))?.value as? Number
+
+    private val fixedExpression = buildString {
+        if (expectedTypeIsFloat || expectedTypeIsDouble) {
+            append(constValue)
+            if (expectedTypeIsFloat) {
+                append('F')
+            }
+            else if ('.' !in this) {
+                append("".0"")
+            }
+        }
+        else {
+            if (constValue is Float || constValue is Double) {
+                append(constValue.toLong())
+            }
+            else {
+                append(element.text.takeWhile { it != 'l' && it != 'L' })","I'd rather use `element.text.trimEnd('l', 'L')`
",I don't think we need the `_byte` prefix.
548,"@@ -0,0 +1,96 @@
+fun Int.foo(a: Int = 1,","The correct spelling is `extension` :)
",
549,"@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import com.intellij.psi.PsiComment
+import com.intellij.psi.PsiElement
+import java.util.ArrayList
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement == null) return false
+
+        if (jetBlockElement!!.getStatements().size == 1) {
+            setText(""Remove braces from '$expressionType' statement"")
+            return true
+        }
+        return false
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        val firstStatement = jetBlockElement!!.getStatements().first()
+
+        val comments = handleComment(jetBlockElement)
+        if (comments != null) {
+            //TODO - output comments on the line above the control statement
+        }
+        val newElement = jetBlockElement.replace(JetPsiFactory.createExpression(element.getProject(), firstStatement.getText()))
+
+        if (expressionType == ""do...while"") {
+            newElement.getParent()!!.addAfter(JetPsiFactory.createNewLine(element.getProject()), newElement)
+        }
+    }
+
+    fun handleComment(element: JetBlockExpression): ArrayList<PsiComment>? {","With this function name, it's hard to guess what it does and what does it return. What about ""extractComments""?
It return `ArrayList`, while just `List` would be enough.
","I don't think you need this class, you can just use `JetSelfTargetingIntention.clas"
550,"@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import com.intellij.psi.PsiComment
+import com.intellij.psi.PsiElement
+import java.util.ArrayList
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement == null) return false
+
+        if (jetBlockElement!!.getStatements().size == 1) {
+            setText(""Remove braces from '$expressionType' statement"")
+            return true
+        }
+        return false
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        val firstStatement = jetBlockElement!!.getStatements().first()
+
+        val comments = handleComment(jetBlockElement)
+        if (comments != null) {
+            //TODO - output comments on the line above the control statement
+        }
+        val newElement = jetBlockElement.replace(JetPsiFactory.createExpression(element.getProject(), firstStatement.getText()))
+
+        if (expressionType == ""do...while"") {
+            newElement.getParent()!!.addAfter(JetPsiFactory.createNewLine(element.getProject()), newElement)
+        }
+    }
+
+    fun handleComment(element: JetBlockExpression): ArrayList<PsiComment>? {
+        val comments = ArrayList<PsiComment>()
+        var sibling = element.getFirstChild()
+        if (sibling == null) return null
+            sibling = sibling?.getNextSibling()","This indent blows minds. I thought that this assignment relates to if.
Why safe call here? `sibling` is not null before assignment here.
","I don't think you need this class, you can just use `JetSelfTargetingIntention.clas"
551,"@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetBlockExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.psiUtil.findBlockInExpression
+import org.jetbrains.jet.JetNodeTypes
+import org.jetbrains.jet.lang.psi.psiUtil.getExpressionType
+import com.intellij.psi.PsiComment
+import com.intellij.psi.PsiElement
+import java.util.ArrayList
+import com.intellij.openapi.fileEditor.FileEditorManager
+import com.intellij.openapi.project.Project
+import com.intellij.psi.PsiFile
+
+
+public class RemoveBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""remove.braces"", javaClass()) {
+    private var expressionType: String? = """"
+    private var caretLocation: Int = 1
+
+    override fun isAvailable(project: Project, editor: Editor, file: PsiFile): Boolean {
+        caretLocation = editor.getCaretModel().getOffset()
+        return getTarget(editor, file) != null
+    }
+
+    override fun isApplicableTo(element: JetExpressionImpl): Boolean {
+        expressionType = element.getExpressionType(element)
+        if (expressionType == null) return false
+
+        if (expressionType == ""else"") {
+            val elseLocation = (element as JetIfExpression).getElse()!!.getParent()!!.getTextOffset() - 5
+            if (caretLocation < elseLocation) {
+                expressionType = ""if""
+            }
+        }
+
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        if (jetBlockElement == null) return false
+
+        if (jetBlockElement!!.getStatements().size == 1) {
+            setText(""Remove braces from '$expressionType' statement"")
+            return true
+        }
+        return false
+    }
+
+    override fun applyTo(element: JetExpressionImpl, editor: Editor) {
+        val jetBlockElement = element.findBlockInExpression(element, expressionType)
+        val firstStatement = jetBlockElement!!.getStatements().first()
+
+        val comments = handleComment(jetBlockElement)
+        if (comments != null) {
+            //TODO - output comments on the line above the control statement
+        }
+        val newElement = jetBlockElement.replace(JetPsiFactory.createExpression(element.getProject(), firstStatement.getText()))
+
+        if (expressionType == ""do...while"") {
+            newElement.getParent()!!.addAfter(JetPsiFactory.createNewLine(element.getProject()), newElement)
+        }
+    }
+
+    fun handleComment(element: JetBlockExpression): ArrayList<PsiComment>? {
+        val comments = ArrayList<PsiComment>()
+        var sibling = element.getFirstChild()
+        if (sibling == null) return null
+            sibling = sibling?.getNextSibling()
+
+        while (sibling != null) {
+            if (sibling is PsiComment) {
+                comments.add(sibling as PsiComment)
+            }
+            sibling = sibling?.getNextSibling()","Another redundant safe call.
","I don't think you need this class, you can just use `JetSelfTargetingIntention.clas"
552,"@@ -0,0 +1,98 @@
+class A(val a: Int = 1,
+        val b: Int = 2,
+        val c: Int = 3,
+        val d: Int = 4,
+        val e: Int = 5,
+        val f: Int = 6,
+        val g: Int = 7,
+        val h: Int = 8,
+        val i: Int = 9,
+        val j: Int = 10,
+        val k: Int = 11,
+        val l: Int = 12,
+        val m: Int = 13,
+        val n: Int = 14,
+        val o: Int = 15,
+        val p: Int = 16,
+        val q: Int = 17,
+        val r: Int = 18,
+        val s: Int = 19,
+        val t: Int = 20,
+        val u: Int = 21,
+        val v: Int = 22,
+        val w: Int = 23,
+        val x: Int = 24,
+        val y: Int = 25,
+        val z: Int = 26,
+        val aa: Int = 27,
+        val bb: Int = 28,
+        val cc: Int = 29,
+        val dd: Int = 30,
+        val ee: Int = 31,
+        val ff: Int = 32,
+        val gg: Int = 33,
+        val hh: Int = 34,
+        val ii: Int = 35,
+        val jj: Int = 36,
+        val kk: Int = 37,
+        val ll: Int = 38,
+        val mm: Int = 39,
+        val nn: Int = 40,
+        val oo: Int = 41,
+        val pp: Int = 42,
+        val qq: Int = 43,
+        val rr: Int = 44,
+        val ss: Int = 45,
+        val tt: Int = 46,
+        val uu: Int = 47,
+        val vv: Int = 48,
+        val ww: Int = 49,
+        val xx: Int = 50,
+        val yy: Int = 51,
+        val zz: Int = 52,
+        val aaa: Int = 53,
+        val bbb: Int = 54,
+        val ccc: Int = 55,
+        val ddd: Int = 56,
+        val eee: Int = 57,
+        val fff: Int = 58,
+        val ggg: Int = 59,
+        val hhh: Int = 60,
+        val iii: Int = 61,
+        val jjj: Int = 62,
+        val kkk: Int = 63,
+        val lll: Int = 64,
+        val mmm: Int = 65,
+        val nnn: Int = 66,
+        val ooo: Int = 67,
+        val ppp: Int = 68,
+        val qqq: Int = 69,
+        val rrr: Int = 70) {
+    override fun toString(): String {
+        return ""$a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p $q $r $s $t $u $v $w $x $y $z $aa $bb $cc $dd $ee $ff $gg $hh $ii $jj $kk "" +
+                ""$ll $mm $nn $oo $pp $qq $rr $ss $tt $uu $vv $ww $xx $yy $zz $aaa $bbb $ccc $ddd $eee $fff $ggg $hhh $iii $jjj $kkk $lll "" +
+                ""$mmm $nnn $ooo $ppp $qqq $rrr""
+    }
+}
+
+fun box(): String {
+    val test1 = A(5, f = 3, w = 1, aa = 71, nn = 2, qq = 15, ww = 97, aaa = 261258, iii = 3, nnn = 8, rrr = 7).toString()
+    val test2 = A().toString()
+    val test3 = A(70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41,
+                    40, 39, 38, 37, 36, jj = 35, kk = 34, ll = 33, mm = 32, nn = 31, oo = 30, pp = 29, qq = 28, rr = 27, ss = 26, tt = 25,
+                    uu = 24, vv = 23, ww = 22, xx = 21, yy = 20, zz = 19, aaa = 18, bbb = 17, ccc = 16, ddd = 15, eee = 14, fff = 13,
+                    ggg = 12, hhh = 11, iii = 10, jjj = 9, kkk = 8, lll = 7, mmm = 6, nnn = 5, ooo = 4, ppp = 3, qqq = 2, rrr = 1).toString()
+    if (test1 != ""5 2 3 4 5 3 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 24 25 26 71 28 29 30 31 32 33 34 35 36 37 38 39 2 41 42 15 "" +
+            ""44 45 46 47 48 97 50 51 52 261258 54 55 56 57 58 59 60 3 62 63 64 65 8 67 68 69 7"") {
+        return test1
+    }
+    if (test2 != ""1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 "" +
+            ""43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70"") {
+        return test2
+    }
+    if (test3 != ""70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 "" +
+            ""31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1"") {
+        return test3
+    }
+    return ""OK""","Unfortunately no test checks the introduced behavior in `FunctionCodegen#generateConstructorWithoutParametersIfNeeded()`.

This test looks almost as if it does, but `A()` here is only a syntactic sugar for invoking the `$default` method :)

To test precisely the synthetic no-args constructor we generate for a class whose constructor's arguments are all default, you could either invoke it from Java or call it reflectively via `newInstance` (I recommend the latter).
",I don't think we need this.
553,"@@ -0,0 +1,99 @@
+/*
+ * Copyright 2010-2014 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.jet.plugin.intentions
+
+import com.intellij.openapi.editor.Editor
+import org.jetbrains.jet.lang.psi.JetDotQualifiedExpression
+import org.jetbrains.jet.lang.psi.JetCallExpression
+import org.jetbrains.jet.lang.psi.JetExpression
+import org.jetbrains.jet.lang.psi.JetPsiFactory
+import org.jetbrains.jet.lang.psi.JetValueArgument
+import org.jetbrains.jet.lang.psi.JetValueArgumentList
+import org.jetbrains.jet.lang.psi.JetNamedArgumentImpl
+import org.jetbrains.jet.lang.psi.JetValueArgumentName
+import org.jetbrains.jet.plugin.references.JetSimpleNameReference
+import org.jetbrains.jet.lang.psi.JetBinaryExpression
+import org.jetbrains.jet.lang.psi.JetPostfixExpression
+import org.jetbrains.jet.lang.psi.JetTypeArgumentList
+
+public class ReplaceGetCallWithArrayAccessIntention : JetSelfTargetingIntention<JetExpression>(""replace.get.call.with.array.access"", javaClass()) {
+    override fun isApplicableTo(element: JetExpression): Boolean {
+        fun methodCallCheck(expression: JetDotQualifiedExpression): Boolean {
+            val selector = expression.getSelectorExpression()
+            val receiver = expression.getReceiverExpression()
+
+            if (selector is JetCallExpression && !(receiver is JetPostfixExpression)) {
+                val callee = selector.getCalleeExpression()
+                val arguments = selector.getValueArgumentList()
+                val typeArguments = selector.getTypeArgumentList()
+
+                return arguments != null
+                    && typeArguments == null
+                    && !arguments.getArguments().any { (arg): Boolean -> arg.getArgumentName() != null }","Specifying return type in function literal is redundant here. Explicit parameter can be also omitted (""it"" name will be auto-generated for it).
",Can you please add the copyright header to all new files?
554,"@@ -0,0 +1,99 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.getCallNameExpression
+
+class KotlinRedundantOverrideInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitNamedFunction(function: KtNamedFunction) {
+                    super.visitNamedFunction(function)
+                    if (!function.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return
+
+                    val bodyExpression = function.bodyExpression
+                    bodyExpression ?: return
+
+                    val body = if (bodyExpression is KtDotQualifiedExpression) {
+                        bodyExpression
+                    }
+                    else {
+                        if (bodyExpression.children.size != 1) {
+                            return
+                        }
+                        bodyExpression.children[0]",You could use `singleOrNull() ?: return` here.,I don't think this is the right place to put this code. It should be in `AbstractKo
555,"@@ -0,0 +1,99 @@
+/*
+ * Copyright 2010-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jetbrains.kotlin.idea.inspections
+
+import com.intellij.codeInspection.*
+import com.intellij.openapi.project.Project
+import org.jetbrains.kotlin.lexer.KtTokens
+import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.getCallNameExpression
+
+class KotlinRedundantOverrideInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
+    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession) =
+            object : KtVisitorVoid() {
+                override fun visitNamedFunction(function: KtNamedFunction) {
+                    super.visitNamedFunction(function)
+                    if (!function.hasModifier(KtTokens.OVERRIDE_KEYWORD)) return
+
+                    val bodyExpression = function.bodyExpression
+                    bodyExpression ?: return
+
+                    val body = if (bodyExpression is KtDotQualifiedExpression) {
+                        bodyExpression
+                    }
+                    else {
+                        if (bodyExpression.children.size != 1) {
+                            return
+                        }
+                        bodyExpression.children[0]
+                    }
+
+                    val qualifiedExpression = if (body is KtReturnExpression) {
+                        val returnedExpression = body.returnedExpression
+                        returnedExpression ?: return
+                        returnedExpression as? KtDotQualifiedExpression ?: return
+                    }
+                    else {
+                        body as? KtDotQualifiedExpression ?: return
+                    }
+
+                    if (qualifiedExpression.receiverExpression !is KtSuperExpression) return
+
+                    val superSelectorExpression = qualifiedExpression.selectorExpression
+                    val superCallElement = superSelectorExpression as? KtCallElement ?: return
+
+                    if (!isSameFunctionName(superSelectorExpression, function)) return",I can use `superCallElement` for the argument. I will fix it.,"I don't think we need to check for `as` here, since `KtDotQualifiedExpression` is a"
556,"@@ -1,11 +1,11 @@
 <component name=""libraryTable"">
   <library name=""kotlin-runtime"">
     <CLASSES>
-      <root url=""jar://$KOTLIN_BUNDLED$/lib/kotlin-runtime.jar!/"" />
+      <root url=""jar://$PROJECT_DIR$/out/artifacts/Kotlin/kotlinc/lib/kotlin-runtime.jar!/"" />","Changes like this in meta-information should be carefully reviewed before committing, because they can easily break compilation or workflow for other developers.
",I think this should be `/artifacts/Kotlin/kotlinc/kotlin-runtime.jar`
557,"@@ -1,15 +1,15 @@
 package kotlin
 
 /**
- * Creates a tuple of type [[Pair<A,B>]] from this and *that* which can be useful for creating [[Map]] literals
- * with less noise, for example
-
- * @includeFunctionBody ../../test/collections/MapTest.kt createUsingTo
+ * Creates a tuple of type [Pair] from this and [that].
+ *
+ * This can be useful for creating [Map] literals with less noise, for example:
+ * @sample test.collections.MapTest.createUsingTo
  */
 public fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
 
 /**
-Run function f
+ * Runs the specified function.","Runs -> Calls?
",This should be `@sample`.
558,"@@ -1,3 +1,19 @@
+/*","It's added by IDEA's pre-commit action. Really shouldn't for generated files.
",Why is this needed?
559,"@@ -1,3 +1,3 @@
 package test
 
-fun lll(a: Int) = a
+fun lll(a: kotlin.Int) = a",Here we have `kotlin.` added too,Why is this needed?
560,"@@ -1,4 +1,4 @@
 package test
 
 // extra parameter is to make sure generic signature is not erased
-fun doNothing(array: IntArray, ignore: java.util.List<String>) = array
+fun doNothing(array: kotlin.IntArray, ignore: java.util.List<String>) = array",And here we have `kotlin.` too,Why this change?
561,"@@ -1,4 +1,4 @@
 package test
 
 // extra parameter is to preserve generic signature
-fun anyany(a: Any, ignore: java.util.List<String>) = a
+fun anyany(a: kotlin.Any, ignore: java.util.List<String>) = a",Unclear. Why should you have `kotlin.` here and how it works without it?,Why this change?
562,"@@ -1,4 +1,5 @@
 package org.junit
 
+@Deprecated(""Use 'Test' from kotlin.test package"", replaceWith = ReplaceWith(""Test"", imports = ""kotlin.test.Test""))", ,import org.junit
563,"@@ -1,6 +1,10 @@
 // ""Change 'foo' function return type to '([ERROR : NoSuchType]) -> Int'"" ""false""
+// ACTION: Disable 'Make Types Implicit In Lambda'
+// ACTION: Edit intention settings
+// ACTION: Make types implicit in lambda","Note that this test is now failing again due to obvious reasons :)
",I don't think th
564,"@@ -1,7 +1,6 @@
 fun foo() {
-    val a: kotlin.test.Asserter?
-    if (<caret>) {
-        a = null
+    val a = if (<caret>) {","It's not OK that you're losing the variable type here.
",Why did you chan
565,"@@ -1,72 +0,0 @@
-/*
- * Copyright 2010-2015 JetBrains s.r.o.
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.jetbrains.kotlin.idea.quickfix
-
-import org.jetbrains.kotlin.psi.*
-import kotlin.platform.*
-import org.jetbrains.kotlin.diagnostics.*
-import com.intellij.codeInsight.intention.*
-import org.jetbrains.kotlin.idea.*
-import com.intellij.openapi.project.*
-import com.intellij.openapi.editor.*
-import com.intellij.psi.*
-import org.jetbrains.kotlin.idea.project.PluginJetFilesProvider
-import org.jetbrains.kotlin.idea.quickfix.quickfixUtil.createIntentionFactory
-import org.jetbrains.kotlin.idea.quickfix.quickfixUtil.createIntentionForFirstParentOfType
-import org.jetbrains.kotlin.lexer.JetTokens
-import org.jetbrains.kotlin.psi.psiUtil.*
-import java.util.ArrayList
-
-
-public class AddInitKeywordFix(element: JetClassInitializer) : JetIntentionAction<JetClassInitializer>(element) {
-    override fun getText() = JetBundle.message(""add.init.keyword"")
-
-    override fun getFamilyName() = JetBundle.message(""add.init.keyword.family"")
-
-    override fun invoke(project: Project, editor: Editor?, file: JetFile) {
-        addInitKeyword(element)
-    }
-
-    companion object Factory : JetSingleIntentionActionFactory() {
-        override fun createAction(diagnostic: Diagnostic) = diagnostic.createIntentionForFirstParentOfType(::AddInitKeywordFix)
-
-        public fun createWholeProjectFixFactory(): JetSingleIntentionActionFactory = createIntentionFactory {
-            JetWholeProjectForEachElementOfTypeFix.createByPredicate<JetClassInitializer>(
-                predicate = { !it.hasInitKeyword() },
-                taskProcessor = { addInitKeyword(it) },
-                modalTitle = JetBundle.message(""add.init.keyword.in.whole.project.modal.title""),
-                name = JetBundle.message(""add.init.keyword.in.whole.project""),
-                familyName = JetBundle.message(""add.init.keyword.in.whole.project.family"")
-            )
-        }
-
-        private fun addInitKeyword(element: JetClassInitializer) {
-            if (element.hasInitKeyword()) return
-
-            val psiFactory = JetPsiFactory(element)
-            val initKeyword = psiFactory.createInitKeyword()","JetPsiFactory.createInitKeyword became unused
",Why is this clas
566,"@@ -1,8 +1,9 @@
 object A {
     @JvmStatic fun main(args: Array<String>) {
-        println(Void.TYPE)
-        println(Integer.TYPE)
-        println(java.lang.Double.TYPE)
+        println(Unit::class.javaPrimitiveType)","This doesn't actually work: `Unit` has no `javaPrimitiveType`. For `void.class`, the previous variant of the code should be used.
",Why did you chan
567,"@@ -10,21 +10,34 @@ import kotlin.jvm.internal.Intrinsic
  *
  * Example:
  *
- *      throws(javaClass<IOException>())
- *      fun readFile(name: String): String {...}
+ * ```
+ * throws(javaClass<IOException>())
+ * fun readFile(name: String): String {...}
+ * ```
  *
  * will be translated to
  *
- *      String readFile(String name) throws IOException {...}
+ * ```
+ * String readFile(String name) throws IOException {...}
+ * ```
  */
 Retention(RetentionPolicy.SOURCE)
 public annotation class throws(public vararg val exceptionClasses: Class<out Throwable>)
 
+/**
+ * Returns the runtime Java class of this object.
+ */
 [Intrinsic(""kotlin.javaClass.property"")] public val <T: Any> T.javaClass : Class<T>
     get() = (this as java.lang.Object).getClass() as Class<T>
 
+/**
+ * Returns the Java class for the specified type.
+ */
 [Intrinsic(""kotlin.javaClass.function"")] public fun <reified T: Any> javaClass(): Class<T> = null as Class<T>
 
+/**
+ * Executes the given function [block] while holding the monitor of the given object [lock].","Somewhere I saw you called it ""semaphore"", and here calling ""monitor""
",I think it would
568,"@@ -10,6 +10,12 @@ class BasicAssertionsTest {
     }
 
     @Test
+    fun testAssertSame() {","`test` prefix reminds me old days of `JUnit`, where it was obligatory to run any test :-)

Could you tell me why there is doubled `kotlin` and `test` packages in path: `kotlin/libraries/kotlin.test/common/src/test/kotlin/kotlin/test/tests/`? Just wondering.",
569,"@@ -10,6 +10,12 @@ package kotlin.text
 public inline fun buildString(builderAction: StringBuilder.() -> Unit): String = StringBuilder().apply(builderAction).toString()
 
 /**
+ * Builds new string by populating newly created [StringBuilder] initialized with the given capacity using provided [builderAction] and then converting it to [String].
+ */","Will fix formatting upon rebase.
",* Builds new [St
570,"@@ -10,6 +10,12 @@ package kotlin.text
 public inline fun buildString(builderAction: StringBuilder.() -> Unit): String = StringBuilder().apply(builderAction).toString()
 
 /**
+ * Builds new string by populating newly created [StringBuilder] initialized with the given capacity using provided [builderAction] and then converting it to [String].
+ */
+@kotlin.internal.InlineOnly
+inline fun buildString(length : Int, builderAction: StringBuilder.() -> Unit): String = StringBuilder(length).apply(builderAction).toString()","Constructor parameter is called `capacity` so it should have the same name here.
Also there should be no space before `:` in parameter definition.
",I don't think we
571,"@@ -10,9 +10,9 @@ import java.util.*
 import java.util.Collections // TODO: it's temporary while we have java.util.Collections in js
 
 /**
- * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
- * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
- * a special *truncated* separator (which defaults to ""..."")
+ * Appends the string from all the elements separated using [separator] and using the given [prefix] and *postfix* if supplied.","Linkify `postfix`
",I don't think we
572,"@@ -10,9 +10,9 @@ import java.util.*
 import java.util.Collections // TODO: it's temporary while we have java.util.Collections in js
 
 /**
- * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
- * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
- * a special *truncated* separator (which defaults to ""..."")
+ * Appends the string from all the elements separated using [separator] and using the given [prefix] and *postfix* if supplied.
+ * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]
+ * elements will be appended, followed by the [truncated] string (which defaults to ""..."").","Ideally `trucated` should default to """", not ""...""
",I think it would
573,"@@ -100,65 +181,143 @@ public class Byte private () : Number, Comparable<Byte> {
  * On the JVM, non-nullable values of this type are represented as values of the primitive type `char`.
  */
 public class Char private () : Comparable<Char> {
-    class object {}
+    default object {}
 
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Byte): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public override fun compareTo(other: Char): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Short): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Int): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Long): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Float): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Double): Int
 
+    /** Adds the two values. */
     public fun plus(other: Byte): Int
+    /** Adds the two values. */
     public fun plus(other: Short): Int
+    /** Adds the two values. */
     public fun plus(other: Int): Int
+    /** Adds the two values. */
     public fun plus(other: Long): Long
+    /** Adds the two values. */
     public fun plus(other: Float): Float
+    /** Adds the two values. */
     public fun plus(other: Double): Double
 
+    /** Subtracts the other value from this value. */
     public fun minus(other: Byte): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Char): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Short): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Int): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Long): Long
+    /** Subtracts the other value from this value. */
     public fun minus(other: Float): Float
+    /** Subtracts the other value from this value. */
     public fun minus(other: Double): Double
 
+    /** Multiplies the two values. */
     public fun times(other: Byte): Int
+    /** Multiplies the two values. */
     public fun times(other: Short): Int
+    /** Multiplies the two values. */
     public fun times(other: Int): Int
+    /** Multiplies the two values. */
     public fun times(other: Long): Long
+    /** Multiplies the two values. */
     public fun times(other: Float): Float
+    /** Multiplies the two values. */
     public fun times(other: Double): Double
 
+    /** Divides this value by the other value. */
     public fun div(other: Byte): Int
+    /** Divides this value by the other value. */
     public fun div(other: Short): Int
+    /** Divides this value by the other value. */
     public fun div(other: Int): Int
+    /** Divides this value by the other value. */
     public fun div(other: Long): Long
+    /** Divides this value by the other value. */
     public fun div(other: Float): Float
+    /** Divides this value by the other value. */
     public fun div(other: Double): Double
 
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Byte): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Short): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Int): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Long): Long
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Float): Float
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Double): Double
 
+    /** Increments this value. */
     public fun inc(): Char
+    /** Decrements this value. */
     public fun dec(): Char
+    /** Returns this value. */
     public fun plus(): Int
+    /** Returns the negative of this value. */
     public fun minus(): Int
 
+     /** Creates a range from this value to the specified [other] value. */
     public fun rangeTo(other: Char): CharRange","We don't have other overloads for rangeTo, like in other types?
",I don't think th
574,"@@ -100,65 +181,143 @@ public class Byte private () : Number, Comparable<Byte> {
  * On the JVM, non-nullable values of this type are represented as values of the primitive type `char`.
  */
 public class Char private () : Comparable<Char> {
-    class object {}
+    default object {}
 
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Byte): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public override fun compareTo(other: Char): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Short): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Int): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Long): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Float): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Double): Int
 
+    /** Adds the two values. */
     public fun plus(other: Byte): Int
+    /** Adds the two values. */
     public fun plus(other: Short): Int
+    /** Adds the two values. */
     public fun plus(other: Int): Int
+    /** Adds the two values. */
     public fun plus(other: Long): Long
+    /** Adds the two values. */
     public fun plus(other: Float): Float
+    /** Adds the two values. */
     public fun plus(other: Double): Double
 
+    /** Subtracts the other value from this value. */
     public fun minus(other: Byte): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Char): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Short): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Int): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Long): Long
+    /** Subtracts the other value from this value. */
     public fun minus(other: Float): Float
+    /** Subtracts the other value from this value. */
     public fun minus(other: Double): Double
 
+    /** Multiplies the two values. */
     public fun times(other: Byte): Int
+    /** Multiplies the two values. */
     public fun times(other: Short): Int
+    /** Multiplies the two values. */
     public fun times(other: Int): Int
+    /** Multiplies the two values. */
     public fun times(other: Long): Long
+    /** Multiplies the two values. */
     public fun times(other: Float): Float
+    /** Multiplies the two values. */
     public fun times(other: Double): Double
 
+    /** Divides this value by the other value. */
     public fun div(other: Byte): Int
+    /** Divides this value by the other value. */
     public fun div(other: Short): Int
+    /** Divides this value by the other value. */
     public fun div(other: Int): Int
+    /** Divides this value by the other value. */
     public fun div(other: Long): Long
+    /** Divides this value by the other value. */
     public fun div(other: Float): Float
+    /** Divides this value by the other value. */
     public fun div(other: Double): Double
 
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Byte): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Short): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Int): Int
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Long): Long
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Float): Float
+    /** Calculates the remainder of dividing this value by the other value. */
     public fun mod(other: Double): Double
 
+    /** Increments this value. */
     public fun inc(): Char
+    /** Decrements this value. */
     public fun dec(): Char
+    /** Returns this value. */
     public fun plus(): Int
+    /** Returns the negative of this value. */
     public fun minus(): Int
 
+     /** Creates a range from this value to the specified [other] value. */
     public fun rangeTo(other: Char): CharRange
 
+    /** Returns the value of this character as a `name`. */","As a name?
",I don't think th
575,"@@ -105,8 +105,19 @@ public KotlinTypeInfo visitIfExpression(KtIfExpression ifExpression, ExpressionT
 
         LexicalWritableScope thenScope = newWritableScopeImpl(context, LexicalScopeKind.THEN, components.overloadChecker);
         LexicalWritableScope elseScope = newWritableScopeImpl(context, LexicalScopeKind.ELSE, components.overloadChecker);
-        DataFlowInfo thenInfo = components.dataFlowAnalyzer.extractDataFlowInfoFromCondition(condition, true, context).and(conditionDataFlowInfo);
-        DataFlowInfo elseInfo = components.dataFlowAnalyzer.extractDataFlowInfoFromCondition(condition, false, context).and(conditionDataFlowInfo);
+        DataFlowInfo basicThenInfo = components.dataFlowAnalyzer.extractDataFlowInfoFromCondition(condition, true, context).and(conditionDataFlowInfo);
+        DataFlowInfo thenInfoFromES = components.effectSystem.getConditionalInfoForThenBranch(",I'd expect here some language feature check.,I think this sho
576,"@@ -107,29 +106,38 @@ protected ExitCode doExecute(
         Project project = environmentForJS.getProject();
         List<JetFile> sourcesFiles = environmentForJS.getSourceFiles();
 
-        if (arguments.verbose) {
-            reportCompiledSourcesList(messageCollector, sourcesFiles);
+        if (arguments.outputFile == null) {
+            messageSeverityCollector.report(CompilerMessageSeverity.ERROR, ""Specify output file via -output"", CompilerMessageLocation.NO_LOCATION);
+            return ExitCode.INTERNAL_ERROR;
         }
 
-        if (arguments.outputFile == null) {
-            messageCollector.report(CompilerMessageSeverity.ERROR, ""Specify output file via -output"", CompilerMessageLocation.NO_LOCATION);
+        if (messageSeverityCollector.anyReported(CompilerMessageSeverity.ERROR)) {
             return ExitCode.INTERNAL_ERROR;
         }
 
+        if (sourcesFiles.isEmpty()) {
+            messageSeverityCollector.report(CompilerMessageSeverity.ERROR, ""No source files"", CompilerMessageLocation.NO_LOCATION);
+            return COMPILATION_ERROR;","Maybe we should have another exit code for such cases? e.g. `ILLEGAL_ARGUMENTS_ERROR`.

//cc @udalov 
",Shouldn't this be an error?
577,"@@ -110,7 +149,10 @@ fun createContainerForLazyResolveWithJava(
         useImpl<LazyResolveToken>()
     }
 }.apply {
-    get<JavaClassFinderImpl>().initialize(bindingTrace, get<KotlinCodeAnalyzer>())
+    if (useJavac)
+        get<JavacClassFinder>().initialize(bindingTrace, get<KotlinCodeAnalyzer>())",I'd write here `JavacBasedClassFinder`. The current name is too close to just `JavaClassFinder`.,Why do we need this if stat
578,"@@ -111,7 +114,9 @@ interface ReplEvalAction {
 
 sealed class ReplEvalResult : Serializable {
     class ValueResult(val value: Any?) : ReplEvalResult() {
-        override fun toString(): String = ""Result: $value""
+        val type = LastInferredTypeHolder.inferredType.get()",I think you can obtain this type from `compileResult` at `GenericReplEvaluator.eval` and pass to `ValueResult`'s constructor here,Why do we need this?
579,"@@ -112,9 +112,18 @@ class MemberVisibilityCanPrivateInspection : AbstractKotlinInspection() {
             else -> ""Property""
         }
         val nameElement = (declaration as? PsiNameIdentifierOwner)?.nameIdentifier ?: return
-        holder.registerProblem(declaration.visibilityModifier() ?: nameElement,
+        val visibilityModifier = declaration.visibilityModifier()
+        val fix = object : AddModifierFix(modifierListOwner, KtTokens.PRIVATE_KEYWORD) {","I would do this as a general fix to AddModifierFix (which already has special logic for handling modality modifiers), not as a single-case override here.",Why do we need this change?
580,"@@ -112,9 +112,20 @@ void parseFile() {
             parseTopLevelDeclaration();
         }
 
+        checkUnclosedBlockComment();
         fileMarker.done(KT_FILE);
     }
 
+    private void checkUnclosedBlockComment() {
+        if (TokenSet.create(BLOCK_COMMENT, DOC_COMMENT).contains(myBuilder.rawLookup(-1))) {
+            int startOffset = myBuilder.rawTokenTypeStart(-1);
+            int endOffset = myBuilder.rawTokenTypeStart(0);
+            if (!myBuilder.getOriginalText().subSequence(startOffset, endOffset).toString().endsWith(""*/"")) {","This may materialize a huge file as a single string (in case of this file being commented entirely)

We could probably use other means, such as:
- changing the lexer to emit a special token type on unfinished comments
- using the CharSequence API to only materialize the last two characters as String, and not the entire text
",Why do we need this check?
581,"@@ -112,9 +112,20 @@ void parseFile() {
             parseTopLevelDeclaration();
         }
 
+        checkUnclosedBlockComment();
         fileMarker.done(KT_FILE);
     }
 
+    private void checkUnclosedBlockComment() {
+        if (TokenSet.create(BLOCK_COMMENT, DOC_COMMENT).contains(myBuilder.rawLookup(-1))) {
+            int startOffset = myBuilder.rawTokenTypeStart(-1);
+            int endOffset = myBuilder.rawTokenTypeStart(0);
+            if (!myBuilder.getOriginalText().subSequence(startOffset, endOffset).toString().endsWith(""*/"")) {
+                error(""Unclosed comment"");","This error is placed before the comment, in Java it is at the end of the file
",I think this should be `myB
582,"@@ -114,15 +116,28 @@ class KotlinQuickDocumentationProvider : AbstractDocumentationProvider() {
             return null
         }
 
-        private fun renderKotlinDeclaration(declaration: KtDeclaration, quickNavigation: Boolean): String {
+        private fun renderKotlinDeclaration(declaration: KtExpression, quickNavigation: Boolean): String {
             val context = declaration.analyze(BodyResolveMode.PARTIAL)
-            var declarationDescriptor = context[BindingContext.DECLARATION_TO_DESCRIPTOR, declaration]
+            val declarationDescriptor = context[BindingContext.DECLARATION_TO_DESCRIPTOR, declaration]
 
             if (declarationDescriptor == null) {
                 LOG.info(""Failed to find descriptor for declaration "" + declaration.getElementTextWithContext())
                 return ""No documentation available""
             }
 
+            return renderKotlin(context, declarationDescriptor, quickNavigation)
+        }
+
+        private fun renderKotlinImplicitLambdaParameter(element: KtReferenceExpression, quickNavigation: Boolean): String? {
+            val context = element.analyze(BodyResolveMode.PARTIAL)
+            val target = element.mainReference.resolveToDescriptors(context).singleOrNull() as? ValueParameterDescriptor? ?: return null
+            context.get(BindingContext.AUTO_CREATED_IT, target)","This line doesn't do anything
",Why do we need this?
583,"@@ -114,15 +116,28 @@ class KotlinQuickDocumentationProvider : AbstractDocumentationProvider() {
             return null
         }
 
-        private fun renderKotlinDeclaration(declaration: KtDeclaration, quickNavigation: Boolean): String {
+        private fun renderKotlinDeclaration(declaration: KtExpression, quickNavigation: Boolean): String {
             val context = declaration.analyze(BodyResolveMode.PARTIAL)
-            var declarationDescriptor = context[BindingContext.DECLARATION_TO_DESCRIPTOR, declaration]
+            val declarationDescriptor = context[BindingContext.DECLARATION_TO_DESCRIPTOR, declaration]
 
             if (declarationDescriptor == null) {
                 LOG.info(""Failed to find descriptor for declaration "" + declaration.getElementTextWithContext())
                 return ""No documentation available""
             }
 
+            return renderKotlin(context, declarationDescriptor, quickNavigation)
+        }
+
+        private fun renderKotlinImplicitLambdaParameter(element: KtReferenceExpression, quickNavigation: Boolean): String? {
+            val context = element.analyze(BodyResolveMode.PARTIAL)
+            val target = element.mainReference.resolveToDescriptors(context).singleOrNull() as? ValueParameterDescriptor? ?: return null
+            context.get(BindingContext.AUTO_CREATED_IT, target)
+            return renderKotlin(context, target, quickNavigation)
+        }
+
+        private fun renderKotlin(context: BindingContext, declarationDescriptor: DeclarationDescriptor, quickNavigation: Boolean): String {
+            @Suppress(""NAME_SHADOWING"")
+            var declarationDescriptor = declarationDescriptor","This doesn't seem to be needed, either
",Why do we need this?
584,"@@ -115,9 +116,73 @@ class KotlinCodeFragmentFactory: CodeFragmentFactory() {
             }
         })
 
+        if (contextElement != null && contextElement !is KtElement) {","Now such variables are skipped during text rendering, so it doesn't matter if they are present in resulting map (this map is used only to get values for kotlin variables that are present in resulting text)
",
585,"@@ -115,9 +116,73 @@ class KotlinCodeFragmentFactory: CodeFragmentFactory() {
             }
         })
 
+        if (contextElement != null && contextElement !is KtElement) {
+            codeFragment.putCopyableUserData(KtCodeFragment.FAKE_CONTEXT_FOR_JAVA_FILE, {
+                val emptyFile = createFakeFileWithJavaContextElement("""", contextElement)
+
+                val debuggerContext = DebuggerManagerEx.getInstanceEx(project).context
+                val debuggerSession = debuggerContext.debuggerSession
+                if ((debuggerSession == null || debuggerContext.suspendContext == null) && !ApplicationManager.getApplication().isUnitTestMode) {
+                    LOG.warn(""Couldn't create fake context element for java file, debugger isn't paused on breakpoint"")
+                    return@putCopyableUserData emptyFile
+                }
+
+                // TODO: 'this' is unavailable
+                val visibleVariables = getVisibleLocalVariables(contextElement, debuggerContext)
+                if (visibleVariables == null) {
+                    LOG.warn(""Couldn't get a list of local variables for ${debuggerContext.sourcePosition.file.name}:${debuggerContext.sourcePosition.line}"")
+                    return@putCopyableUserData emptyFile
+                }
+
+                val fakeFunctionText = ""fun _java_locals_debug_fun_() {\n"" +
+                                       visibleVariables.entries.associate { it.key.name() to it.value }.kotlinVariablesAsText(project) +
+                                       ""}""
+
+                val fakeFile = createFakeFileWithJavaContextElement(fakeFunctionText, contextElement)
+                val fakeFunction = fakeFile.declarations.firstOrNull() as? KtFunction
+                val fakeContext = (fakeFunction?.bodyExpression as? KtBlockExpression)?.statements?.lastOrNull()
+
+                return@putCopyableUserData wrapContextIfNeeded(project, contextElement, fakeContext) ?: emptyFile
+            })
+        }
+
         return codeFragment
     }
 
+    private fun getVisibleLocalVariables(contextElement: PsiElement?, debuggerContext: DebuggerContextImpl): Map<LocalVariable, Value>? {
+        val semaphore = Semaphore()
+        semaphore.down()
+
+        var visibleVariables: Map<LocalVariable, Value>? = null
+
+        val worker = object : DebuggerCommandImpl() {
+            override fun action() {","I've replaced it with codeFragment.getContentElement().statements.lastOrNull() to make this line clearer
",Is this TODO still relevant
586,"@@ -116,13 +128,35 @@ private static String execCompiler(
             List<String> argumentsList = ArgumentUtils.convertArgumentsToStringList(arguments);
             argumentsList.addAll(StringUtil.split(additionalArguments, "" ""));
 
+            String[] argsArray = ArrayUtil.toStringArray(argumentsList);
+
+            // trying the daemon first
+            if (incrementalCaches != null && KotlinCompilerClient.Companion.isDaemonEnabled()) {
+                File libPath = CompilerRunnerUtil.getLibPath(environment.getKotlinPaths(), messageCollector);
+                // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+                //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+                CompilerId compilerId = CompilerId.makeCompilerId(new File(libPath, ""kotlin-compiler.jar""));
+                DaemonOptions daemonOptions = new DaemonOptions();
+                DaemonLaunchingOptions daemonLaunchingOptions = new DaemonLaunchingOptions();
+                KotlinCompilerClient.Companion.configureDaemonLaunchingOptions(daemonLaunchingOptions);
+                // TODO: find proper stream to report daemon connection progress
+                CompileService daemon = KotlinCompilerClient.Companion.connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, System.out, true, true);
+                if (daemon != null) {
+                    Integer res = KotlinCompilerClient.Companion.incrementalCompile(daemon, argsArray, incrementalCaches, out);
+                    return res.toString();
+                }
+            }
+
+            // otherwise fallback to in-process
+
             Object rc = CompilerRunnerUtil.invokeExecMethod(
-                    compilerClassName, ArrayUtil.toStringArray(argumentsList), environment, messageCollector, out
+                    compilerClassName, argsArray, environment, messageCollector, out
             );
 
             // exec() returns an ExitCode object, class of which is loaded with a different class loader,
             // so we take it's contents through reflection
             return getReturnCodeFromObject(rc);
+","Extra empty line.
",I think it would be better 
587,"@@ -1162,3 +1162,77 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {
+    val resultTable = IntArray(pattern.length)
+
+    var matches = 0
+    for (i in 1..pattern.length - 1) {
+        while (matches > 0 && pattern[matches] != pattern[i]) {
+            matches = resultTable[matches]
+        }
+
+        if (pattern[matches] == pattern[i]) {
+            matches++
+        }
+        resultTable[i] = matches
+    }
+
+    return resultTable
+}
+
+/**
+ * Returns a list of indices where the pattern occurs in this String. This method
+ * searches character by character and thus does not support regular expressions
+ * as input for the pattern.
+ *
+ * @param [pattern] The pattern to look for in this String. Regular expressions
+ *                 are not supported
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ *
+ * @return A list of indices where the supplied [pattern] starts in the text.
+ */
+public fun CharSequence.occurrencesOf(pattern: CharSequence, ignoreCase: Boolean = false): Sequence<Int> {
+
+    if (isEmpty() || pattern.isEmpty()) {","`if (pattern.isEmpty() || pattern.length > this.length)`  ?
",I think it would be good to
588,"@@ -1162,3 +1162,77 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {
+    val resultTable = IntArray(pattern.length)
+
+    var matches = 0
+    for (i in 1..pattern.length - 1) {
+        while (matches > 0 && pattern[matches] != pattern[i]) {
+            matches = resultTable[matches]
+        }
+
+        if (pattern[matches] == pattern[i]) {
+            matches++
+        }
+        resultTable[i] = matches
+    }
+
+    return resultTable
+}
+
+/**
+ * Returns a list of indices where the pattern occurs in this String. This method
+ * searches character by character and thus does not support regular expressions
+ * as input for the pattern.
+ *
+ * @param [pattern] The pattern to look for in this String. Regular expressions
+ *                 are not supported
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ *
+ * @return A list of indices where the supplied [pattern] starts in the text.
+ */
+public fun CharSequence.occurrencesOf(pattern: CharSequence, ignoreCase: Boolean = false): Sequence<Int> {
+
+    if (pattern.isEmpty() || pattern.length > this.length) {
+        return emptySequence()","I believe this should be consistent with the result of `Regex("""").findAll(input = ""...."")`, i.e. a match in every position.
",I think it would be good to
589,"@@ -1162,3 +1162,84 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {
+    val resultTable = IntArray(pattern.length)
+
+    var matches = 0
+    for (i in 1..pattern.length - 1) {
+        while (matches > 0 && pattern[matches] != pattern[i]) {
+            matches = resultTable[matches]
+        }
+
+        if (pattern[matches] == pattern[i]) {
+            matches++
+        }
+        resultTable[i] = matches
+    }
+
+    return resultTable
+}
+
+/**
+ * Returns a list of indices where the pattern occurs in this String. This method
+ * searches character by character and thus does not support regular expressions
+ * as input for the pattern.
+ * For a pattern longer than the text, an empty sequence is returned. If the pattern
+ * is empty, all indices are matched.
+ *
+ * @param [pattern] The pattern to look for in this String. Regular expressions
+ *                 are not supported
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ * @param [matchOverlapping] If true, also match overlapping occurences.
+ *
+ * @return A list of indices where the supplied [pattern] starts in the text.
+ */
+public fun CharSequence.occurrencesOf(pattern: CharSequence, ignoreCase: Boolean = false, matchOverlapping: Boolean = false): Sequence<Int> {
+
+    if (pattern.length > this.length) {
+        return emptySequence()
+    }
+
+    if (pattern.isEmpty()) {
+        return indices.asSequence()","It should be `(0..length).asSequence()`, because you need to count an empty match before the first character and empty one after the last characater.
",I think you can use `Array.
590,"@@ -1162,3 +1162,84 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {
+    val resultTable = IntArray(pattern.length)
+
+    var matches = 0
+    for (i in 1..pattern.length - 1) {
+        while (matches > 0 && pattern[matches] != pattern[i]) {
+            matches = resultTable[matches]
+        }
+
+        if (pattern[matches] == pattern[i]) {
+            matches++
+        }
+        resultTable[i] = matches
+    }
+
+    return resultTable
+}
+
+/**
+ * Returns a list of indices where the pattern occurs in this String. This method
+ * searches character by character and thus does not support regular expressions
+ * as input for the pattern.
+ * For a pattern longer than the text, an empty sequence is returned. If the pattern
+ * is empty, all indices are matched.
+ *
+ * @param [pattern] The pattern to look for in this String. Regular expressions
+ *                 are not supported
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ * @param [matchOverlapping] If true, also match overlapping occurences.
+ *
+ * @return A list of indices where the supplied [pattern] starts in the text.
+ */
+public fun CharSequence.occurrencesOf(pattern: CharSequence, ignoreCase: Boolean = false, matchOverlapping: Boolean = false): Sequence<Int> {
+
+    if (pattern.length > this.length) {
+        return emptySequence()
+    }
+
+    if (pattern.isEmpty()) {
+        return indices.asSequence()
+    }
+
+    if (pattern.length == 1) {
+        return indices.asSequence().filter { this[it].equals(pattern[0], ignoreCase) }","We could extract `CharSequence.occurrencesOf(char: Char, ignoreCase)` function from here.
",I think this should be `pat
591,"@@ -1162,3 +1162,97 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {","I'm not sure the prefix function is computed correctly. For the following example ""ABCDABD"" it returns [0,0,0,0,1,2,0], while according to the [reference](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm#Worked_example_of_the_table-building_algorithm) it should be [-1,0,0,0,0,1,2].

Also it loops infinitely on the input ""AAABAAB"".
",nit: `computeLengthOfPrefix
592,"@@ -1162,3 +1162,97 @@ public fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(""\r\n
  * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.
  */
 public fun CharSequence.lines(): List<String> = lineSequence().toList()
+
+/**
+ * For each i in [0, length), this function computes
+ * the length of the longest suffix of a substring of pattern from 0 to i
+ * that is also a prefix of the pattern itself.
+ */
+private fun computePrefixFunction(pattern: CharSequence): IntArray {
+    val resultTable = IntArray(pattern.length)
+
+    var matches = 0
+    for (i in 1..pattern.length - 1) {
+        while (matches > 0 && pattern[matches] != pattern[i]) {
+            matches = resultTable[matches - 1]
+        }
+
+        if (pattern[matches] == pattern[i]) {
+            matches++
+        }
+        resultTable[i] = matches
+    }
+
+    return resultTable
+}
+
+/**
+ * Returns a sequence of indices where the char occurs in this CharSequence.
+ *
+ * @param [char] The character to look for in the string
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ *
+ * @return A list of indices where the supplied [char] occurs in the text.
+ */
+public fun CharSequence.occurrencesOf(char: Char, ignoreCase: Boolean = false): Sequence<Int> {
+    return indices.asSequence().filter { this[it].equals(char, ignoreCase) }
+}
+
+/**
+ * Returns a sequence of indices where the pattern occurs in this CharSequence. This method
+ * searches character by character and thus does not support regular expressions
+ * as input for the pattern.
+ * For a pattern longer than the text, an empty sequence is returned. If the pattern
+ * is empty, all indices plus an empty occurrence at the end are matched.
+ *
+ * @param [pattern] The pattern to look for in this String. Regular expressions
+ *                 are not supported
+ * @param [ignoreCase] If true, characters are matched even if one is upper and the other is
+ *                 lower case
+ * @param [matchOverlapping] If true, also match overlapping occurrences.
+ *
+ * @return A list of indices where the supplied [pattern] starts in the text.
+ */
+public fun CharSequence.occurrencesOf(pattern: CharSequence, ignoreCase: Boolean = false, matchOverlapping: Boolean = false): Sequence<Int> {
+
+    if (pattern.length > this.length) {
+        return emptySequence()
+    }
+
+    if (pattern.isEmpty()) {
+        return (0..length).asSequence()
+    }
+
+    if (pattern.length == 1) {
+        return occurrencesOf(pattern[0], ignoreCase)
+    }
+
+    // Non-trivial pattern matching, perform computation
+    // using Knuth-Morris-Pratt
+
+    val prefixFunction = computePrefixFunction(pattern)
+
+    var i = 0
+    var matches = 0
+    return generateSequence {
+        while (i < length) {
+            while (matches > 0 && !pattern[matches].equals(this[i], ignoreCase)) {
+                matches = prefixFunction[matches - 1]
+            }
+
+            if (pattern[matches].equals(this[i], ignoreCase)) {
+                matches++
+            }","This approach requires two character comparisons per position when `matches > 0`. Is it possible to restructure the loop body? Also applies to `computePrefixFunction`.
",I think you can use `Array.from` here.
593,"@@ -117,7 +117,7 @@ and find classes or functions which are not documented very well and submit a pa
 In particular it'd be great if all functions included a nice example of how to use it such as for the
 <a href=""http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/hash-map-of.html"">hashMapOf()</a> function.
 This is implemented using the <a href=https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Maps.kt#L53"">@sample</a>
-macro to include code from a test function. This serves as a double win; the API gets better documented with nice examples to help new users and the code gets more test coverage.
+macro to include code from a test function. The benefits of this approach are twofold; First, the API's documentations is improved via beneficial examples that help new users and second, the code coverage is increased.","> documentations is

Not sure if it's consistent: either ""documentations are"" or ""documentation is""
","Nit: ""twofold"" -> ""twice"""
594,"@@ -117,9 +118,8 @@ public object KotlinCompilerRunner {
                 val stream = ByteArrayOutputStream()
                 val out = PrintStream(stream)
 
-// Uncomment after resolving problems with parallel compilation and tests
-//                if (System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY) == null)
-//                    System.setProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY, """")
+                if (java.lang.Boolean.parseBoolean(System.getProperty(GlobalOptions.COMPILE_PARALLEL_OPTION, ""false"")))","use `String#toBoolean()`
",You can use `Boolean.parseBoolean()` h
595,"@@ -118,17 +119,33 @@ private static Integer doExec(@NotNull CompileContext context, @NotNull Compiler
             context.addMessage(CompilerMessageCategory.ERROR, ""K2JSCompiler does not support multiple module source roots."", null, -1, -1);
             return -1;
         }
-        String[] commandLineArgs = constructArguments(context.getProject(), context.getModuleOutputDirectory(module), roots[0]);
+
+        VirtualFile outDir = context.getModuleOutputDirectory(module);
+        String outFile = outDir == null ? null : K2JSRunnerUtils.constructPathToGeneratedFile(context.getProject(), outDir.getPath());
+
+        String[] commandLineArgs = constructArguments(context.getProject(), outFile, roots[0]);
         Object rc = invokeExecMethod(environment, out, context, commandLineArgs, ""org.jetbrains.jet.cli.js.K2JSCompiler"");
+
+        if (outDir != null) {
+            outDir.refresh(false, true);","Can you please tell me what this is about?
",Shouldn't this be `outDir.deleteOnExit
596,"@@ -1191,14 +1191,14 @@ public inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T>
 }
 
 /**
- * Returns a stream containing first elements satisfying the given *predicate*
+ * Returns a stream containing first elements satisfying the given [predicate]
  */
 public fun <T> Stream<T>.takeWhile(predicate: (T) -> Boolean): Stream<T> {
     return TakeWhileStream(this, predicate)
 }
 
 /**
- * Returns a list containing first elements satisfying the given *predicate*
+ * Returns a string containing the first characters that satisfy the given [predicate]","""the first characters"", do not need ""the""
",I think this should be `Returns a stri
597,"@@ -12,7 +12,7 @@ public fun <T> Enumeration<T>.iterator(): Iterator<T> = object : Iterator<T> {
 }
 
 /**
- * Returns the given iterator itself. This allows to use an instance of iterator in a ranged for-loop
+ * Returns the given iterator itself. This allows to use an instance of iterator in a ranged for-loop.","""ranged for-loop"" -> ""`for` loop""
",Why did you change this?
598,"@@ -120,6 +129,39 @@ fun JetElement.wrapInBlock(): JetBlockExpression {
     block.appendElement(this)
     return block
 }
+
+fun JetExpressionImpl.findBlockInExpression(element: JetExpressionImpl,  expressionType: String?): JetBlockExpression? {","Why are this and the following functions extensions, but you don't use `this` in them and require call sites to pass same value twice?
",
599,"@@ -120,6 +129,39 @@ fun JetElement.wrapInBlock(): JetBlockExpression {
     block.appendElement(this)
     return block
 }
+
+fun JetExpressionImpl.findBlockInExpression(element: JetExpressionImpl,  expressionType: String?): JetBlockExpression? {
+    val bodyNode = when (expressionType) {
+        ""if"" -> element.getNode().findChildByType(JetNodeTypes.THEN)
+        ""else"" -> element.getNode().findChildByType(JetNodeTypes.ELSE)
+        else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+    }
+    if (bodyNode?.getPsi()?.getFirstChild() is JetBlockExpression) {
+        return bodyNode!!.getPsi()!!.getFirstChild() as JetBlockExpression
+    }
+    return null","Use the power of Kotlin :) Four lines can be replaced with `return bodyNode?.getPsi()?.getFirstChild() as? JetBlockExpression`
",Why do we need this?
600,"@@ -120,6 +129,39 @@ fun JetElement.wrapInBlock(): JetBlockExpression {
     block.appendElement(this)
     return block
 }
+
+fun JetExpressionImpl.findBlockInExpression(element: JetExpressionImpl,  expressionType: String?): JetBlockExpression? {
+    val bodyNode = when (expressionType) {
+        ""if"" -> element.getNode().findChildByType(JetNodeTypes.THEN)
+        ""else"" -> element.getNode().findChildByType(JetNodeTypes.ELSE)
+        else -> element.getNode().findChildByType(JetNodeTypes.BODY)
+    }
+    if (bodyNode?.getPsi()?.getFirstChild() is JetBlockExpression) {
+        return bodyNode!!.getPsi()!!.getFirstChild() as JetBlockExpression
+    }
+    return null
+}
+
+fun JetExpressionImpl.getExpressionType(element: JetExpressionImpl): String? {","""Expression type"" phrase usually means different thing, so this usage of it is misleading. Better to replace ""type"" word with ""kind"". Don't forget that you have this phrase in several other places.
Also, it's better to use enumeration instead of strings, because it's more type-safe. Enumeration can be named `ExpressionBlockKind` or something like this.
",I think this should be `JetExpressionI
601,"@@ -121,17 +164,16 @@ public open class KotlinCompile(): AbstractCompile() {
         args.noOptimize = kotlinOptions.noOptimize
         args.noCallAssertions = kotlinOptions.noCallAssertions
         args.noParamAssertions = kotlinOptions.noParamAssertions
+    }
 
-        val messageCollector = GradleMessageCollector(getLogger())
-        getLogger().debug(""Calling compiler"")
-        val exitCode = compiler.exec(messageCollector, Services.EMPTY, args)
-
-        when (exitCode) {
-            ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
-            ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
-            else -> {}
-        }
+    private fun getJavaSourceRoots(): HashSet<File> = getSource()","May be `List`?
",Why do we need this?
602,"@@ -121,17 +164,16 @@ public open class KotlinCompile(): AbstractCompile() {
         args.noOptimize = kotlinOptions.noOptimize
         args.noCallAssertions = kotlinOptions.noCallAssertions
         args.noParamAssertions = kotlinOptions.noParamAssertions
+    }
 
-        val messageCollector = GradleMessageCollector(getLogger())
-        getLogger().debug(""Calling compiler"")
-        val exitCode = compiler.exec(messageCollector, Services.EMPTY, args)
-
-        when (exitCode) {
-            ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
-            ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
-            else -> {}
-        }
+    private fun getJavaSourceRoots(): HashSet<File> = getSource()
+            .filter { isJava(it) }
+            .map { findSrcDirRoot(it) }
+            .filter { it != null }","May be replaced with `filterNotNull`
",Why do we need this?
603,"@@ -122,3 +124,47 @@ class KotlinEnterHandler: EnterHandlerDelegateAdapter() {
         return false
     }
 }
+
+class KotlinConvertToBodyEnterHandler : EnterHandlerDelegateAdapter() {
+    override fun preprocessEnter(file: PsiFile, editor: Editor,
+                                 caretOffset: Ref<Int>, caretAdvance: Ref<Int>, dataContext: DataContext,
+                                 originalHandler: EditorActionHandler?): EnterHandlerDelegate.Result {
+        if (file !is KtFile) return EnterHandlerDelegate.Result.Continue
+        if (!KotlinEditorOptions.getInstance().isEnableSmartConvertToBody) return EnterHandlerDelegate.Result.Continue
+        if (!EnterAfterUnmatchedBraceHandler.isAfterUnmatchedLBrace(editor, caretOffset.get(),
+                                                                    file.fileType)) return EnterHandlerDelegate.Result.Continue
+
+        val document = editor.document
+
+        //Let's check if it's special convert to body case.",This comments doesn't explain anything and can be dropped safely.,Why do we need this?
604,"@@ -122,3 +124,47 @@ class KotlinEnterHandler: EnterHandlerDelegateAdapter() {
         return false
     }
 }
+
+class KotlinConvertToBodyEnterHandler : EnterHandlerDelegateAdapter() {
+    override fun preprocessEnter(file: PsiFile, editor: Editor,
+                                 caretOffset: Ref<Int>, caretAdvance: Ref<Int>, dataContext: DataContext,
+                                 originalHandler: EditorActionHandler?): EnterHandlerDelegate.Result {
+        if (file !is KtFile) return EnterHandlerDelegate.Result.Continue
+        if (!KotlinEditorOptions.getInstance().isEnableSmartConvertToBody) return EnterHandlerDelegate.Result.Continue
+        if (!EnterAfterUnmatchedBraceHandler.isAfterUnmatchedLBrace(editor, caretOffset.get(),
+                                                                    file.fileType)) return EnterHandlerDelegate.Result.Continue
+
+        val document = editor.document
+
+        //Let's check if it's special convert to body case.
+        val prevOffset = caretOffset.get() - 1
+        if (document.isTextAt(prevOffset, ""{"")) {",Please consider inverting `if`.,Nit: please add a space after `//`
605,"@@ -122,3 +124,47 @@ class KotlinEnterHandler: EnterHandlerDelegateAdapter() {
         return false
     }
 }
+
+class KotlinConvertToBodyEnterHandler : EnterHandlerDelegateAdapter() {
+    override fun preprocessEnter(file: PsiFile, editor: Editor,
+                                 caretOffset: Ref<Int>, caretAdvance: Ref<Int>, dataContext: DataContext,
+                                 originalHandler: EditorActionHandler?): EnterHandlerDelegate.Result {
+        if (file !is KtFile) return EnterHandlerDelegate.Result.Continue
+        if (!KotlinEditorOptions.getInstance().isEnableSmartConvertToBody) return EnterHandlerDelegate.Result.Continue
+        if (!EnterAfterUnmatchedBraceHandler.isAfterUnmatchedLBrace(editor, caretOffset.get(),
+                                                                    file.fileType)) return EnterHandlerDelegate.Result.Continue
+
+        val document = editor.document
+
+        //Let's check if it's special convert to body case.
+        val prevOffset = caretOffset.get() - 1
+        if (document.isTextAt(prevOffset, ""{"")) {
+            document.commit(file.project)
+            val element = file.findElementAt(prevOffset)
+            if (element != null && element.matchParents(
+                    KtFunctionLiteral::class.java,
+                    KtLambdaExpression::class.java,
+                    KtDeclarationWithBody::class.java
+            )) {
+                val declaration = element.parent.parent.parent as KtDeclarationWithBody
+                if (!declaration.hasDeclaredReturnType()) return EnterHandlerDelegate.Result.Continue",I think this restriction leaves the majority of use-cases out of scope. Can we overcome it? I'm not sure it all worth it without the solution.,I don't think this is the right place 
606,"@@ -122,3 +124,47 @@ class KotlinEnterHandler: EnterHandlerDelegateAdapter() {
         return false
     }
 }
+
+class KotlinConvertToBodyEnterHandler : EnterHandlerDelegateAdapter() {
+    override fun preprocessEnter(file: PsiFile, editor: Editor,
+                                 caretOffset: Ref<Int>, caretAdvance: Ref<Int>, dataContext: DataContext,
+                                 originalHandler: EditorActionHandler?): EnterHandlerDelegate.Result {
+        if (file !is KtFile) return EnterHandlerDelegate.Result.Continue
+        if (!KotlinEditorOptions.getInstance().isEnableSmartConvertToBody) return EnterHandlerDelegate.Result.Continue
+        if (!EnterAfterUnmatchedBraceHandler.isAfterUnmatchedLBrace(editor, caretOffset.get(),
+                                                                    file.fileType)) return EnterHandlerDelegate.Result.Continue
+
+        val document = editor.document
+
+        //Let's check if it's special convert to body case.
+        val prevOffset = caretOffset.get() - 1
+        if (document.isTextAt(prevOffset, ""{"")) {
+            document.commit(file.project)
+            val element = file.findElementAt(prevOffset)
+            if (element != null && element.matchParents(
+                    KtFunctionLiteral::class.java,
+                    KtLambdaExpression::class.java,
+                    KtDeclarationWithBody::class.java
+            )) {
+                val declaration = element.parent.parent.parent as KtDeclarationWithBody
+                if (!declaration.hasDeclaredReturnType()) return EnterHandlerDelegate.Result.Continue
+                val equals = declaration.equalsToken
+                if (equals != null) {
+                    val startOffset =",Will it work with comments? Maybe it would be better to check for '=' and extend it with spaces from left and right.,I don't think this is the right place 
607,"@@ -124,21 +128,71 @@ class ConvertTwoComparisonsToRangeCheckIntention : SelfTargetingOffsetIndependen
         // To avoid possible side effects
         if (!min.isSimple() || !max.isSimple()) return null
 
+        val valContext = value.analyze()",You don't need to call `analyze()` multiple times; calling it once will return a `BindingContext` with information about all the expressions.,val valContext = min.analyze()
608,"@@ -124,21 +128,71 @@ class ConvertTwoComparisonsToRangeCheckIntention : SelfTargetingOffsetIndependen
         // To avoid possible side effects
         if (!min.isSimple() || !max.isSimple()) return null
 
+        val valContext = value.analyze()
+        val minContext = min.analyze()
+        val maxContext = max.analyze()
+        val valType = value.getType(valContext)
+        val minType = min.getType(minContext)
+        val maxType = max.getType(maxContext)
+
+        if (valType == null || minType == null || maxType == null) return null
+
+        if (!valType.isComparable()) return null
+
+        var minVal = min
+        var maxVal = max
+
+        if (minType != valType || maxType != valType) {
+            //numbers can be compared to numbers of different types
+            if (valType.isPrimitiveNumberType() && minType.isPrimitiveNumberType() && maxType.isPrimitiveNumberType()) {
+                //char is comparable to chars only
+                if (KotlinBuiltIns.isChar(valType) || KotlinBuiltIns.isChar(minType) || KotlinBuiltIns.isChar(maxType)) return null
+
+                if (valType.isFloatingPoint()) {
+                    if (minType.isInteger())
+                        minVal = KtPsiFactory(minVal).createExpression(getDoubleConstant(min, minType, minContext) ?: return null)
+                    if (maxType.isInteger())
+                        maxVal = KtPsiFactory(maxVal).createExpression(getDoubleConstant(max, maxType, maxContext) ?: return null)
+                }
+            } else {
+                return null
+            }
+        }
+
         if (incrementMinByOne || decrementMaxByOne) {
-            if (!value.getType(value.analyze()).isValidTypeForIncrementDecrementByOne()) return null
+            if (!valType.isValidTypeForIncrementDecrementByOne()) return null
         }
 
-        val minText = if (incrementMinByOne) min.getChangeBy(1) else min.text
-        val maxText = if (decrementMaxByOne) max.getChangeBy(-1) else max.text
+        val minText = if (incrementMinByOne) minVal.getChangeBy(1) else minVal.text
+        val maxText = if (decrementMaxByOne) maxVal.getChangeBy(-1) else maxVal.text
         return RangeExpressionData(value, minText ?: return null, maxText ?: return null)
     }
 
-    private fun KotlinType?.isValidTypeForIncrementDecrementByOne(): Boolean {
-        this ?: return false
+    private fun getDoubleConstant(intExpr: KtExpression, type: KotlinType, context: BindingContext): String? {
+        val intConst = ConstantExpressionEvaluator.getConstant(intExpr, context)?.getValue(type) ?: return null
+        return (intConst as? Number)?.toDouble()?.toString()
+    }
+
+    private fun KotlinType.isComparable(): Boolean {","`DescriptorUtils.isSubtypeOfClass(this, expression.builtIns.getComparable())`",Why do we need this check?
609,"@@ -126,32 +254,100 @@ public trait MutableSet<E> : Set<E>, MutableCollection<E> {
     override fun clear(): Unit
 }
 
+/**
+ * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving
+ * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.
+ * Methods in this trait support only read-only access to the map; read-write access is supported through
+ * the [MutableMap] trait.
+ */
 public trait Map<K, out V> {
     // Query Operations
+    /**
+     * Returns the size of the map.
+     */","size is a little bit unclear, may be ""number of key-value"" pairs? 
",I don't think we need to e
610,"@@ -126,32 +254,100 @@ public trait MutableSet<E> : Set<E>, MutableCollection<E> {
     override fun clear(): Unit
 }
 
+/**
+ * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving
+ * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.
+ * Methods in this trait support only read-only access to the map; read-write access is supported through
+ * the [MutableMap] trait.
+ */
 public trait Map<K, out V> {
     // Query Operations
+    /**
+     * Returns the size of the map.
+     */
     public fun size(): Int
+
+    /**
+     * Returns `true` if the map is empty (contains no elements), `false` otherwise.
+     */
     public fun isEmpty(): Boolean
+
+    /**
+     * Returns `true` if the map contains the specified [key].
+     */
     public fun containsKey(key: Any?): Boolean
+
+    /**
+     * Returns `true` if the map maps one or more keys to the specified [value].
+     */
     public fun containsValue(value: Any?): Boolean
+
+    /**
+     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.
+     */
     public fun get(key: Any?): V?
 
     // Views
+    /**
+     * Returns a [Set] of all keys in this map.
+     */
     public fun keySet(): Set<K>
+
+    /**
+     * Returns a [Collection] of all values in this map.
+     */
     public fun values(): Collection<V>","May contain duplicate values
",I don't think we need to a
611,"@@ -128,36 +128,71 @@ private static String execCompiler(
 
             String[] argsArray = ArrayUtil.toStringArray(argumentsList);
 
-            // trying the daemon first
-            if (incrementalCaches != null && RmiPackage.isDaemonEnabled()) {
-                File libPath = CompilerRunnerUtil.getLibPath(environment.getKotlinPaths(), messageCollector);
-                // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
-                //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
-                CompilerId compilerId = CompilerId.makeCompilerId(new File(libPath, ""kotlin-compiler.jar""));
-                DaemonOptions daemonOptions = RmiPackage.configureDaemonOptions();
-                DaemonJVMOptions daemonJVMOptions = RmiPackage.configureDaemonLaunchingOptions(true);
-                // TODO: find proper stream to report daemon connection progress
-                CompileService daemon = KotlinCompilerClient.Companion.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, System.out, true, true);
-                if (daemon != null) {
-                    Integer res = KotlinCompilerClient.Companion.incrementalCompile(daemon, argsArray, incrementalCaches, out);
-                    return res.toString();
-                }
-            }
+            if (!tryCompileWithDaemon(messageCollector, collector, environment, incrementalCaches, argsArray)) {
+                // otherwise fallback to in-process
 
-            // otherwise fallback to in-process
+                ByteArrayOutputStream stream = new ByteArrayOutputStream();
+                PrintStream out = new PrintStream(stream);
 
-            Object rc = CompilerRunnerUtil.invokeExecMethod(
-                    compilerClassName, argsArray, environment, messageCollector, out
-            );
+                Object rc = CompilerRunnerUtil.invokeExecMethod( compilerClassName, argsArray, environment, messageCollector, out);
 
-            // exec() returns an ExitCode object, class of which is loaded with a different class loader,
-            // so we take it's contents through reflection
-            return getReturnCodeFromObject(rc);
+                // exec() returns an ExitCode object, class of which is loaded with a different class loader,
+                // so we take it's contents through reflection
+                ProcessCompilerOutput(messageCollector, collector, stream, getReturnCodeFromObject(rc));
+            }
         }
         catch (Throwable e) {
             MessageCollectorUtil.reportException(messageCollector, e);
-            return INTERNAL_ERROR;
+            reportInternalCompilerError(messageCollector);
+        }
+    }
+
+    private static boolean tryCompileWithDaemon(
+            MessageCollector messageCollector,
+            OutputItemsCollector collector,
+            CompilerEnvironment environment,
+            Map<String, IncrementalCache> incrementalCaches,
+            String[] argsArray
+    ) throws IOException {
+        if (incrementalCaches != null && RmiPackage.isDaemonEnabled()) {
+            File libPath = CompilerRunnerUtil.getLibPath(environment.getKotlinPaths(), messageCollector);
+            // TODO: it may be a good idea to cache the compilerId, since making it means calculating digest over jar(s) and if \\
+            //    the lifetime of JPS process is small anyway, we can neglect the probability of changed compiler
+            CompilerId compilerId = CompilerId.makeCompilerId(new File(libPath, ""kotlin-compiler.jar""));
+            DaemonOptions daemonOptions = RmiPackage.configureDaemonOptions();
+            DaemonJVMOptions daemonJVMOptions = RmiPackage.configureDaemonJVMOptions(true);
+
+            ArrayList<DaemonReportMessage> daemonReportMessages = new ArrayList<DaemonReportMessage>();
+
+            CompileService daemon = KotlinCompilerClient.connectToCompileService(compilerId, daemonJVMOptions, daemonOptions, new DaemonReportingTargets(null, daemonReportMessages), true, true);
+
+            for (DaemonReportMessage msg: daemonReportMessages) {
+                if (msg.getCategory() == DaemonReportCategory.EXCEPTION && daemon == null) {
+                    messageCollector.report(CompilerMessageSeverity.INFO,
+                                            ""Falling  back to compilation without daemon due to error: "" + msg.getMessage(),
+                                            CompilerMessageLocation.NO_LOCATION);
+                }
+                else {
+                    messageCollector.report(CompilerMessageSeverity.INFO, msg.getMessage(), CompilerMessageLocation.NO_LOCATION);
+                }
+            }
+
+            if (daemon != null) {
+                ByteArrayOutputStream compilerOut = new ByteArrayOutputStream();
+                ByteArrayOutputStream daemonOut = new ByteArrayOutputStream();
+
+                Integer res = KotlinCompilerClient.incrementalCompile(daemon, argsArray, incrementalCaches, compilerOut, daemonOut);
+
+                ProcessCompilerOutput(messageCollector, collector, compilerOut, res.toString());
+                BufferedReader reader = new BufferedReader(new StringReader(daemonOut.toString()));","will we see non-latin characters? it could be significant for error messages with path to files, for example
",I think we can remove the 
612,"@@ -13,39 +13,45 @@ public fun InputStream.iterator(): ByteIterator =
             public override fun nextByte(): Byte = read().toByte()
         }
 
-/** Creates a buffered input stream */
+/**
+ * Creates a buffered input stream wrapping this stream.
+ * @param bufferSize the buffer size to use.
+ */
 public fun InputStream.buffered(bufferSize: Int = defaultBufferSize): InputStream
         = if (this is BufferedInputStream)
     this
 else
     BufferedInputStream(this, bufferSize)
 
-/** Creates a reader on an input stream using UTF-8 or specified charset. */
+/** Creates a reader on this input stream using UTF-8 or the specified [charset]. */","Need to put it in conventions, wording around documenting parameter with default value.
",I think this should be `@p
613,"@@ -13,79 +13,96 @@ class ParsePrimitivesJVMTest {
     }
 
     @test fun toByte() {
-        assertEqualsOrFailsNullable(77.toByte(), ""+77"", String::toByte, String::toByteOrNull)
-        assertEqualsOrFailsNullable(Byte.MIN_VALUE, ""-128"", String::toByte, String::toByteOrNull)
-        assertEqualsOrFailsNullable(null, ""128"", String::toByte, String::toByteOrNull)
+        CompareBehaviourContext(String::toByte, String::toByteOrNull).apply {
+
+            assertProduce(77.toByte(), ""+77"")
+            assertProduce(Byte.MIN_VALUE, ""-128"")
+            assertProduce(null, ""128"")
+        }
     }
 
     @test fun toShort() {
-        assertEqualsOrFailsNullable(77.toShort(), ""77"", String::toShort, String::toShortOrNull)
-        assertEqualsOrFailsNullable(Short.MIN_VALUE, ""-32768"", String::toShort, String::toShortOrNull)
-        assertEqualsOrFailsNullable(null, ""+32768"", String::toShort, String::toShortOrNull)
+        CompareBehaviourContext(String::toShort, String::toShortOrNull).apply {
+
+            assertProduce(77.toShort(), ""77"")
+            assertProduce(Short.MIN_VALUE, ""-32768"")
+            assertProduce(null, ""+32768"")
+        }
     }
 
     @test fun toInt() {
-        assertEqualsOrFailsNullable(77, ""77"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(Int.MAX_VALUE, ""+2147483647"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(Int.MIN_VALUE, ""-2147483648"", String::toInt, String::toIntOrNull)
+        CompareBehaviourContext(String::toInt, String::toIntOrNull).apply {
+
+            assertProduce(77, ""77"")
+            assertProduce(Int.MAX_VALUE, ""+2147483647"")
+            assertProduce(Int.MIN_VALUE, ""-2147483648"")
 
-        assertEqualsOrFailsNullable(null, ""2147483648"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(null, ""-2147483649"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(null, ""239239kotlin"", String::toInt, String::toIntOrNull)
+            assertProduce(null, ""2147483648"")
+            assertProduce(null, ""-2147483649"")
+            assertProduce(null, ""239239kotlin"")
+        }
     }
 
     @test fun toLong() {
-        assertEqualsOrFailsNullable(77.toLong(), ""77"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(Long.MAX_VALUE, ""+9223372036854775807"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(Long.MIN_VALUE, ""-9223372036854775808"", String::toLong, String::toLongOrNull)
-
-        assertEqualsOrFailsNullable(null, ""9223372036854775808"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""-9223372036854775809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""922337 75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""92233,75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""92233`75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""-922337KOTLIN775809"", String::toLong, String::toLongOrNull)
+        CompareBehaviourContext(String::toLong, String::toLongOrNull).apply {
+
+            assertProduce(77.toLong(), ""77"")
+            assertProduce(Long.MAX_VALUE, ""+9223372036854775807"")
+            assertProduce(Long.MIN_VALUE, ""-9223372036854775808"")
+
+            assertProduce(null, ""9223372036854775808"")
+            assertProduce(null, ""-9223372036854775809"")
+            assertProduce(null, ""922337 75809"")
+            assertProduce(null, ""92233,75809"")
+            assertProduce(null, ""92233`75809"")
+            assertProduce(null, ""-922337KOTLIN775809"")
+        }
     }
 
     @test fun toFloat() {
-        assertEqualsOrFailsNullable(77.0f, ""77.0"", String::toFloat, String::toFloatOrNull)
-        assertEqualsOrFailsNullable(Float.NEGATIVE_INFINITY, ""-1e39"", String::toFloat, String::toFloatOrNull)
-        assertEqualsOrFailsNullable(Float.POSITIVE_INFINITY, ""1000000000000000000000000000000000000000"",
-                String::toFloat, String::toFloatOrNull)
+        CompareBehaviourContext(String::toFloat, String::toFloatOrNull).apply {
 
-        assertEqualsOrFailsNullable(null, ""dark side"", String::toFloat, String::toFloatOrNull)
+            assertProduce(77.0f, ""77.0"")
+            assertProduce(Float.NEGATIVE_INFINITY, ""-1e39"")
+            assertProduce(Float.POSITIVE_INFINITY, ""1000000000000000000000000000000000000000"")
+            assertProduce(null, ""dark side"")
+        }
     }
 
     @test fun toDouble() {
-        assertEqualsOrFailsNullable(-77.0, ""-77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""77."", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""77.0"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(-1.77, ""-1.77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(0.77, ""+.77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(-77.0, ""\t-77 \n"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""7.7e1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""+770e-1"", String::toDouble, String::toDoubleOrNull)
-
-        assertEqualsOrFailsNullable(-Double.NaN, ""-NaN"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(Double.POSITIVE_INFINITY, ""+Infinity"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable((0x77 shl 1).toDouble(), ""0x77p1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(0x77.toDouble(), ""0x.77P8"", String::toDouble, String::toDoubleOrNull)
-
-        assertEqualsOrFailsNullable(null, ""7..7"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(null, ""0x77e1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(null, ""007 not a number"", String::toDouble, String::toDoubleOrNull)
+        CompareBehaviourContext(String::toDouble, String::toDoubleOrNull).apply {
+
+            assertProduce(-77.0, ""-77"")
+            assertProduce(77.0, ""77."")
+            assertProduce(77.0, ""77.0"")
+            assertProduce(-1.77, ""-1.77"")
+            assertProduce(0.77, ""+.77"")
+            assertProduce(-77.0, ""\t-77 \n"")
+            assertProduce(77.0, ""7.7e1"")
+            assertProduce(77.0, ""+770e-1"")
+
+            assertProduce(-Double.NaN, ""-NaN"")
+            assertProduce(Double.POSITIVE_INFINITY, ""+Infinity"")
+            assertProduce((0x77 shl 1).toDouble(), ""0x77p1"")
+            assertProduce(0x77.toDouble(), ""0x.77P8"")
+
+            assertProduce(null, ""7..7"")
+            assertProduce(null, ""0x77e1"")
+            assertProduce(null, ""007 not a number"")
+        }
     }
 }
 
-private inline fun <T: Any> assertEqualsOrFailsNullable(output: T?,
-                                                        input: String,
-                                                        crossinline converOrFail: (String) -> T,
-                                                        crossinline convertOrNull: (String) -> T?) {
-    if(output == null) {
-        assertFails { converOrFail(input) }
-        assertNull (convertOrNull(input) )
-    } else {
-        assertEquals(output, converOrFail(input))
-        assertEquals(output, convertOrNull(input))
+
+private class CompareBehaviourContext<T: Any>(val convertOrFail: (String) -> T,","`Behaviour` we prefer American English in identifiers :)
",Why did you remove the `nu
614,"@@ -13,79 +13,96 @@ class ParsePrimitivesJVMTest {
     }
 
     @test fun toByte() {
-        assertEqualsOrFailsNullable(77.toByte(), ""+77"", String::toByte, String::toByteOrNull)
-        assertEqualsOrFailsNullable(Byte.MIN_VALUE, ""-128"", String::toByte, String::toByteOrNull)
-        assertEqualsOrFailsNullable(null, ""128"", String::toByte, String::toByteOrNull)
+        CompareBehaviourContext(String::toByte, String::toByteOrNull).apply {
+
+            assertProduce(77.toByte(), ""+77"")
+            assertProduce(Byte.MIN_VALUE, ""-128"")
+            assertProduce(null, ""128"")
+        }
     }
 
     @test fun toShort() {
-        assertEqualsOrFailsNullable(77.toShort(), ""77"", String::toShort, String::toShortOrNull)
-        assertEqualsOrFailsNullable(Short.MIN_VALUE, ""-32768"", String::toShort, String::toShortOrNull)
-        assertEqualsOrFailsNullable(null, ""+32768"", String::toShort, String::toShortOrNull)
+        CompareBehaviourContext(String::toShort, String::toShortOrNull).apply {
+
+            assertProduce(77.toShort(), ""77"")
+            assertProduce(Short.MIN_VALUE, ""-32768"")
+            assertProduce(null, ""+32768"")
+        }
     }
 
     @test fun toInt() {
-        assertEqualsOrFailsNullable(77, ""77"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(Int.MAX_VALUE, ""+2147483647"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(Int.MIN_VALUE, ""-2147483648"", String::toInt, String::toIntOrNull)
+        CompareBehaviourContext(String::toInt, String::toIntOrNull).apply {
+
+            assertProduce(77, ""77"")
+            assertProduce(Int.MAX_VALUE, ""+2147483647"")
+            assertProduce(Int.MIN_VALUE, ""-2147483648"")
 
-        assertEqualsOrFailsNullable(null, ""2147483648"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(null, ""-2147483649"", String::toInt, String::toIntOrNull)
-        assertEqualsOrFailsNullable(null, ""239239kotlin"", String::toInt, String::toIntOrNull)
+            assertProduce(null, ""2147483648"")
+            assertProduce(null, ""-2147483649"")
+            assertProduce(null, ""239239kotlin"")
+        }
     }
 
     @test fun toLong() {
-        assertEqualsOrFailsNullable(77.toLong(), ""77"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(Long.MAX_VALUE, ""+9223372036854775807"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(Long.MIN_VALUE, ""-9223372036854775808"", String::toLong, String::toLongOrNull)
-
-        assertEqualsOrFailsNullable(null, ""9223372036854775808"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""-9223372036854775809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""922337 75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""92233,75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""92233`75809"", String::toLong, String::toLongOrNull)
-        assertEqualsOrFailsNullable(null, ""-922337KOTLIN775809"", String::toLong, String::toLongOrNull)
+        CompareBehaviourContext(String::toLong, String::toLongOrNull).apply {
+
+            assertProduce(77.toLong(), ""77"")
+            assertProduce(Long.MAX_VALUE, ""+9223372036854775807"")
+            assertProduce(Long.MIN_VALUE, ""-9223372036854775808"")
+
+            assertProduce(null, ""9223372036854775808"")
+            assertProduce(null, ""-9223372036854775809"")
+            assertProduce(null, ""922337 75809"")
+            assertProduce(null, ""92233,75809"")
+            assertProduce(null, ""92233`75809"")
+            assertProduce(null, ""-922337KOTLIN775809"")
+        }
     }
 
     @test fun toFloat() {
-        assertEqualsOrFailsNullable(77.0f, ""77.0"", String::toFloat, String::toFloatOrNull)
-        assertEqualsOrFailsNullable(Float.NEGATIVE_INFINITY, ""-1e39"", String::toFloat, String::toFloatOrNull)
-        assertEqualsOrFailsNullable(Float.POSITIVE_INFINITY, ""1000000000000000000000000000000000000000"",
-                String::toFloat, String::toFloatOrNull)
+        CompareBehaviourContext(String::toFloat, String::toFloatOrNull).apply {
 
-        assertEqualsOrFailsNullable(null, ""dark side"", String::toFloat, String::toFloatOrNull)
+            assertProduce(77.0f, ""77.0"")
+            assertProduce(Float.NEGATIVE_INFINITY, ""-1e39"")
+            assertProduce(Float.POSITIVE_INFINITY, ""1000000000000000000000000000000000000000"")
+            assertProduce(null, ""dark side"")
+        }
     }
 
     @test fun toDouble() {
-        assertEqualsOrFailsNullable(-77.0, ""-77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""77."", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""77.0"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(-1.77, ""-1.77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(0.77, ""+.77"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(-77.0, ""\t-77 \n"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""7.7e1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(77.0, ""+770e-1"", String::toDouble, String::toDoubleOrNull)
-
-        assertEqualsOrFailsNullable(-Double.NaN, ""-NaN"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(Double.POSITIVE_INFINITY, ""+Infinity"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable((0x77 shl 1).toDouble(), ""0x77p1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(0x77.toDouble(), ""0x.77P8"", String::toDouble, String::toDoubleOrNull)
-
-        assertEqualsOrFailsNullable(null, ""7..7"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(null, ""0x77e1"", String::toDouble, String::toDoubleOrNull)
-        assertEqualsOrFailsNullable(null, ""007 not a number"", String::toDouble, String::toDoubleOrNull)
+        CompareBehaviourContext(String::toDouble, String::toDoubleOrNull).apply {
+
+            assertProduce(-77.0, ""-77"")
+            assertProduce(77.0, ""77."")
+            assertProduce(77.0, ""77.0"")
+            assertProduce(-1.77, ""-1.77"")
+            assertProduce(0.77, ""+.77"")
+            assertProduce(-77.0, ""\t-77 \n"")
+            assertProduce(77.0, ""7.7e1"")
+            assertProduce(77.0, ""+770e-1"")
+
+            assertProduce(-Double.NaN, ""-NaN"")
+            assertProduce(Double.POSITIVE_INFINITY, ""+Infinity"")
+            assertProduce((0x77 shl 1).toDouble(), ""0x77p1"")
+            assertProduce(0x77.toDouble(), ""0x.77P8"")
+
+            assertProduce(null, ""7..7"")
+            assertProduce(null, ""0x77e1"")
+            assertProduce(null, ""007 not a number"")
+        }
     }
 }
 
-private inline fun <T: Any> assertEqualsOrFailsNullable(output: T?,
-                                                        input: String,
-                                                        crossinline converOrFail: (String) -> T,
-                                                        crossinline convertOrNull: (String) -> T?) {
-    if(output == null) {
-        assertFails { converOrFail(input) }
-        assertNull (convertOrNull(input) )
-    } else {
-        assertEquals(output, converOrFail(input))
-        assertEquals(output, convertOrNull(input))
+
+private class CompareBehaviourContext<T: Any>(val convertOrFail: (String) -> T,
+                                              val convertOrNull: (String) -> T?) {
+    fun assertProduce(output: T?, input: String) {
+        if(output == null) {
+            assertFails { convertOrFail(input) }","Please specify input string in the detail message, i.e. something like ""Expected to fail (or return null) on $input""
",Why did you remove the `nu
615,"@@ -13,8 +13,8 @@ private enum class State {
 }
 
 /**
- * A base class to simplify implementing iterators so that implementations only have to implement [[computeNext()]]
- * to implement the iterator, calling [[done()]] when the iteration is complete.
+ * A base class to simplify implementing iterators so that implementations only have to implement [computeNext]","Warning, using this class has performance penalty compared to plain raw implementation per case, measured with JMH when operation per element is relatively cheap.
",I don't think this change 
616,"@@ -132,50 +132,34 @@ public inline fun println() {
     System.out.println()
 }
 
-// Since System.in can change its value on the course of program running,
-// we should always delegate to current value and cannot just pass it to InputStreamReader constructor.
-// We could use ""by"" implementation, but we can only use ""by"" with interfaces and InputStream is abstract class.
-private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(object : InputStream() {
-    public override fun read(): Int {
-        return System.`in`.read()
-    }
-
-    public override fun reset() {
-        System.`in`.reset()
-    }
-
-    public override fun read(b: ByteArray): Int {
-        return System.`in`.read(b)
-    }
-
-    public override fun close() {
-        System.`in`.close()
-    }
-
-    public override fun mark(readlimit: Int) {
-        System.`in`.mark(readlimit)
-    }
-
-    public override fun skip(n: Long): Long {
-        return System.`in`.skip(n)
-    }
-
-    public override fun available(): Int {
-        return System.`in`.available()
-    }
-
-    public override fun markSupported(): Boolean {
-        return System.`in`.markSupported()
-    }
-
-    public override fun read(b: ByteArray, off: Int, len: Int): Int {
-        return System.`in`.read(b, off, len)
-    }
-}))}
-
 /**
  * Reads a line of input from the standard input stream.
  *
  * @return the line read or `null` if the input stream is redirected to a file and the end of file has been reached.
  */
-public fun readLine(): String? = stdin.readLine()
+
+public fun readLine(): String? {
+    val buffer = StringBuilder()
+    var c = System.`in`.read()
+    if(c < 0) return null
+    buffer.append(c.toChar())
+    do {
+        c = System.`in`.read()
+        if(c < 0) return buffer.toString()
+        val ch = c.toChar()","Unfortunately, this will work only for US-ASCII encoding. ",Why do we need to do this?
617,"@@ -132,7 +132,10 @@ map.platform.class.to.kotlin=Change all usages of ''{0}'' in this file to ''{1}'
 map.platform.class.to.kotlin.multiple=Change all usages of ''{0}'' in this file to a Kotlin class
 map.platform.class.to.kotlin.advertisement=Choose an appropriate Kotlin class
 map.platform.class.to.kotlin.family=Change to Kotlin class
-
+create.from.usage.family=Create from usage
+create.method.from.usage=Create method ''{0}'' from usage","In Kotlin, we call them functions, not methods. Please, rename it here and in other code.
",Line is too long. [83/80]
618,"@@ -132,8 +132,13 @@ class AndroidGradleWrapper {
               && variantData.scope.getRenderscriptCompileTask() != null) {
         result.add(variantData.scope.getRenderscriptSourceOutputDir());
       }
+    }
 
-      return result
+    def getExtraSourcesMethod = variantData.getMetaClass().getMetaMethod(""getExtraGeneratedSourceFolders"")
+    if (getExtraSourcesMethod.returnType.metaClass == List.metaClass) {
+      result.addAll(variantData.getExtraGeneratedSourceFolders())","variantData.getExtraGeneratedSourceFolders() is Nullable, so you should check for null, before calling addAll
",Shouldn't this be `if (get
619,"@@ -133,15 +138,32 @@ public void execute() throws MojoExecutionException, MojoFailureException {
         configureCompilerArguments(arguments, compiler);
         printCompilerArgumentsIfDebugEnabled(arguments, compiler);
 
-        MessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog());
+        MavenPluginLogMessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog(), true);
 
         ExitCode exitCode = compiler.exec(messageCollector, Services.EMPTY, arguments);
 
         switch (exitCode) {
             case COMPILATION_ERROR:
-                throw new MojoExecutionException(""Compilation error. See log for more details"");
             case INTERNAL_ERROR:
-                throw new MojoExecutionException(""Internal compiler error. See log for more details"");
+                throw new KotlinCompilationFailureException(
+                        CollectionsKt.map(messageCollector.getCollectedErrors(), new Function1<Pair<CompilerMessageLocation, String>, CompilerMessage>() {","Isn't compiler exception logged as error?
",Why do we need the `true` 
620,"@@ -133,15 +138,32 @@ public void execute() throws MojoExecutionException, MojoFailureException {
         configureCompilerArguments(arguments, compiler);
         printCompilerArgumentsIfDebugEnabled(arguments, compiler);
 
-        MessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog());
+        MavenPluginLogMessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog(), true);
 
         ExitCode exitCode = compiler.exec(messageCollector, Services.EMPTY, arguments);
 
         switch (exitCode) {
             case COMPILATION_ERROR:
-                throw new MojoExecutionException(""Compilation error. See log for more details"");
             case INTERNAL_ERROR:
-                throw new MojoExecutionException(""Internal compiler error. See log for more details"");
+                throw new KotlinCompilationFailureException(
+                        CollectionsKt.map(messageCollector.getCollectedErrors(), new Function1<Pair<CompilerMessageLocation, String>, CompilerMessage>() {
+                            @Override
+                            public CompilerMessage invoke(Pair<CompilerMessageLocation, String> pair) {
+                                String lineContent = pair.getFirst().getLineContent();
+                                int lineContentLength = lineContent == null ? 0 : lineContent.length();
+
+                                return new CompilerMessage(
+                                        pair.getFirst().getPath(),
+                                        CompilerMessage.Kind.ERROR,
+                                        pair.getFirst().getLine(),","Are they zero-based in `CompilerMessageLocation` ?
",Why do we need to pass `tr
621,"@@ -133,16 +137,32 @@ public void execute() throws MojoExecutionException, MojoFailureException {
         configureCompilerArguments(arguments, compiler);
         printCompilerArgumentsIfDebugEnabled(arguments, compiler);
 
-        MessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog());
+        MavenPluginLogMessageCollector messageCollector = new MavenPluginLogMessageCollector(getLog());
 
         ExitCode exitCode = compiler.exec(messageCollector, Services.EMPTY, arguments);
 
-        switch (exitCode) {
-            case COMPILATION_ERROR:
-                throw new MojoExecutionException(""Compilation error. See log for more details"");
-            case INTERNAL_ERROR:
-                throw new MojoExecutionException(""Internal compiler error. See log for more details"");
-            default:
+        if (exitCode != ExitCode.OK) {
+            throw new KotlinCompilationFailureException(
+                    CollectionsKt.map(messageCollector.getCollectedErrors(), new Function1<Pair<CompilerMessageLocation, String>, CompilerMessage>() {
+                        @Override
+                        public CompilerMessage invoke(Pair<CompilerMessageLocation, String> pair) {
+                            CompilerMessageLocation location = pair.getFirst();
+                            String message = pair.getSecond();
+                            String lineContent = location.getLineContent();
+                            int lineContentLength = lineContent == null ? 0 : lineContent.length();
+
+                            return new CompilerMessage(
+                                    location.getPath(),
+                                    CompilerMessage.Kind.ERROR,","yes, but in this case it looks not so clear that there is -1 and 0 with special meaning
",I think it would be better
622,"@@ -133,8 +133,12 @@ private QuickFixes() {}
         actions.put(VAL_WITH_SETTER, changeVariableMutabilityFix);
         actions.put(VAL_REASSIGNMENT, changeVariableMutabilityFix);
 
-        actions.put(UNNECESSARY_SAFE_CALL, new ReplaceCallFix(false));
-        actions.put(UNSAFE_CALL, new ReplaceCallFix(true));
+        actions.put(UNNECESSARY_SAFE_CALL, new ReplaceCallFix(true, false));
+        actions.put(UNSAFE_CALL, new ReplaceCallFix(true, true));
+        actions.put(UNSAFE_CALL, new ReplaceCallFix(false, true));","Two booleans in parameters almost always look bad because it's difficult to read such code. It's better to provide static constructors like ReplaceCallFix.toDotCall(), ReplaceCallFix.toQuestionMarkCall(), ReplaceCallFix.toExclamationCall(). Another alternative is to create and pass as parameter some enumeration.
",Why do we need this change
623,"@@ -133,8 +133,14 @@ private QuickFixes() {}
         actions.put(VAL_WITH_SETTER, changeVariableMutabilityFix);
         actions.put(VAL_REASSIGNMENT, changeVariableMutabilityFix);
 
-        actions.put(UNNECESSARY_SAFE_CALL, new ReplaceCallFix(false));
-        actions.put(UNSAFE_CALL, new ReplaceCallFix(true));
+        actions.put(UNNECESSARY_SAFE_CALL, ReplaceCallFix.toDotCallFromSafeCall());
+        actions.put(UNSAFE_CALL, ReplaceCallFix.toSafeCall());
+
+        actions.put(UNSAFE_CALL, ReplaceCallFix.toNonNullAssertedCall());
+        actions.put(UNNECESSARY_NOT_NULL_ASSERTION, ReplaceCallFix.toDotCallFromNonNullAssertedCall());
+
+        actions.put(UNNECESSARY_NOT_NULL_ASSERTION, new UnnecessaryNotNullAssertionFix());","Both quick fixes are available for this code snippet:
fun test(value : String) : String {
  return value!!.toString()
}

I suggest to forbid one from UnnecessaryNotNullAssertionFix if warning is in the middle of DOT_QUALIFIED_EXPRESSION.

By the way, Sergey, what tools do you use for monitoring PSI tree. I don't remember did I tell you about Tools->View PSI structure of current file?
",Why do we need this change
624,"@@ -135,4 +136,23 @@ public static KotlinSingleIntentionActionFactory createFactory() {
             }
         };
     }
+
+    public static KotlinSingleIntentionActionFactory createLateInitFactory() {","Please convert this file to Kotlin if you're adding substantial new code to it. (Rename to .kt, commit, then rename back to .java, run J2K, make any changes needed for the project to compile, commit again, then make your changes.)",
625,"@@ -135,4 +136,23 @@ public static KotlinSingleIntentionActionFactory createFactory() {
             }
         };
     }
+
+    public static KotlinSingleIntentionActionFactory createLateInitFactory() {
+        return new KotlinSingleIntentionActionFactory() {
+            @Override
+            public KotlinQuickFixAction<KtProperty> createAction(@NotNull Diagnostic diagnostic) {
+                PsiElement element = Errors.INAPPLICABLE_LATEINIT_MODIFIER.cast(diagnostic).getPsiElement();
+                KtProperty property = PsiTreeUtil.getParentOfType(element, KtProperty.class);
+                if (property == null) return null;
+
+                boolean hasInitializer = property.hasInitializer();
+                boolean hasGetter = property.getGetter() != null && property.getGetter().getBodyExpression() != null;","The getter and setter checks are not needed. This quickfix should apply to any lateinit property; _late_init means that it's initialized somewhere in the class, and this applies to regular properties with default getters and setters too.",I
626,"@@ -135,7 +135,7 @@ public inline fun println() {
 // Since System.in can change its value on the course of program running,
 // we should always delegate to current value and cannot just pass it to InputStreamReader constructor.
 // We could use ""by"" implementation, but we can only use ""by"" with interfaces and InputStream is abstract class.
-private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(object : InputStream() {
+private val stdin: InputStreamReader by lazy { InputStreamReader(object : InputStream() {","If we're not going to buffer contents, `stdin` wrapper isn't required anymore.",W
627,"@@ -137,6 +137,16 @@
     )
     public String[] scriptResolverEnvironment;
 
+    // Javac options
+    @Argument(value = ""-Xuse-javac"", description = ""Use Javac analysis"")","Consider something like `""Use javac for analysis of Java source and class files""`",@
628,"@@ -139,29 +140,34 @@ public fun File.readLines(charset: Charset = Charsets.UTF_8): List<String> {
     return result
 }
 
-/** Creates a buffered reader, or returns self if Reader is already buffered */
+/** Creates a buffered reader wrapping this Reader, or returns self if Reader is already buffered */","self -> this Reader
",/
629,"@@ -139,29 +140,34 @@ public fun File.readLines(charset: Charset = Charsets.UTF_8): List<String> {
     return result
 }
 
-/** Creates a buffered reader, or returns self if Reader is already buffered */
+/** Creates a buffered reader wrapping this Reader, or returns self if Reader is already buffered */
 public fun Reader.buffered(bufferSize: Int = defaultBufferSize): BufferedReader
         = if (this is BufferedReader) this else BufferedReader(this, bufferSize)
 
-/** Creates a buffered writer, or returns self if Writer is already buffered */
+/** Creates a buffered writer wrapping this Writer, or returns self if Writer is already buffered */","self -> this Writer
",I
630,"@@ -139,4 +139,214 @@ The compiler issues warnings specific to `@Nullable`/`@NotNull` in the following
  - a `@Nullable` value is assigned to a not-null location (including passing parameters and receivers to functions/properties);
  - a nullable value is assigned to a `@NotNull` location;
  - a `@NotNull` value is dereferenced with a safe call (`?.`), used in `!!` or on the left-hand side of an elvis operator `?:`;
- - a `@NotNull` value is compared with `null` through `==`, `!=`, `===` or `!==`
\ No newline at end of file
+ - a `@NotNull` value is compared with `null` through `==`, `!=`, `===` or `!==`
+
+## More precise type information from annotations
+
+Goals:
+ - Catch more errors related to nullability in case of Java interop
+ - Keep all class hierarchies consistent at all times (no hierarchy errors related to incorrect annotations)
+ - (!) If the code compiled with annotations, it should always compile without annotations (because external annotations may disappear)
+
+ This process never results in errors. On any mismatch, a bare platform signature is used (and a warning issued).
+
+### Annotations recognized by the compiler
+
+- `org.jetbrains.annotations.Nullable` - value may be null/accepts nulls","Why only the JetBrains versions and not also javax.annotations versions? My own code won't benefit if this is the complete list.
",I
631,"@@ -139,4 +139,214 @@ The compiler issues warnings specific to `@Nullable`/`@NotNull` in the following
  - a `@Nullable` value is assigned to a not-null location (including passing parameters and receivers to functions/properties);
  - a nullable value is assigned to a `@NotNull` location;
  - a `@NotNull` value is dereferenced with a safe call (`?.`), used in `!!` or on the left-hand side of an elvis operator `?:`;
- - a `@NotNull` value is compared with `null` through `==`, `!=`, `===` or `!==`
\ No newline at end of file
+ - a `@NotNull` value is compared with `null` through `==`, `!=`, `===` or `!==`
+
+## More precise type information from annotations
+
+Goals:
+ - Catch more errors related to nullability in case of Java interop
+ - Keep all class hierarchies consistent at all times (no hierarchy errors related to incorrect annotations)
+ - (!) If the code compiled with annotations, it should always compile without annotations (because external annotations may disappear)
+
+ This process never results in errors. On any mismatch, a bare platform signature is used (and a warning issued).
+
+### Annotations recognized by the compiler
+
+- `org.jetbrains.annotations.Nullable` - value may be null/accepts nulls
+- `org.jetbrains.annotations.NotNull` - value can not be null/passing null leads to an exception
+- `org.jetbrains.annotations.ReadOnly` - only non-mutating methods can be used on this collection/iterable/iterator
+- `org.jetbrains.annotations.Mutable` - only non-mutating methods can be used on this collection/iterable/iterator","This description seems duplicated?
",I
632,"@@ -139,8 +140,8 @@ public boolean isVar() {
 
     @NotNull
     @Override
-    public ValueParameterDescriptor copy(@NotNull DeclarationDescriptor newOwner) {
-        return new ValueParameterDescriptorImpl(newOwner, index, Lists.newArrayList(getAnnotations()), getName(), getType(), hasDefaultValue, varargElementType);
+    public ValueParameterDescriptor copy(@NotNull DeclarationDescriptor newOwner, @NotNull Name newName) {
+        return new ValueParameterDescriptorImpl(newOwner, index, Lists.newArrayList(getAnnotations()), newName, getType(), declaresDefaultValue(), varargElementType);","I have changed `hasDefaultValue` to `declaresDefaultValue()` - I think that is correct (the constructor parameter is named `declaresDefaultValue`). Besides, `hasDefaultValue` is computed lazily in `hasDefaultValue()` and can be `null` resulting in `NullPointerException` (which, in fact, it does).
",`
633,"@@ -14,48 +14,47 @@ public fun Appendable.appendln(value: CharSequence?): Appendable = append(value)
 /** Appends value to the given Appendable and line separator after it. */
 public fun Appendable.appendln(value: Char): Appendable = append(value).append(LINE_SEPARATOR)
 
-/** Appends line separator to StringBuilder. */
-
+/** Appends a line separator to this StringBuilder. */
 public fun StringBuilder.appendln(): StringBuilder = append(LINE_SEPARATOR)
 
-/** Appends value to the given StringBuilder and line separator after it. */
+/** Appends value to this StringBuilder and line separator after it. */","backtickify value, linkify StringBuilder
",T
634,"@@ -14,6 +14,44 @@ public fun File.recurse(block: (File) -> Unit): Unit {
 }
 
 /**
+ * Create an empty directory in the specified directory, using the given prefix and suffix to generate its name.
+ * Prefix shouldn't be shorter than 3 symbols or IllegalArgumentException will be thrown.
+ *
+ * If prefix is not specified then some unspecified name will be used.
+ * If suffix is not specified then "".tmp"" will be used.
+ * If directory is not specified then the default temporary-file directory will be used.
+ *
+ * Returns a file object corresponding to a newly-created directory.
+ *
+ * If some error occurs then IOException is thrown.
+ */
+public fun createTempDir(prefix: String = ""tmp"", suffix: String? = null, directory: File? = null): File {","I don't really like global functions in stdlib, until absolutely necessary. They pollute global namespace, since they are in the `kotlin` package. Consider creating object to group them into. 
",I
635,"@@ -14,7 +14,7 @@ fun elements(): List<GenericFunction> {
         doc { f -> ""Returns `true` if [element] is found in the ${f.collection}."" }
         typeParam(""@kotlin.internal.OnlyInputTypes T"")
         returns(""Boolean"")
-        body(Iterables) { f ->
+        body(Iterables) {","Please extract unrelated changes, such as formatting improvement in a separate PR.",W
636,"@@ -14,88 +14,77 @@ import java.util.Collections // TODO: it's temporary while we have java.util.Col
  * Returns an ArrayList of all elements
  */
 public fun <T> Array<out T>.toArrayList(): ArrayList<T> {
-    val list = ArrayList<T>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun BooleanArray.toArrayList(): ArrayList<Boolean> {
-    val list = ArrayList<Boolean>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun ByteArray.toArrayList(): ArrayList<Byte> {
-    val list = ArrayList<Byte>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun CharArray.toArrayList(): ArrayList<Char> {
-    val list = ArrayList<Char>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun DoubleArray.toArrayList(): ArrayList<Double> {
-    val list = ArrayList<Double>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun FloatArray.toArrayList(): ArrayList<Float> {
-    val list = ArrayList<Float>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun IntArray.toArrayList(): ArrayList<Int> {
-    val list = ArrayList<Int>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun LongArray.toArrayList(): ArrayList<Long> {
-    val list = ArrayList<Long>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun ShortArray.toArrayList(): ArrayList<Short> {
-    val list = ArrayList<Short>(size())
-    for (item in this) list.add(item)
-    return list
+    return this.asList().toArrayList()
+}
+
+/**
+ * Returns an ArrayList of all elements
+ */
+public fun <T> Collection<T>.toArrayList(): ArrayList<T> {
+    return ArrayList(this)
 }
 
 /**
  * Returns an ArrayList of all elements
  */
 public fun <T> Iterable<T>.toArrayList(): ArrayList<T> {
-    return toCollection(ArrayList<T>(collectionSizeOrDefault(10)))
+    return toCollection(ArrayList<T>())","Still it makes sense to check an actual type of this `Iterable` and switch to `Collection.toArrayList` in case if this is a collection.
",T
637,"@@ -141,13 +141,28 @@ public static void checkAnnotationType(
         }
     }
 
+    @Nullable
+    private static <T extends PsiElement> T findAncestorOfType(@NotNull PsiElement element, Class<T> ancestorType) {","There is already `getParentOfType`, please use it here",
638,"@@ -141,6 +183,64 @@ public open class KotlinCompile(): AbstractCompile() {
     }
 }
 
+public open class Kotlin2JsCompile(): AbstractKotlinCompile<K2JSCompilerArguments>() {
+    override val compiler = K2JSCompiler()
+
+    override fun createBlankArgs(): K2JSCompilerArguments = K2JSCompilerArguments()
+
+    public fun addLibraryFiles(vararg fs: String) {
+        kotlinOptions.libraryFiles = (kotlinOptions.libraryFiles + fs).copyToArray()
+    }
+
+    public fun addLibraryFiles(vararg fs: File) {
+        val strs = fs.map{it.getPath()}.copyToArray()
+        addLibraryFiles(*strs)
+    }
+
+    fun outputFile(): String {
+        return if (StringUtils.isEmpty(kotlinOptions.outputFile)) {
+            ""${kotlinDestinationDir}/app.js""","I think outputFile can not be omitted and if it omitted compilation should be failed.
",W
639,"@@ -141,6 +183,64 @@ public open class KotlinCompile(): AbstractCompile() {
     }
 }
 
+public open class Kotlin2JsCompile(): AbstractKotlinCompile<K2JSCompilerArguments>() {
+    override val compiler = K2JSCompiler()
+
+    override fun createBlankArgs(): K2JSCompilerArguments = K2JSCompilerArguments()
+
+    public fun addLibraryFiles(vararg fs: String) {
+        kotlinOptions.libraryFiles = (kotlinOptions.libraryFiles + fs).copyToArray()
+    }
+
+    public fun addLibraryFiles(vararg fs: File) {
+        val strs = fs.map{it.getPath()}.copyToArray()
+        addLibraryFiles(*strs)
+    }
+
+    fun outputFile(): String {
+        return if (StringUtils.isEmpty(kotlinOptions.outputFile)) {
+            ""${kotlinDestinationDir}/app.js""
+        } else {
+            kotlinOptions.outputFile
+        }
+    }
+
+    public fun sourceMapDestinationDir(): File = File(outputFile()).directory
+
+    {
+        getOutputs().file(MethodClosure(this, ""outputFile""))
+    }
+
+    override fun populateTargetSpecificArgs(args: K2JSCompilerArguments, sources: ArrayList<File>) {
+        args.outputFile = outputFile()
+        args.outputPrefix = kotlinOptions.outputPrefix
+        args.outputPostfix = kotlinOptions.outputPostfix
+        args.libraryFiles = kotlinOptions.libraryFiles
+        args.target = kotlinOptions.target
+        args.sourceMap = kotlinOptions.sourceMap
+
+        val outputDir = File(args.outputFile).directory
+        if (!outputDir.exists()) {
+            if (!outputDir.mkdirs()) {
+               throw GradleException(""Failed to create output directory ${outputDir} or one of its ancestors"")
+            }
+        }
+    }
+}
+
+public open class RewritePathsInSourceMap(): DefaultTask() {
+    var sourceMapPath: () -> String = {""""}
+    var sourceRootDir: () -> String = {""""}
+
+    [TaskAction] fun rewrite() {
+        val file = File(sourceMapPath())
+        val text = file.readText(""UTF-8"")","charset parameter may be omitted -- UTF-8 will by use by default
",W
640,"@@ -141,7 +185,63 @@ public open class KotlinCompile(): AbstractCompile() {
     }
 }
 
-public open class KDoc(): SourceTask() {
+public open class Kotlin2JsCompile() : AbstractKotlinCompile<K2JSCompilerArguments>() {
+    override val compiler = K2JSCompiler()
+
+    override fun createBlankArgs(): K2JSCompilerArguments = K2JSCompilerArguments()
+
+    public fun addLibraryFiles(vararg fs: String) {","I think we should extract all libraries from dependencies instead.
",nit: `K2JSCompilerArguments` -> `K2JSCompiler`
641,"@@ -141,7 +185,63 @@ public open class KotlinCompile(): AbstractCompile() {
     }
 }
 
-public open class KDoc(): SourceTask() {
+public open class Kotlin2JsCompile() : AbstractKotlinCompile<K2JSCompilerArguments>() {
+    override val compiler = K2JSCompiler()
+
+    override fun createBlankArgs(): K2JSCompilerArguments = K2JSCompilerArguments()
+
+    public fun addLibraryFiles(vararg fs: String) {
+        kotlinOptions.libraryFiles = (kotlinOptions.libraryFiles + fs).copyToArray()
+    }
+
+    public fun addLibraryFiles(vararg fs: File) {
+        val strs = fs.map { it.getPath() }.copyToArray()
+        addLibraryFiles(*strs)
+    }
+
+    fun outputFile(): String? = kotlinOptions.outputFile
+
+    public fun sourceMapDestinationDir(): File = File(outputFile()).directory
+
+    {
+        getOutputs().file(MethodClosure(this, ""outputFile""))
+    }
+
+    override fun populateTargetSpecificArgs(args: K2JSCompilerArguments) {
+        args.outputFile = outputFile()
+        args.outputPrefix = kotlinOptions.outputPrefix
+        args.outputPostfix = kotlinOptions.outputPostfix
+        args.libraryFiles = kotlinOptions.libraryFiles
+        args.target = kotlinOptions.target
+        args.sourceMap = kotlinOptions.sourceMap
+
+        if (args.outputFile == null) {
+            throw GradleException(""${getName()}.kotlinOptions.outputFile must be set to a string."")
+        }
+
+        val outputDir = File(args.outputFile).directory
+        if (!outputDir.exists()) {
+            if (!outputDir.mkdirs()) {
+                throw GradleException(""Failed to create output directory ${outputDir} or one of its ancestors"")
+            }
+        }
+    }
+}
+
+public open class RewritePathsInSourceMap() : DefaultTask() {","Ideally it should be fixed in compiler as part of [KT-4078](https://youtrack.jetbrains.com/issue/KT-4078). You can just add TODO comment that this hack should be dropped after KT-4078 will be fixed or fix it :)
",Why do we need to override this method?
642,"@@ -142,7 +176,7 @@ public inline fun <K, V, R, C : MutableMap<R, V>> Map<K, V>.mapKeysTo(destinatio
 }
 
 /**
- * Puts all the entries into this [[MutableMap]] with the first value in the pair being the key and the second the value
+ * Puts all the entries into this [MutableMap] with the first value in the pair being the key and the second the value","""Puts given values"", and again value vs component for Pair.
",I don't think this should be changed.
643,"@@ -144,8 +146,14 @@ fun createKeywordConstructLookupElement(
                     val beforeCaret = tailBeforeCaret.indentLinesAfterFirst(newIndent)
                     val afterCaret = tailAfterCaret.indentLinesAfterFirst(newIndent)
 
-                    insertionContext.document.insertString(offset, beforeCaret + afterCaret)
-                    insertionContext.editor.moveCaret(offset + beforeCaret.length)
+                    val element = insertionContext.file.findElementAt(offset)?.getNextSiblingIgnoringWhitespaceAndComments(true)","Why getNextSiblingIgnoringWhitespaceAndComments() is needed? I expect that it is for 'for' keyword completion, but at least one test needed for it.
I also think that there shouldn't be comments skipping.",Why is this change necessary?
644,"@@ -144,8 +146,14 @@ fun createKeywordConstructLookupElement(
                     val beforeCaret = tailBeforeCaret.indentLinesAfterFirst(newIndent)
                     val afterCaret = tailAfterCaret.indentLinesAfterFirst(newIndent)
 
-                    insertionContext.document.insertString(offset, beforeCaret + afterCaret)
-                    insertionContext.editor.moveCaret(offset + beforeCaret.length)
+                    val element = insertionContext.file.findElementAt(offset)?.getNextSiblingIgnoringWhitespaceAndComments(true)
+
+                    if (element != null && beforeCaret.trimStart().startsWith(insertionContext.document.getText(TextRange.from(element.startOffset, 1)))) {",I think it will be more safe to use == instead of startsWith(),Please use `TextRange.from(element.startOffset
645,"@@ -145,10 +145,22 @@ private static JetElement overrideFunction(Project project, JetFile file, Simple
         StringBuilder bodyBuilder = new StringBuilder(""override fun "");
         bodyBuilder.append(descriptor.getName());
         bodyBuilder.append(""("");
+        boolean isAbstractFun = descriptor.getModality() == Modality.ABSTRACT;
+        StringBuilder delegationBuilder = new StringBuilder();","It's not very critical now, but I think that your decision to barter flat and simple structure of this method to one more iteration over parameters collection was a bad deal. Now it's really difficult to understand the logic of filling StringBuilder variables.
",This is not needed.
646,"@@ -15,6 +15,7 @@ public abstract class Mine</*0*/ T> : java.util.AbstractList<T> {
     public open /*fake_override*/ fun clear(): kotlin.Unit
     public open /*fake_override*/ fun contains(/*0*/ T!): kotlin.Boolean
     public open /*fake_override*/ fun containsAll(/*0*/ kotlin.collections.Collection<T!>): kotlin.Boolean
+    public open /*fake_override*/ fun forEach(/*0*/ java.util.function.Consumer<in T!>!): kotlin.Unit","You'd better not to change existing tests, but to create a new test group with the same test data and your flag enabled.",public open /*fake_override*/ fun forEach(/*0*
647,"@@ -151,7 +185,7 @@ public fun <K, V> MutableMap<K, V>.putAll(vararg values: Pair<K, V>): Unit {
 }
 
 /**
- * Puts all the entries into this [[MutableMap]] with the first value in the pair being the key and the second the value
+ * Puts all the entries into this [MutableMap] with the first value in the pair being the key and the second the value","""Puts elements of the given collection""
",I don't think this should be changed.
648,"@@ -152,13 +152,14 @@ class ClassBodyConverter(private val psiClass: PsiClass,
     ): Member? {
         when (member) {
             is PsiMethod -> {
-                memberToPropertyInfo[member]?.let { propertyInfo ->
-                    if (propertyInfo.field != null) return null // just drop the method, property will be generated when converting the field
-                    return if (member == propertyInfo.getMethod || propertyInfo.getMethod == null)
-                        converter.convertProperty(propertyInfo, classKind)
-                    else
-                        null // drop the method, property will be generated when converting the field or the getter
-                }
+                if (!member.hasModifierProperty(PsiModifier.NATIVE))","This doesn't seem to be a correct check. This is valid Kotlin:

``` kotlin
val foo: Int = 0
    external get
```
",Why is this change needed?
649,"@@ -1520,6 +1520,15 @@
                      language=""kotlin""
     />
 
+    <localInspection implementationClass=""org.jetbrains.kotlin.idea.inspections.UnnecessaryJavaUsageInspection""
+                     displayName=""Unnecessary java usage""","This is no more clear than the same text in the inspection description, and also needs to be changed.
",
650,"@@ -1520,6 +1520,15 @@
                      language=""kotlin""
     />
 
+    <localInspection implementationClass=""org.jetbrains.kotlin.idea.inspections.UnnecessaryJavaUsageInspection""
+                     displayName=""Unnecessary java usage""
+                     groupName=""Kotlin""
+                     enabledByDefault=""true""
+                     cleanupTool=""true""
+                     level=""WARNING""","This should be a WEAK_WARNING at most. There's nothing wrong with the original code - it's simply not as concise as it could be.
",I think it would be better to use `<LocalInspe
651,"@@ -1564,4 +1568,36 @@ public static void checkParameterHasNoValOrVar(
             trace.report(diagnosticFactory.on(valOrVarNode.getPsi(), ((JetKeywordToken) valOrVarNode.getElementType())));
         }
     }
+
+    private static void checkConstructorParameterHasNoModifier(
+            @NotNull BindingTrace trace,
+            @NotNull JetParameter parameter,
+            @NotNull DiagnosticFactory1<PsiElement, JetKeywordToken> diagnosticFactory
+    ) {
+        // If is not a property, then it must have no modifier
+        if (parameter.getValOrVarNode() == null) {
+            checkParameterHasNoModifier(trace, parameter, diagnosticFactory);
+        }
+    }
+
+    public static void checkParameterHasNoModifier(
+            @NotNull BindingTrace trace,
+            @NotNull JetParameter parameter,
+            @NotNull DiagnosticFactory1<PsiElement, JetKeywordToken> diagnosticFactory
+    ) {
+        JetModifierList modifiers = parameter.getModifierList();
+        if (modifiers != null) {
+            ASTNode node = modifiers.getNode().getFirstChildNode();
+
+            while (node != null) {
+                IElementType elementType = node.getElementType();
+
+                if (elementType != JetTokens.VARARG_KEYWORD && elementType instanceof JetKeywordToken) {
+                    trace.report(diagnosticFactory.on(node.getPsi(), (JetKeywordToken) elementType));
+                    break;","fun foo(public abstract x: Int) //abstract should also highlighted as error 
",I think it would be better to use `JetTokens.V
652,"@@ -158,6 +157,7 @@ protected void blackBox() {
             Method method = aClass.getMethod(""box"");
             String r = (String) method.invoke(null);
             assertEquals(""OK"", r);
+            System.out.println(generateToText());","I beleive this was commited erroneously.
",Please remove this line.
653,"@@ -16,10 +16,25 @@
 
 package kotlin
 
+/**
+ * Represents a sequence of numbers or characters with a given start value, end value and step.
+ * This class is intended to be used in 'for' loops, and the JVM backend suggests efficient
+ * bytecode generation for it. Progressions with a step of -1 can be created through the
+ * `downTo` method on classes representing primitive types.","Link to `downTo` method.
",I'm not sure if this is the best name for this
654,"@@ -16,10 +16,25 @@
 
 package kotlin
 
+/**
+ * Represents a sequence of numbers or characters with a given start value, end value and step.
+ * This class is intended to be used in 'for' loops, and the JVM backend suggests efficient
+ * bytecode generation for it. Progressions with a step of -1 can be created through the
+ * `downTo` method on classes representing primitive types.
+ */
 public trait Progression<out N : Any> : Iterable<N> {
+    /**
+     * The start value of a progression.
+     */
     public val start: N
 
+    /**
+     * The end value of the progression (inclusive).","start ""a progression"", end ""the progression""
",I don't think we need the `<out>` here.
655,"@@ -16,10 +16,25 @@
 
 package kotlin
 
+/**
+ * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
+ */
 public open class Any {
+    /**
+     * Indicates whether some other object is ""equal to"" this one. Implementations must follow
+     * the same contract as the [Java equals() method](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29).","Referencing Java in such a way doesn't make it look like a standard library for a _language_, which is targeting different platforms. E.g. for JS it may be different contract.
","""Indicates whether this object is equal to thi"
656,"@@ -16,10 +16,25 @@
 
 package kotlin
 
+/**
+ * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
+ */
 public open class Any {
+    /**
+     * Indicates whether some other object is ""equal to"" this one. Implementations must follow
+     * the same contract as the [Java equals() method](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29).
+     * Note that the `==` operator in Kotlin code is translated into a null-safe call to [equals].","Expand ""null-safe call"". I would read it as ""a?.equals(b)"" which is wrong, because expression type for `==` is `Boolean`, not `Boolean?`
",I think it would be better to use `java.lang.Object` instead of `java.lang.Object`.
657,"@@ -16,10 +16,25 @@
 
 package kotlin
 
+/**
+ * The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.
+ */
 public open class Any {
+    /**
+     * Indicates whether some other object is ""equal to"" this one. Implementations must follow
+     * the same contract as the [Java equals() method](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29).
+     * Note that the `==` operator in Kotlin code is translated into a null-safe call to [equals].
+     */
     public open fun equals(other: Any?): Boolean
 
+    /**
+     * Returns a hash code value for the object. Implementations must follow the same contract
+     * as the [Java hashCode() method](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode%28%29).","Same note about Java-ism.
",I think it would be better to use `java.lang.Object` instead of `java.lang.Object`.
658,"@@ -16,10 +16,30 @@
 
 package kotlin
 
+/**
+ * Marks the annotated class as a data class. Data classes have automatically generated","""When processing data class, compiler will generate""...
",
659,"@@ -16,11 +16,17 @@
 
 package org.jetbrains.jet.plugin.refactoring.rename;
 
-import org.jetbrains.jet.JetTestUtils;
-import org.jetbrains.jet.test.TestMetadata;
+import junit.framework.Assert;
+import junit.framework.Test;
+import junit.framework.TestSuite;
 
 import java.io.File;
 import java.util.regex.Pattern;
+import org.jetbrains.jet.JetTestUtils;
+import org.jetbrains.jet.test.InnerTestClasses;
+import org.jetbrains.jet.test.TestMetadata;
+
+import org.jetbrains.jet.plugin.refactoring.rename.AbstractRenameTest;","Changes in this file shouldn't have been included in your pull request
",Why is this needed?
660,"@@ -16,13 +16,31 @@
 
 package kotlin
 
+/**
+ * Returns true if the receiver and the [other] object are the same object instance, or if they
+ * are both null.
+ */
 public fun Any?.identityEquals(other: Any?): Boolean // = this === other
 
+/**
+ * Returns true if the receiver and the [other] object are ""equal"" to each other, or if they are","Link to Any.equals() on ""equal"" would be good, to refer to explanation of equality.
",I think this should be `public bool identityEquals(other: Any?);`
661,"@@ -16,13 +16,44 @@
 
 package kotlin
 
+/**
+ * Represents an array (specifically, a Java array when targeting the JVM platform).
+ * Array instances can be created using the [array] and [arrayOfNulls] standard
+ * library functions.
+ * See [Kotlin language documentation](http://kotlinlang.org/docs/reference/basic-types.html#arrays)
+ * for more information on arrays.
+ */
 public class Array<reified T> private (): Cloneable {
+    /**
+     * Returns the array element at the specified [index]. This method can be called using the
+     * brackets notation:","We usually call it ""index operator"", I think, not ""brackets notation"".
",I think it would be better to use `Array<T>` instead of `Array<reified>`.
662,"@@ -16,13 +16,44 @@
 
 package kotlin
 
+/**
+ * Represents an array (specifically, a Java array when targeting the JVM platform).
+ * Array instances can be created using the [array] and [arrayOfNulls] standard
+ * library functions.
+ * See [Kotlin language documentation](http://kotlinlang.org/docs/reference/basic-types.html#arrays)
+ * for more information on arrays.
+ */
 public class Array<reified T> private (): Cloneable {
+    /**
+     * Returns the array element at the specified [index]. This method can be called using the
+     * brackets notation:
+     * ```
+     * val = arr[index]","bad example, ""val"" is keyword. 
",I think it would be better to use `Array<T>` instead of `Array<reified>`.
663,"@@ -16,13 +16,44 @@
 
 package kotlin
 
+/**
+ * Represents an array (specifically, a Java array when targeting the JVM platform).
+ * Array instances can be created using the [array] and [arrayOfNulls] standard
+ * library functions.
+ * See [Kotlin language documentation](http://kotlinlang.org/docs/reference/basic-types.html#arrays)
+ * for more information on arrays.
+ */
 public class Array<reified T> private (): Cloneable {
+    /**
+     * Returns the array element at the specified [index]. This method can be called using the
+     * brackets notation:
+     * ```
+     * val = arr[index]
+     * ```
+     */
     public fun get(index: Int): T
+
+    /**
+     * Sets the array element at the specified [index] to the specified [value]. This method can
+     * be called using the brackets notation:
+     * ```
+     * arr[index] = val","Same here for ""brackets"" and ""val""
",I think it would be better to use `Array<T>` instead of `Array<T>`.
664,"@@ -16,13 +16,44 @@
 
 package kotlin
 
+/**
+ * Represents an array (specifically, a Java array when targeting the JVM platform).
+ * Array instances can be created using the [array] and [arrayOfNulls] standard
+ * library functions.
+ * See [Kotlin language documentation](http://kotlinlang.org/docs/reference/basic-types.html#arrays)
+ * for more information on arrays.
+ */
 public class Array<reified T> private (): Cloneable {
+    /**
+     * Returns the array element at the specified [index]. This method can be called using the
+     * brackets notation:
+     * ```
+     * val = arr[index]
+     * ```
+     */
     public fun get(index: Int): T
+
+    /**
+     * Sets the array element at the specified [index] to the specified [value]. This method can
+     * be called using the brackets notation:
+     * ```
+     * arr[index] = val
+     * ```
+     */
     public fun set(index: Int, value: T): Unit
 
+    /**
+     * Returns the length of the array.","""Returns number of elements in the array"". Method called ""size"" shouldn't be described with word ""length""
",I think it would be better to use `Array<T>` instead of `Array<reified>`.
665,"@@ -16,14 +16,9 @@
 
 package org.jetbrains.kotlin.resolve.descriptorUtil
 
-import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
 import org.jetbrains.kotlin.descriptors.annotations.Annotated
 import org.jetbrains.kotlin.name.FqName
 
-private val HIDDEN_ANNOTATION_FQ_NAME = FqName(""kotlin.HiddenDeclaration"")
-
-public fun DeclarationDescriptor.isAnnotatedAsHidden(): Boolean = annotations.findAnnotation(HIDDEN_ANNOTATION_FQ_NAME) != null
-
 private val NO_INFER_ANNOTATION_FQ_NAME = FqName(""kotlin.NoInfer"")","I think this whole file should be moved to `frontend`...
",Why did you remove this?
666,"@@ -16,18 +16,25 @@
 
 package kotlin.script.templates.standard
 
+// discuss
+//
+// These are some 'basic' script templates
+// Should we keep them here?","I think we should do the following with these:
* `SimpleScriptTemplate` -> remove (script with args can be always used instead of it)
* `kotlin.script.templates.standard.ScriptTemplateWithArgs` -> rename and move to `kotlin.script.templates.StandardScriptTemplate`
* `kotlin.script.templates.standard.ScriptTemplateWithBindings` -> move to `kotlin.script.templates.ScriptTemplateWithBindings`",I don't think we need to keep them here.
667,"@@ -16,26 +16,66 @@
 
 package kotlin
 
+/**
+ * An iterator over a collection. Allows to sequentially access the elements in a collection.","Not necessary ""in a collection"". 
",
668,"@@ -16,26 +16,66 @@
 
 package kotlin
 
+/**
+ * An iterator over a collection. Allows to sequentially access the elements in a collection.
+ */
 public trait Iterator<out T> {
+    /**
+     * Returns the next element in the iteration.
+     */
     public fun next(): T
+
+    /**
+     * Returns `true` if the iteration has more elements.
+     */
     public fun hasNext(): Boolean
 }
 
+/**
+ * An iterator over a mutable collection. Provides the ability to remove elements while iterating.
+ * @see MutableCollection.iterator
+ */
 public trait MutableIterator<out T> : Iterator<T> {
+    /**
+     * Removes from the underlying collection the last element returned by this iterator.
+     */
     public fun remove(): Unit
 }
 
+/**
+ * An iterator over a collection that supports indexed access.
+ * @see List.listIterator
+ */
 public trait ListIterator<out T> : Iterator<T> {
     // Query Operations
     override fun next(): T","Do we need overrides here?
",I think this should be `@see MutableCollection.iterator`.
669,"@@ -16,29 +16,26 @@
 
 package org.jetbrains.kotlin.idea.codeInsight.surroundWith
 
-import com.intellij.openapi.project.Project
 import com.intellij.psi.PsiElement
 import com.intellij.psi.PsiReference
 import com.intellij.psi.search.LocalSearchScope
 import com.intellij.psi.search.SearchScope
 import com.intellij.psi.search.searches.ReferencesSearch
 import com.intellij.psi.util.PsiUtilCore
-import org.jetbrains.kotlin.descriptors.VariableDescriptor
-import org.jetbrains.kotlin.idea.caches.resolve.*
+import org.jetbrains.kotlin.idea.caches.resolve.analyze
 import org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils
-import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
 import org.jetbrains.kotlin.idea.core.ShortenReferences
+import org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers
 import org.jetbrains.kotlin.psi.*
 import org.jetbrains.kotlin.resolve.BindingContext
 import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
 import org.jetbrains.kotlin.types.KotlinType
-
-import java.util.ArrayList
+import java.util.*
 
 object MoveDeclarationsOutHelper {","This `object` serves no purpose; the contents of the file should simply be top-level functions
",Please don't use wildcard imports.
670,"@@ -16,40 +16,112 @@
 
 package kotlin
 
+/**
+ * Classes that inherit from this trait can be represented as a sequence of elements that can
+ * be iterated over.
+ */
 public trait Iterable<out T> {","doc for `T`?
",I don't think we need this.
671,"@@ -16,6 +16,11 @@
 
 package kotlin.script.extensions
 
+// discuss
+
+// Is this an appropriate place to put this class?","This doesn't look like an appropriate place. If I understand correctly, it has nothing to do with scripts, so putting it into package `kotlin.script.extensions` is risky. As soon as we decide to publish it as a supported compiler plugin, we'll have to move it to another package and artifact, causing incompatibilities, so maybe it'd be better to do this earlier.",I don't think this is the right place to put this class.
672,"@@ -16,8 +16,18 @@
 
 package kotlin
 
+/**
+ * Annotates the parameter of a function annotates as [inline] and forbids inlining of","Typo: ""annotates as [inline]"" -> ""annotated as [inline]""
",nit: typo `forbids`
673,"@@ -16,8 +16,18 @@
 
 package kotlin
 
+/**
+ * Annotates the parameter of a function annotates as [inline] and forbids inlining of
+ * function literals passed as arguments for this parameter.
+ */
 public annotation class noinline
 
+/**","Add cross-reference to other annotations, like `noinline`
",nit: typo `forbids`
674,"@@ -161,6 +162,13 @@ object KotlinToJVMBytecodeCompiler {
                 ProgressIndicatorAndCompilationCanceledStatus.checkCanceled()
                 writeOutput(state.configuration, state.factory, null)
             }
+
+            if (chunk.size == 1 && projectConfiguration.getBoolean(JVMConfigurationKeys.USE_JAVAC)) {","If the chunk contains multiple modules and `-Xuse-javac` has been specified, maybe we should report a warning saying that we won't in fact use javac for compilation",I don't think this 
675,"@@ -161,6 +162,14 @@ object KotlinToJVMBytecodeCompiler {
                 ProgressIndicatorAndCompilationCanceledStatus.checkCanceled()
                 writeOutput(state.configuration, state.factory, null)
             }
+
+            if (chunk.size == 1) {
+                val javacWrapper = JavacWrapper.getInstance(environment.project)
+                if (projectConfiguration[JVMConfigurationKeys.USE_JAVAC]!!) {",@baratynskiy Please use `getBoolean(...)` instead of `get(...)!!`,Why do we need this
676,"@@ -162,4 +162,8 @@ change.function.signature.family=Change function signature
 change.function.signature.chooser.title=Choose signature
 change.function.signature.action=Change function signature
 remove.unnecessary.parentheses=Remove unnecessary parentheses
-remove.unnecessary.parentheses.family=Remove Unnecessary Parentheses
\ No newline at end of file
+remove.unnecessary.parentheses.family=Remove Unnecessary Parentheses
+add.function.to.supertype.family=Add Function to Supertype","While I know it's technically not 100% correct and maybe ""Add Function to _Superclassifier_"" would be a more accurate name for this quickfix I still want to stick with the name ""Add Function to Supertype"". In my opinion the user would be confused by using word ""superclassifier"". I can change the name though if you disagree. 
",This should be `Add
677,"@@ -1629,70 +1629,70 @@ public fun <T> Stream<T>.lastIndexOf(element: T): Int {
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun <T> Array<out T>.lastOrNull(): T? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun BooleanArray.lastOrNull(): Boolean? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun ByteArray.lastOrNull(): Byte? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun CharArray.lastOrNull(): Char? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun DoubleArray.lastOrNull(): Double? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun FloatArray.lastOrNull(): Float? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun IntArray.lastOrNull(): Int? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty
  */
 public fun LongArray.lastOrNull(): Long? {
     return if (isEmpty()) null else this[size() - 1]
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last element, or null if the collection is empty","Back-tick quote ""null""?
",I don't think this 
678,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {","It seems more like just ""createIncrementalCache""
",I'm not sure if thi
679,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =","1. Formatting is unusual to our codebase (surrounding ""->"" with spaces).
2. logAction is the same for both call-sites
3. filesFiler is almost the same for call-sites. Could be replaced with excludedFiles: Set<File>
",I'm not sure if thi
680,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {","I don't think these lookups can useful: 
- for JPS a processing of removed classes is done in `clearCacheForRemovedClasses`; that method uses proto from caches for dirty fqnames;
- current implementation can only return lookups of classes.

So I suggest to remove this function.
",I'm not sure if thi
681,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            return if (removedKotlinFiles.isNotEmpty())
+                targets.flatMap { getIncrementalCache(it).classesBySources(removedKotlinFiles).map { LookupSymbol(it.fqNameForClassNameWithoutDollars.shortName().toString(), it.packageFqName.toString()) } }
+            else listOf()
+        }
+
+        fun dirtyLookupSymbolsFromModifiedJavaFiles(): List<LookupSymbol> {
+            val modifiedJavaFiles = modified.filter { it.isJavaFile() }
+            return (if (modifiedJavaFiles.any()) {
+                val rootDisposable = Disposer.newDisposable()
+                val configuration = CompilerConfiguration()
+                val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
+                val project = environment.project
+                val psiFileFactory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl
+                modifiedJavaFiles.flatMap {
+                    val javaFile = psiFileFactory.createFileFromText(it.nameWithoutExtension, Language.findLanguageByID(""JAVA"")!!, it.readText())
+                    if (javaFile is PsiJavaFile)
+                        javaFile.classes.flatMap { it.findLookupSymbols() }
+                    else listOf()
+                }
+            } else listOf())
+        }
+
+        fun dirtyKotlinSourcesFromGradle(): List<File> {
+            // TODO: handle classpath changes similarly - compare with cashed version (likely a big change, may be costly, some heuristics could be considered)
+            val modifiedKotlinFiles = modified.filter { it.isKotlinFile() }
+            val lookupSymbols =
+                    dirtyLookupSymbolsFromModifiedJavaFiles() +
+                    dirtyLookupSymbolsFromRemovedKotlinFiles()
+                    // TODO: add dirty lookups from modified kotlin files to reduce number of steps needed
+
+            if (lookupSymbols.any()) {
+                val kotlinModifiedFilesSet = modifiedKotlinFiles.toHashSet()
+                return modifiedKotlinFiles +
+                        lookupSymbols.files(
+                                filesFilter = { it !in kotlinModifiedFilesSet },
+                                logAction = { lookup, files ->
+                                    logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                                })
+            }
+            return modifiedKotlinFiles
+        }
+
+        fun isClassPathChanged(): Boolean {
+            // TODO: that doesn't look to wise - join it first and then split here, consider storing it somewhere in between
+            val classpath = args.classpath.split(File.pathSeparator).map { File(it) }.toHashSet()
+            val changedClasspath = modified.filter { classpath.contains(it) }
+            return changedClasspath.any()
+        }
+
+        fun allCachesVersions() = allCachesVersions(cachesBaseDir, listOf(cachesBaseDir))
+
+        fun calculateSourcesToCompile(): Pair<List<File>, Boolean> {
+
+            if (!experimentalIncremental ||
+                    !isIncrementalRequested ||
+                    // TODO: more precise will be not to rebuild unconditionally on classpath changes, but retrieve lookup info and try to find out which sources are affected by cp changes
+                    isClassPathChanged() ||
+                    // so far considering it not incremental TODO: store java files in the cache and extract removed symbols from it here
+                    removed.any { it.isJavaFile() }
+            ) {
+                logger.kotlinInfo(if (!isIncrementalRequested) ""clean caches on rebuild"" else ""classpath changed, rebuilding all kotlin files"")
+                targets.forEach { getIncrementalCache(it).clean() }
+                lookupStorage.clean()
+                return Pair(sources, false)
+            }
+            val actions = if (isIncrementalRequested) allCachesVersions().map { it.checkVersion() }
+                          else listOf(CacheVersion.Action.REBUILD_ALL_KOTLIN)
+            // TODO: find out whether these flags should be emulated too
+//            val hasKotlin = HasKotlinMarker(dataManager)
+//            val rebuildAfterCacheVersionChanged = RebuildAfterCacheVersionChangeMarker(dataManager)
+
+            for (status in actions.distinct().sorted()) {
+                when (status) {
+                    CacheVersion.Action.REBUILD_ALL_KOTLIN -> {
+                        logger.kotlinInfo(""Kotlin global lookup map format changed, rebuilding all kotlin files"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                        lookupStorage.clean()
+                        return Pair(sources, false)
+                    }
+                    CacheVersion.Action.REBUILD_CHUNK -> {
+                        logger.kotlinInfo(""Clearing caches for "" + targets.joinToString { it.name })
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_NORMAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_EXPERIMENTAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing experimental caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).cleanExperimental() }
+                    }
+                    CacheVersion.Action.CLEAN_DATA_CONTAINER -> {
+                        logger.kotlinInfo(""Clearing lookup cache"")
+                        lookupStorage.clean()
+                        dataContainerCacheVersion(cachesBaseDir).clean()
+                    }
+                    else -> {
+                        assert(status == CacheVersion.Action.DO_NOTHING) { ""Unknown version status $status"" }
+                    }
+                }
+            }
+            val dirtyFiles = dirtyKotlinSourcesFromGradle().distinct()
+            // first dirty files should be found and only then caches cleared
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            targets.forEach { getIncrementalCache(it).let {
+                it.markOutputClassesDirty(removedKotlinFiles)
+                it.removeClassfilesBySources(removedKotlinFiles)
+            }}
+            return Pair(dirtyFiles, true)
+        }
+
+        fun cleanupOnError() {
+            val outputDirFile = File(args.destination!!)
+
+            assert(outputDirFile.exists())
+            val generatedRelPaths = allGeneratedFiles.map { it.outputFile.toRelativeString(outputDirFile) }
+            logger.kotlinInfo(""deleting output on error: ${generatedRelPaths.joinToString()}"")
+
+            allGeneratedFiles.forEach { it.outputFile.delete() }
+            generatedRelPaths.forEach { File(destinationDir, it).delete() }
+        }
+
+        fun processCompilerExitCode(exitCode: ExitCode) {
+            if (exitCode != ExitCode.OK) {
+                cleanupOnError()
+            }
+            when (exitCode) {
+                ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
+                ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
+                ExitCode.SCRIPT_EXECUTION_ERROR -> throw GradleException(""Script execution error. See log for more details"")
+                ExitCode.OK -> logger.kotlinInfo(""Compilation succeeded"")
+            }
+        }
+
+        fun outputRelativePath(f: File) = f.toRelativeString(outputDir)
+
+
+        if (!experimentalIncremental) {
+            anyClassesCompiled = true
+            processCompilerExitCode(compileNotIncremental(sources, outputDir, args))
+            return
+        }
+        logger.warn(""Using experimental kotlin incremental compilation"")
+
+        anyClassesCompiled = false
+
+        // TODO: decide what to do if no files are considered dirty - rebuild or skip the module
+        var (sourcesToCompile, isIncrementalDecided) = calculateSourcesToCompile()
+
+        if (isIncrementalDecided) {
+            // TODO: process as list here, merge into string later
+            args.classpath = args.classpath + File.pathSeparator + outputDir.absolutePath
+        }
+
+        while (sourcesToCompile.any()) {
+            logger.kotlinInfo(""compile iteration: ${sourcesToCompile.joinToString{ projectRelativePath(it) }}"")
+
+            val (exitCode, generatedFiles) = compileChanged(","What's the point in using named arguments here?
",I'm not sure if thi
682,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            return if (removedKotlinFiles.isNotEmpty())
+                targets.flatMap { getIncrementalCache(it).classesBySources(removedKotlinFiles).map { LookupSymbol(it.fqNameForClassNameWithoutDollars.shortName().toString(), it.packageFqName.toString()) } }
+            else listOf()
+        }
+
+        fun dirtyLookupSymbolsFromModifiedJavaFiles(): List<LookupSymbol> {
+            val modifiedJavaFiles = modified.filter { it.isJavaFile() }
+            return (if (modifiedJavaFiles.any()) {
+                val rootDisposable = Disposer.newDisposable()
+                val configuration = CompilerConfiguration()
+                val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
+                val project = environment.project
+                val psiFileFactory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl
+                modifiedJavaFiles.flatMap {
+                    val javaFile = psiFileFactory.createFileFromText(it.nameWithoutExtension, Language.findLanguageByID(""JAVA"")!!, it.readText())
+                    if (javaFile is PsiJavaFile)
+                        javaFile.classes.flatMap { it.findLookupSymbols() }
+                    else listOf()
+                }
+            } else listOf())
+        }
+
+        fun dirtyKotlinSourcesFromGradle(): List<File> {
+            // TODO: handle classpath changes similarly - compare with cashed version (likely a big change, may be costly, some heuristics could be considered)
+            val modifiedKotlinFiles = modified.filter { it.isKotlinFile() }
+            val lookupSymbols =
+                    dirtyLookupSymbolsFromModifiedJavaFiles() +
+                    dirtyLookupSymbolsFromRemovedKotlinFiles()
+                    // TODO: add dirty lookups from modified kotlin files to reduce number of steps needed
+
+            if (lookupSymbols.any()) {
+                val kotlinModifiedFilesSet = modifiedKotlinFiles.toHashSet()
+                return modifiedKotlinFiles +
+                        lookupSymbols.files(
+                                filesFilter = { it !in kotlinModifiedFilesSet },
+                                logAction = { lookup, files ->
+                                    logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                                })
+            }
+            return modifiedKotlinFiles
+        }
+
+        fun isClassPathChanged(): Boolean {
+            // TODO: that doesn't look to wise - join it first and then split here, consider storing it somewhere in between
+            val classpath = args.classpath.split(File.pathSeparator).map { File(it) }.toHashSet()
+            val changedClasspath = modified.filter { classpath.contains(it) }
+            return changedClasspath.any()
+        }
+
+        fun allCachesVersions() = allCachesVersions(cachesBaseDir, listOf(cachesBaseDir))
+
+        fun calculateSourcesToCompile(): Pair<List<File>, Boolean> {
+
+            if (!experimentalIncremental ||
+                    !isIncrementalRequested ||
+                    // TODO: more precise will be not to rebuild unconditionally on classpath changes, but retrieve lookup info and try to find out which sources are affected by cp changes
+                    isClassPathChanged() ||
+                    // so far considering it not incremental TODO: store java files in the cache and extract removed symbols from it here
+                    removed.any { it.isJavaFile() }
+            ) {
+                logger.kotlinInfo(if (!isIncrementalRequested) ""clean caches on rebuild"" else ""classpath changed, rebuilding all kotlin files"")
+                targets.forEach { getIncrementalCache(it).clean() }
+                lookupStorage.clean()
+                return Pair(sources, false)
+            }
+            val actions = if (isIncrementalRequested) allCachesVersions().map { it.checkVersion() }
+                          else listOf(CacheVersion.Action.REBUILD_ALL_KOTLIN)
+            // TODO: find out whether these flags should be emulated too
+//            val hasKotlin = HasKotlinMarker(dataManager)
+//            val rebuildAfterCacheVersionChanged = RebuildAfterCacheVersionChangeMarker(dataManager)
+
+            for (status in actions.distinct().sorted()) {
+                when (status) {
+                    CacheVersion.Action.REBUILD_ALL_KOTLIN -> {
+                        logger.kotlinInfo(""Kotlin global lookup map format changed, rebuilding all kotlin files"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                        lookupStorage.clean()
+                        return Pair(sources, false)
+                    }
+                    CacheVersion.Action.REBUILD_CHUNK -> {
+                        logger.kotlinInfo(""Clearing caches for "" + targets.joinToString { it.name })
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_NORMAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_EXPERIMENTAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing experimental caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).cleanExperimental() }
+                    }
+                    CacheVersion.Action.CLEAN_DATA_CONTAINER -> {
+                        logger.kotlinInfo(""Clearing lookup cache"")
+                        lookupStorage.clean()
+                        dataContainerCacheVersion(cachesBaseDir).clean()
+                    }
+                    else -> {
+                        assert(status == CacheVersion.Action.DO_NOTHING) { ""Unknown version status $status"" }
+                    }
+                }
+            }
+            val dirtyFiles = dirtyKotlinSourcesFromGradle().distinct()
+            // first dirty files should be found and only then caches cleared
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            targets.forEach { getIncrementalCache(it).let {
+                it.markOutputClassesDirty(removedKotlinFiles)
+                it.removeClassfilesBySources(removedKotlinFiles)
+            }}
+            return Pair(dirtyFiles, true)
+        }
+
+        fun cleanupOnError() {
+            val outputDirFile = File(args.destination!!)
+
+            assert(outputDirFile.exists())
+            val generatedRelPaths = allGeneratedFiles.map { it.outputFile.toRelativeString(outputDirFile) }
+            logger.kotlinInfo(""deleting output on error: ${generatedRelPaths.joinToString()}"")
+
+            allGeneratedFiles.forEach { it.outputFile.delete() }
+            generatedRelPaths.forEach { File(destinationDir, it).delete() }
+        }
+
+        fun processCompilerExitCode(exitCode: ExitCode) {
+            if (exitCode != ExitCode.OK) {
+                cleanupOnError()
+            }
+            when (exitCode) {
+                ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
+                ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
+                ExitCode.SCRIPT_EXECUTION_ERROR -> throw GradleException(""Script execution error. See log for more details"")
+                ExitCode.OK -> logger.kotlinInfo(""Compilation succeeded"")
+            }
+        }
+
+        fun outputRelativePath(f: File) = f.toRelativeString(outputDir)
+
+
+        if (!experimentalIncremental) {
+            anyClassesCompiled = true
+            processCompilerExitCode(compileNotIncremental(sources, outputDir, args))
+            return
+        }
+        logger.warn(""Using experimental kotlin incremental compilation"")
+
+        anyClassesCompiled = false
+
+        // TODO: decide what to do if no files are considered dirty - rebuild or skip the module
+        var (sourcesToCompile, isIncrementalDecided) = calculateSourcesToCompile()
+
+        if (isIncrementalDecided) {
+            // TODO: process as list here, merge into string later
+            args.classpath = args.classpath + File.pathSeparator + outputDir.absolutePath
+        }
+
+        while (sourcesToCompile.any()) {
+            logger.kotlinInfo(""compile iteration: ${sourcesToCompile.joinToString{ projectRelativePath(it) }}"")
+
+            val (exitCode, generatedFiles) = compileChanged(
+                    targets = targets,
+                    sourcesToCompile = sourcesToCompile,
+                    outputDir = outputDir,
+                    args = args,
+                    getIncrementalCache = ::getIncrementalCache,
+                    lookupTracker = lookupTracker)
+
+            allGeneratedFiles.addAll(generatedFiles)
+            // save versions?
+
+            val changes = updateIncrementalCaches(
+                    targets = targets,
+                    generatedFiles = generatedFiles,
+                    compiledWithErrors = exitCode != ExitCode.OK,
+                    getIncrementalCache = { caches[it]!! })
+
+//            lookupTracker.lookups.entrySet().forEach {
+//                logger.kotlinDebug(""lookups to ${it.key.name}:${it.key.scope} from ${it.value.joinToString { projectRelativePath(it) }}"")
+//            }
+
+            lookupStorage.update(lookupTracker, sourcesToCompile, currentRemoved)
+
+            allCachesVersions().forEach { it.saveIfNeeded() }","I believe saving versions should be after the loop.
",I'm not sure if thi
683,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            return if (removedKotlinFiles.isNotEmpty())
+                targets.flatMap { getIncrementalCache(it).classesBySources(removedKotlinFiles).map { LookupSymbol(it.fqNameForClassNameWithoutDollars.shortName().toString(), it.packageFqName.toString()) } }
+            else listOf()
+        }
+
+        fun dirtyLookupSymbolsFromModifiedJavaFiles(): List<LookupSymbol> {
+            val modifiedJavaFiles = modified.filter { it.isJavaFile() }
+            return (if (modifiedJavaFiles.any()) {
+                val rootDisposable = Disposer.newDisposable()
+                val configuration = CompilerConfiguration()
+                val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
+                val project = environment.project
+                val psiFileFactory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl
+                modifiedJavaFiles.flatMap {
+                    val javaFile = psiFileFactory.createFileFromText(it.nameWithoutExtension, Language.findLanguageByID(""JAVA"")!!, it.readText())
+                    if (javaFile is PsiJavaFile)
+                        javaFile.classes.flatMap { it.findLookupSymbols() }
+                    else listOf()
+                }
+            } else listOf())
+        }
+
+        fun dirtyKotlinSourcesFromGradle(): List<File> {
+            // TODO: handle classpath changes similarly - compare with cashed version (likely a big change, may be costly, some heuristics could be considered)
+            val modifiedKotlinFiles = modified.filter { it.isKotlinFile() }
+            val lookupSymbols =
+                    dirtyLookupSymbolsFromModifiedJavaFiles() +
+                    dirtyLookupSymbolsFromRemovedKotlinFiles()
+                    // TODO: add dirty lookups from modified kotlin files to reduce number of steps needed
+
+            if (lookupSymbols.any()) {
+                val kotlinModifiedFilesSet = modifiedKotlinFiles.toHashSet()
+                return modifiedKotlinFiles +
+                        lookupSymbols.files(
+                                filesFilter = { it !in kotlinModifiedFilesSet },
+                                logAction = { lookup, files ->
+                                    logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                                })
+            }
+            return modifiedKotlinFiles
+        }
+
+        fun isClassPathChanged(): Boolean {
+            // TODO: that doesn't look to wise - join it first and then split here, consider storing it somewhere in between
+            val classpath = args.classpath.split(File.pathSeparator).map { File(it) }.toHashSet()
+            val changedClasspath = modified.filter { classpath.contains(it) }
+            return changedClasspath.any()
+        }
+
+        fun allCachesVersions() = allCachesVersions(cachesBaseDir, listOf(cachesBaseDir))
+
+        fun calculateSourcesToCompile(): Pair<List<File>, Boolean> {
+
+            if (!experimentalIncremental ||
+                    !isIncrementalRequested ||
+                    // TODO: more precise will be not to rebuild unconditionally on classpath changes, but retrieve lookup info and try to find out which sources are affected by cp changes
+                    isClassPathChanged() ||
+                    // so far considering it not incremental TODO: store java files in the cache and extract removed symbols from it here
+                    removed.any { it.isJavaFile() }
+            ) {
+                logger.kotlinInfo(if (!isIncrementalRequested) ""clean caches on rebuild"" else ""classpath changed, rebuilding all kotlin files"")
+                targets.forEach { getIncrementalCache(it).clean() }
+                lookupStorage.clean()
+                return Pair(sources, false)
+            }
+            val actions = if (isIncrementalRequested) allCachesVersions().map { it.checkVersion() }
+                          else listOf(CacheVersion.Action.REBUILD_ALL_KOTLIN)
+            // TODO: find out whether these flags should be emulated too
+//            val hasKotlin = HasKotlinMarker(dataManager)
+//            val rebuildAfterCacheVersionChanged = RebuildAfterCacheVersionChangeMarker(dataManager)
+
+            for (status in actions.distinct().sorted()) {
+                when (status) {
+                    CacheVersion.Action.REBUILD_ALL_KOTLIN -> {
+                        logger.kotlinInfo(""Kotlin global lookup map format changed, rebuilding all kotlin files"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                        lookupStorage.clean()
+                        return Pair(sources, false)
+                    }
+                    CacheVersion.Action.REBUILD_CHUNK -> {
+                        logger.kotlinInfo(""Clearing caches for "" + targets.joinToString { it.name })
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_NORMAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_EXPERIMENTAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing experimental caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).cleanExperimental() }
+                    }
+                    CacheVersion.Action.CLEAN_DATA_CONTAINER -> {
+                        logger.kotlinInfo(""Clearing lookup cache"")
+                        lookupStorage.clean()
+                        dataContainerCacheVersion(cachesBaseDir).clean()
+                    }
+                    else -> {
+                        assert(status == CacheVersion.Action.DO_NOTHING) { ""Unknown version status $status"" }
+                    }
+                }
+            }
+            val dirtyFiles = dirtyKotlinSourcesFromGradle().distinct()
+            // first dirty files should be found and only then caches cleared
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            targets.forEach { getIncrementalCache(it).let {
+                it.markOutputClassesDirty(removedKotlinFiles)
+                it.removeClassfilesBySources(removedKotlinFiles)
+            }}
+            return Pair(dirtyFiles, true)
+        }
+
+        fun cleanupOnError() {
+            val outputDirFile = File(args.destination!!)
+
+            assert(outputDirFile.exists())
+            val generatedRelPaths = allGeneratedFiles.map { it.outputFile.toRelativeString(outputDirFile) }
+            logger.kotlinInfo(""deleting output on error: ${generatedRelPaths.joinToString()}"")
+
+            allGeneratedFiles.forEach { it.outputFile.delete() }
+            generatedRelPaths.forEach { File(destinationDir, it).delete() }
+        }
+
+        fun processCompilerExitCode(exitCode: ExitCode) {
+            if (exitCode != ExitCode.OK) {
+                cleanupOnError()
+            }
+            when (exitCode) {
+                ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
+                ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
+                ExitCode.SCRIPT_EXECUTION_ERROR -> throw GradleException(""Script execution error. See log for more details"")
+                ExitCode.OK -> logger.kotlinInfo(""Compilation succeeded"")
+            }
+        }
+
+        fun outputRelativePath(f: File) = f.toRelativeString(outputDir)
+
+
+        if (!experimentalIncremental) {
+            anyClassesCompiled = true
+            processCompilerExitCode(compileNotIncremental(sources, outputDir, args))
+            return
+        }
+        logger.warn(""Using experimental kotlin incremental compilation"")
+
+        anyClassesCompiled = false
+
+        // TODO: decide what to do if no files are considered dirty - rebuild or skip the module
+        var (sourcesToCompile, isIncrementalDecided) = calculateSourcesToCompile()
+
+        if (isIncrementalDecided) {
+            // TODO: process as list here, merge into string later
+            args.classpath = args.classpath + File.pathSeparator + outputDir.absolutePath
+        }
+
+        while (sourcesToCompile.any()) {
+            logger.kotlinInfo(""compile iteration: ${sourcesToCompile.joinToString{ projectRelativePath(it) }}"")
+
+            val (exitCode, generatedFiles) = compileChanged(
+                    targets = targets,
+                    sourcesToCompile = sourcesToCompile,
+                    outputDir = outputDir,
+                    args = args,
+                    getIncrementalCache = ::getIncrementalCache,
+                    lookupTracker = lookupTracker)
+
+            allGeneratedFiles.addAll(generatedFiles)
+            // save versions?
+
+            val changes = updateIncrementalCaches(
+                    targets = targets,
+                    generatedFiles = generatedFiles,
+                    compiledWithErrors = exitCode != ExitCode.OK,
+                    getIncrementalCache = { caches[it]!! })
+
+//            lookupTracker.lookups.entrySet().forEach {
+//                logger.kotlinDebug(""lookups to ${it.key.name}:${it.key.scope} from ${it.value.joinToString { projectRelativePath(it) }}"")
+//            }
+
+            lookupStorage.update(lookupTracker, sourcesToCompile, currentRemoved)
+
+            allCachesVersions().forEach { it.saveIfNeeded() }
+
+            processCompilerExitCode(exitCode)
+
+            if (!isIncrementalDecided) break;
+
+//            logger.kotlinDebug(""generated ${generatedFiles.joinToString { outputRelativePath(it.outputFile) }}"")
+//            logger.kotlinDebug(""changes: ${changes.changes.joinToString { ""${it.fqName}: ${it.javaClass.simpleName}"" }}"")
+//
+//            logger.kotlinLazyDebug({
+//                ""known lookups:\n${lookupStorage.dump(changes.changes.flatMap {
+//                    change ->
+//                        if (change is ChangeInfo.MembersChanged)
+//                            change.names.asSequence().map { LookupSymbol(it, change.fqName.asString()) }
+//                        else
+//                            sequenceOf<LookupSymbol>()
+//                }.toSet(), project.projectDir)}"" })
+
+            compiledSourcesSet.addAll(sourcesToCompile)
+
+            val dirtyLookups = changes.dirtyLookups<TargetId>(caches.values.asSequence())
+
+//            logger.kotlinDebug(""dirty lookups: ${dirtyLookups.joinToString { ""${it.name}:${it.scope}"" }}"")
+
+            val dirty = dirtyLookups.files(
+                    filesFilter = { it !in compiledSourcesSet },
+                    logAction = { lookup, files ->
+                        logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                    })
+            sourcesToCompile = dirty.filter { it in sources }.toList()","Minor: `filter` returns list
",I'm not sure if thi
684,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            return if (removedKotlinFiles.isNotEmpty())
+                targets.flatMap { getIncrementalCache(it).classesBySources(removedKotlinFiles).map { LookupSymbol(it.fqNameForClassNameWithoutDollars.shortName().toString(), it.packageFqName.toString()) } }
+            else listOf()
+        }
+
+        fun dirtyLookupSymbolsFromModifiedJavaFiles(): List<LookupSymbol> {
+            val modifiedJavaFiles = modified.filter { it.isJavaFile() }
+            return (if (modifiedJavaFiles.any()) {
+                val rootDisposable = Disposer.newDisposable()
+                val configuration = CompilerConfiguration()
+                val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
+                val project = environment.project
+                val psiFileFactory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl
+                modifiedJavaFiles.flatMap {
+                    val javaFile = psiFileFactory.createFileFromText(it.nameWithoutExtension, Language.findLanguageByID(""JAVA"")!!, it.readText())
+                    if (javaFile is PsiJavaFile)
+                        javaFile.classes.flatMap { it.findLookupSymbols() }
+                    else listOf()
+                }
+            } else listOf())
+        }
+
+        fun dirtyKotlinSourcesFromGradle(): List<File> {
+            // TODO: handle classpath changes similarly - compare with cashed version (likely a big change, may be costly, some heuristics could be considered)
+            val modifiedKotlinFiles = modified.filter { it.isKotlinFile() }
+            val lookupSymbols =
+                    dirtyLookupSymbolsFromModifiedJavaFiles() +
+                    dirtyLookupSymbolsFromRemovedKotlinFiles()
+                    // TODO: add dirty lookups from modified kotlin files to reduce number of steps needed
+
+            if (lookupSymbols.any()) {
+                val kotlinModifiedFilesSet = modifiedKotlinFiles.toHashSet()
+                return modifiedKotlinFiles +
+                        lookupSymbols.files(
+                                filesFilter = { it !in kotlinModifiedFilesSet },
+                                logAction = { lookup, files ->
+                                    logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                                })
+            }
+            return modifiedKotlinFiles
+        }
+
+        fun isClassPathChanged(): Boolean {
+            // TODO: that doesn't look to wise - join it first and then split here, consider storing it somewhere in between
+            val classpath = args.classpath.split(File.pathSeparator).map { File(it) }.toHashSet()
+            val changedClasspath = modified.filter { classpath.contains(it) }
+            return changedClasspath.any()
+        }
+
+        fun allCachesVersions() = allCachesVersions(cachesBaseDir, listOf(cachesBaseDir))
+
+        fun calculateSourcesToCompile(): Pair<List<File>, Boolean> {
+
+            if (!experimentalIncremental ||
+                    !isIncrementalRequested ||
+                    // TODO: more precise will be not to rebuild unconditionally on classpath changes, but retrieve lookup info and try to find out which sources are affected by cp changes
+                    isClassPathChanged() ||
+                    // so far considering it not incremental TODO: store java files in the cache and extract removed symbols from it here
+                    removed.any { it.isJavaFile() }
+            ) {
+                logger.kotlinInfo(if (!isIncrementalRequested) ""clean caches on rebuild"" else ""classpath changed, rebuilding all kotlin files"")
+                targets.forEach { getIncrementalCache(it).clean() }
+                lookupStorage.clean()
+                return Pair(sources, false)
+            }
+            val actions = if (isIncrementalRequested) allCachesVersions().map { it.checkVersion() }
+                          else listOf(CacheVersion.Action.REBUILD_ALL_KOTLIN)
+            // TODO: find out whether these flags should be emulated too
+//            val hasKotlin = HasKotlinMarker(dataManager)
+//            val rebuildAfterCacheVersionChanged = RebuildAfterCacheVersionChangeMarker(dataManager)
+
+            for (status in actions.distinct().sorted()) {
+                when (status) {
+                    CacheVersion.Action.REBUILD_ALL_KOTLIN -> {
+                        logger.kotlinInfo(""Kotlin global lookup map format changed, rebuilding all kotlin files"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                        lookupStorage.clean()
+                        return Pair(sources, false)
+                    }
+                    CacheVersion.Action.REBUILD_CHUNK -> {
+                        logger.kotlinInfo(""Clearing caches for "" + targets.joinToString { it.name })
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_NORMAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_EXPERIMENTAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing experimental caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).cleanExperimental() }
+                    }
+                    CacheVersion.Action.CLEAN_DATA_CONTAINER -> {
+                        logger.kotlinInfo(""Clearing lookup cache"")
+                        lookupStorage.clean()
+                        dataContainerCacheVersion(cachesBaseDir).clean()
+                    }
+                    else -> {
+                        assert(status == CacheVersion.Action.DO_NOTHING) { ""Unknown version status $status"" }
+                    }
+                }
+            }
+            val dirtyFiles = dirtyKotlinSourcesFromGradle().distinct()
+            // first dirty files should be found and only then caches cleared
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            targets.forEach { getIncrementalCache(it).let {
+                it.markOutputClassesDirty(removedKotlinFiles)
+                it.removeClassfilesBySources(removedKotlinFiles)
+            }}
+            return Pair(dirtyFiles, true)
+        }
+
+        fun cleanupOnError() {
+            val outputDirFile = File(args.destination!!)
+
+            assert(outputDirFile.exists())
+            val generatedRelPaths = allGeneratedFiles.map { it.outputFile.toRelativeString(outputDirFile) }
+            logger.kotlinInfo(""deleting output on error: ${generatedRelPaths.joinToString()}"")
+
+            allGeneratedFiles.forEach { it.outputFile.delete() }
+            generatedRelPaths.forEach { File(destinationDir, it).delete() }
+        }
+
+        fun processCompilerExitCode(exitCode: ExitCode) {
+            if (exitCode != ExitCode.OK) {
+                cleanupOnError()
+            }
+            when (exitCode) {
+                ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
+                ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
+                ExitCode.SCRIPT_EXECUTION_ERROR -> throw GradleException(""Script execution error. See log for more details"")
+                ExitCode.OK -> logger.kotlinInfo(""Compilation succeeded"")
+            }
+        }
+
+        fun outputRelativePath(f: File) = f.toRelativeString(outputDir)
+
+
+        if (!experimentalIncremental) {
+            anyClassesCompiled = true
+            processCompilerExitCode(compileNotIncremental(sources, outputDir, args))
+            return
+        }
+        logger.warn(""Using experimental kotlin incremental compilation"")
+
+        anyClassesCompiled = false
+
+        // TODO: decide what to do if no files are considered dirty - rebuild or skip the module
+        var (sourcesToCompile, isIncrementalDecided) = calculateSourcesToCompile()
+
+        if (isIncrementalDecided) {
+            // TODO: process as list here, merge into string later
+            args.classpath = args.classpath + File.pathSeparator + outputDir.absolutePath
+        }
+
+        while (sourcesToCompile.any()) {
+            logger.kotlinInfo(""compile iteration: ${sourcesToCompile.joinToString{ projectRelativePath(it) }}"")
+
+            val (exitCode, generatedFiles) = compileChanged(
+                    targets = targets,
+                    sourcesToCompile = sourcesToCompile,
+                    outputDir = outputDir,
+                    args = args,
+                    getIncrementalCache = ::getIncrementalCache,
+                    lookupTracker = lookupTracker)
+
+            allGeneratedFiles.addAll(generatedFiles)
+            // save versions?
+
+            val changes = updateIncrementalCaches(
+                    targets = targets,
+                    generatedFiles = generatedFiles,
+                    compiledWithErrors = exitCode != ExitCode.OK,
+                    getIncrementalCache = { caches[it]!! })
+
+//            lookupTracker.lookups.entrySet().forEach {
+//                logger.kotlinDebug(""lookups to ${it.key.name}:${it.key.scope} from ${it.value.joinToString { projectRelativePath(it) }}"")
+//            }
+
+            lookupStorage.update(lookupTracker, sourcesToCompile, currentRemoved)
+
+            allCachesVersions().forEach { it.saveIfNeeded() }
+
+            processCompilerExitCode(exitCode)
+
+            if (!isIncrementalDecided) break;
+
+//            logger.kotlinDebug(""generated ${generatedFiles.joinToString { outputRelativePath(it.outputFile) }}"")
+//            logger.kotlinDebug(""changes: ${changes.changes.joinToString { ""${it.fqName}: ${it.javaClass.simpleName}"" }}"")
+//
+//            logger.kotlinLazyDebug({
+//                ""known lookups:\n${lookupStorage.dump(changes.changes.flatMap {
+//                    change ->
+//                        if (change is ChangeInfo.MembersChanged)
+//                            change.names.asSequence().map { LookupSymbol(it, change.fqName.asString()) }
+//                        else
+//                            sequenceOf<LookupSymbol>()
+//                }.toSet(), project.projectDir)}"" })
+
+            compiledSourcesSet.addAll(sourcesToCompile)
+
+            val dirtyLookups = changes.dirtyLookups<TargetId>(caches.values.asSequence())
+
+//            logger.kotlinDebug(""dirty lookups: ${dirtyLookups.joinToString { ""${it.name}:${it.scope}"" }}"")
+
+            val dirty = dirtyLookups.files(
+                    filesFilter = { it !in compiledSourcesSet },
+                    logAction = { lookup, files ->
+                        logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                    })
+            sourcesToCompile = dirty.filter { it in sources }.toList()
+            if (currentRemoved.any()) {
+                currentRemoved = listOf()
+            }
+//            logger.kotlinDebug(""dirty: ${dirty.joinToString { projectRelativePath(it) }}"")
+//            logger.kotlinDebug(""to compile: ${sourcesToCompile.joinToString { projectRelativePath(it) }}"")
+        }
+        lookupStorage.flush(false)
+        lookupStorage.close()
+        caches.values.forEach { it.flush(false); it.close() }
+        if (allGeneratedFiles.isNotEmpty()) {
+            anyClassesCompiled = true
+        }
+    }
+
+    private data class CompileChangedResults(val exitCode: ExitCode, val generatedFiles: List<GeneratedFile<TargetId>>)
+
+    private fun compileChanged(targets: List<TargetId>,
+                               sourcesToCompile: List<File>,
+                               outputDir: File,
+                               args: K2JVMCompilerArguments,
+                               getIncrementalCache: (TargetId) -> GradleIncrementalCacheImpl,
+                               lookupTracker: LookupTracker)
+            : CompileChangedResults","Minor: formatting
",I'm not sure if thi
685,"@@ -163,16 +217,341 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
         logger.kotlinDebug(""args.moduleName = ${args.moduleName}"")
     }
 
+    override fun callCompiler(args: K2JVMCompilerArguments, sources: List<File>, isIncrementalRequested: Boolean, modified: List<File>, removed: List<File>, cachesBaseDir: File) {
+
+        if (experimentalIncremental) {
+            // TODO: consider other ways to pass incremental flag to compiler/builder
+            System.setProperty(""kotlin.incremental.compilation"", ""true"")
+            // TODO: experimental should be removed as soon as it becomes standard
+            System.setProperty(""kotlin.incremental.compilation.experimental"", ""true"")
+        }
+
+        val targetType = ""java-production""
+        val moduleName = args.moduleName
+        val targets = listOf(TargetId(moduleName, targetType))
+        val outputDir = File(args.destination)
+        val caches = hashMapOf<TargetId, GradleIncrementalCacheImpl>()
+        val lookupStorage = LookupStorage(File(cachesBaseDir, ""lookups""))
+        val lookupTracker = LookupTrackerImpl(LookupTracker.DO_NOTHING)
+        var currentRemoved = removed
+        val allGeneratedFiles = hashSetOf<GeneratedFile<TargetId>>()
+        val compiledSourcesSet = hashSetOf<File>()
+
+        fun getOrCreateIncrementalCache(target: TargetId): GradleIncrementalCacheImpl {
+            val cacheDir = File(cachesBaseDir, ""increCache.${target.name}"")
+            cacheDir.mkdirs()
+            return GradleIncrementalCacheImpl(targetDataRoot = cacheDir, targetOutputDir = outputDir, target = target)
+        }
+
+        fun getIncrementalCache(it: TargetId) = caches.getOrPut(it, { getOrCreateIncrementalCache(it) })
+
+        fun PsiClass.findLookupSymbols(): Iterable<LookupSymbol> {
+            val fqn = qualifiedName.orEmpty()
+            return listOf(LookupSymbol(name.orEmpty(), if (fqn == name) """" else fqn.removeSuffix(""."" + name!!))) +
+                    methods.map { LookupSymbol(it.name, fqn) } +
+                    fields.map { LookupSymbol(it.name.orEmpty(), fqn) } +
+                    innerClasses.flatMap { it.findLookupSymbols() }
+        }
+
+        fun Iterable<LookupSymbol>.files(filesFilter: (File) -> Boolean = { true }, logAction: (LookupSymbol, Iterable<File>) -> Unit = { l,fs -> }): Iterable<File> =
+            flatMap { lookup ->
+                val files = lookupStorage.get(lookup).map(::File).filter(filesFilter)
+                if (files.any()) {
+                    logAction(lookup, files)
+                }
+                files
+            }
+
+        fun dirtyLookupSymbolsFromRemovedKotlinFiles(): List<LookupSymbol> {
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            return if (removedKotlinFiles.isNotEmpty())
+                targets.flatMap { getIncrementalCache(it).classesBySources(removedKotlinFiles).map { LookupSymbol(it.fqNameForClassNameWithoutDollars.shortName().toString(), it.packageFqName.toString()) } }
+            else listOf()
+        }
+
+        fun dirtyLookupSymbolsFromModifiedJavaFiles(): List<LookupSymbol> {
+            val modifiedJavaFiles = modified.filter { it.isJavaFile() }
+            return (if (modifiedJavaFiles.any()) {
+                val rootDisposable = Disposer.newDisposable()
+                val configuration = CompilerConfiguration()
+                val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)
+                val project = environment.project
+                val psiFileFactory = PsiFileFactory.getInstance(project) as PsiFileFactoryImpl
+                modifiedJavaFiles.flatMap {
+                    val javaFile = psiFileFactory.createFileFromText(it.nameWithoutExtension, Language.findLanguageByID(""JAVA"")!!, it.readText())
+                    if (javaFile is PsiJavaFile)
+                        javaFile.classes.flatMap { it.findLookupSymbols() }
+                    else listOf()
+                }
+            } else listOf())
+        }
+
+        fun dirtyKotlinSourcesFromGradle(): List<File> {
+            // TODO: handle classpath changes similarly - compare with cashed version (likely a big change, may be costly, some heuristics could be considered)
+            val modifiedKotlinFiles = modified.filter { it.isKotlinFile() }
+            val lookupSymbols =
+                    dirtyLookupSymbolsFromModifiedJavaFiles() +
+                    dirtyLookupSymbolsFromRemovedKotlinFiles()
+                    // TODO: add dirty lookups from modified kotlin files to reduce number of steps needed
+
+            if (lookupSymbols.any()) {
+                val kotlinModifiedFilesSet = modifiedKotlinFiles.toHashSet()
+                return modifiedKotlinFiles +
+                        lookupSymbols.files(
+                                filesFilter = { it !in kotlinModifiedFilesSet },
+                                logAction = { lookup, files ->
+                                    logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                                })
+            }
+            return modifiedKotlinFiles
+        }
+
+        fun isClassPathChanged(): Boolean {
+            // TODO: that doesn't look to wise - join it first and then split here, consider storing it somewhere in between
+            val classpath = args.classpath.split(File.pathSeparator).map { File(it) }.toHashSet()
+            val changedClasspath = modified.filter { classpath.contains(it) }
+            return changedClasspath.any()
+        }
+
+        fun allCachesVersions() = allCachesVersions(cachesBaseDir, listOf(cachesBaseDir))
+
+        fun calculateSourcesToCompile(): Pair<List<File>, Boolean> {
+
+            if (!experimentalIncremental ||
+                    !isIncrementalRequested ||
+                    // TODO: more precise will be not to rebuild unconditionally on classpath changes, but retrieve lookup info and try to find out which sources are affected by cp changes
+                    isClassPathChanged() ||
+                    // so far considering it not incremental TODO: store java files in the cache and extract removed symbols from it here
+                    removed.any { it.isJavaFile() }
+            ) {
+                logger.kotlinInfo(if (!isIncrementalRequested) ""clean caches on rebuild"" else ""classpath changed, rebuilding all kotlin files"")
+                targets.forEach { getIncrementalCache(it).clean() }
+                lookupStorage.clean()
+                return Pair(sources, false)
+            }
+            val actions = if (isIncrementalRequested) allCachesVersions().map { it.checkVersion() }
+                          else listOf(CacheVersion.Action.REBUILD_ALL_KOTLIN)
+            // TODO: find out whether these flags should be emulated too
+//            val hasKotlin = HasKotlinMarker(dataManager)
+//            val rebuildAfterCacheVersionChanged = RebuildAfterCacheVersionChangeMarker(dataManager)
+
+            for (status in actions.distinct().sorted()) {
+                when (status) {
+                    CacheVersion.Action.REBUILD_ALL_KOTLIN -> {
+                        logger.kotlinInfo(""Kotlin global lookup map format changed, rebuilding all kotlin files"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                        lookupStorage.clean()
+                        return Pair(sources, false)
+                    }
+                    CacheVersion.Action.REBUILD_CHUNK -> {
+                        logger.kotlinInfo(""Clearing caches for "" + targets.joinToString { it.name })
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_NORMAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).clean() }
+                    }
+                    CacheVersion.Action.CLEAN_EXPERIMENTAL_CACHES -> {
+                        logger.kotlinInfo(""Clearing experimental caches for all targets"")
+                        targets.forEach { getIncrementalCache(it).cleanExperimental() }
+                    }
+                    CacheVersion.Action.CLEAN_DATA_CONTAINER -> {
+                        logger.kotlinInfo(""Clearing lookup cache"")
+                        lookupStorage.clean()
+                        dataContainerCacheVersion(cachesBaseDir).clean()
+                    }
+                    else -> {
+                        assert(status == CacheVersion.Action.DO_NOTHING) { ""Unknown version status $status"" }
+                    }
+                }
+            }
+            val dirtyFiles = dirtyKotlinSourcesFromGradle().distinct()
+            // first dirty files should be found and only then caches cleared
+            val removedKotlinFiles = removed.filter { it.isKotlinFile() }
+            targets.forEach { getIncrementalCache(it).let {
+                it.markOutputClassesDirty(removedKotlinFiles)
+                it.removeClassfilesBySources(removedKotlinFiles)
+            }}
+            return Pair(dirtyFiles, true)
+        }
+
+        fun cleanupOnError() {
+            val outputDirFile = File(args.destination!!)
+
+            assert(outputDirFile.exists())
+            val generatedRelPaths = allGeneratedFiles.map { it.outputFile.toRelativeString(outputDirFile) }
+            logger.kotlinInfo(""deleting output on error: ${generatedRelPaths.joinToString()}"")
+
+            allGeneratedFiles.forEach { it.outputFile.delete() }
+            generatedRelPaths.forEach { File(destinationDir, it).delete() }
+        }
+
+        fun processCompilerExitCode(exitCode: ExitCode) {
+            if (exitCode != ExitCode.OK) {
+                cleanupOnError()
+            }
+            when (exitCode) {
+                ExitCode.COMPILATION_ERROR -> throw GradleException(""Compilation error. See log for more details"")
+                ExitCode.INTERNAL_ERROR -> throw GradleException(""Internal compiler error. See log for more details"")
+                ExitCode.SCRIPT_EXECUTION_ERROR -> throw GradleException(""Script execution error. See log for more details"")
+                ExitCode.OK -> logger.kotlinInfo(""Compilation succeeded"")
+            }
+        }
+
+        fun outputRelativePath(f: File) = f.toRelativeString(outputDir)
+
+
+        if (!experimentalIncremental) {
+            anyClassesCompiled = true
+            processCompilerExitCode(compileNotIncremental(sources, outputDir, args))
+            return
+        }
+        logger.warn(""Using experimental kotlin incremental compilation"")
+
+        anyClassesCompiled = false
+
+        // TODO: decide what to do if no files are considered dirty - rebuild or skip the module
+        var (sourcesToCompile, isIncrementalDecided) = calculateSourcesToCompile()
+
+        if (isIncrementalDecided) {
+            // TODO: process as list here, merge into string later
+            args.classpath = args.classpath + File.pathSeparator + outputDir.absolutePath
+        }
+
+        while (sourcesToCompile.any()) {
+            logger.kotlinInfo(""compile iteration: ${sourcesToCompile.joinToString{ projectRelativePath(it) }}"")
+
+            val (exitCode, generatedFiles) = compileChanged(
+                    targets = targets,
+                    sourcesToCompile = sourcesToCompile,
+                    outputDir = outputDir,
+                    args = args,
+                    getIncrementalCache = ::getIncrementalCache,
+                    lookupTracker = lookupTracker)
+
+            allGeneratedFiles.addAll(generatedFiles)
+            // save versions?
+
+            val changes = updateIncrementalCaches(
+                    targets = targets,
+                    generatedFiles = generatedFiles,
+                    compiledWithErrors = exitCode != ExitCode.OK,
+                    getIncrementalCache = { caches[it]!! })
+
+//            lookupTracker.lookups.entrySet().forEach {
+//                logger.kotlinDebug(""lookups to ${it.key.name}:${it.key.scope} from ${it.value.joinToString { projectRelativePath(it) }}"")
+//            }
+
+            lookupStorage.update(lookupTracker, sourcesToCompile, currentRemoved)
+
+            allCachesVersions().forEach { it.saveIfNeeded() }
+
+            processCompilerExitCode(exitCode)
+
+            if (!isIncrementalDecided) break;
+
+//            logger.kotlinDebug(""generated ${generatedFiles.joinToString { outputRelativePath(it.outputFile) }}"")
+//            logger.kotlinDebug(""changes: ${changes.changes.joinToString { ""${it.fqName}: ${it.javaClass.simpleName}"" }}"")
+//
+//            logger.kotlinLazyDebug({
+//                ""known lookups:\n${lookupStorage.dump(changes.changes.flatMap {
+//                    change ->
+//                        if (change is ChangeInfo.MembersChanged)
+//                            change.names.asSequence().map { LookupSymbol(it, change.fqName.asString()) }
+//                        else
+//                            sequenceOf<LookupSymbol>()
+//                }.toSet(), project.projectDir)}"" })
+
+            compiledSourcesSet.addAll(sourcesToCompile)
+
+            val dirtyLookups = changes.dirtyLookups<TargetId>(caches.values.asSequence())
+
+//            logger.kotlinDebug(""dirty lookups: ${dirtyLookups.joinToString { ""${it.name}:${it.scope}"" }}"")
+
+            val dirty = dirtyLookups.files(
+                    filesFilter = { it !in compiledSourcesSet },
+                    logAction = { lookup, files ->
+                        logger.kotlinInfo(""changes in ${lookup.name} (${lookup.scope}) causes recompilation of ${files.joinToString { projectRelativePath(it) }}"")
+                    })
+            sourcesToCompile = dirty.filter { it in sources }.toList()
+            if (currentRemoved.any()) {
+                currentRemoved = listOf()
+            }
+//            logger.kotlinDebug(""dirty: ${dirty.joinToString { projectRelativePath(it) }}"")
+//            logger.kotlinDebug(""to compile: ${sourcesToCompile.joinToString { projectRelativePath(it) }}"")
+        }
+        lookupStorage.flush(false)
+        lookupStorage.close()
+        caches.values.forEach { it.flush(false); it.close() }
+        if (allGeneratedFiles.isNotEmpty()) {
+            anyClassesCompiled = true
+        }
+    }
+
+    private data class CompileChangedResults(val exitCode: ExitCode, val generatedFiles: List<GeneratedFile<TargetId>>)
+
+    private fun compileChanged(targets: List<TargetId>,
+                               sourcesToCompile: List<File>,
+                               outputDir: File,
+                               args: K2JVMCompilerArguments,
+                               getIncrementalCache: (TargetId) -> GradleIncrementalCacheImpl,
+                               lookupTracker: LookupTracker)
+            : CompileChangedResults
+    {
+        // show kotlin compiler where to look for java source files
+        args.freeArgs = (sourcesToCompile.map { it.absolutePath } + getJavaSourceRoots().map { it.absolutePath }).distinct()
+        args.destination = outputDir.absolutePath
+
+        logger.kotlinDebug(""compiling with args ${ArgumentUtils.convertArgumentsToStringList(args)}"")
+
+        val outputItemCollector = OutputItemsCollectorImpl()
+
+        val messageCollector = GradleMessageCollector(logger, outputItemCollector)
+
+        val incrementalCaches = makeIncrementalCachesMap(targets, { listOf<TargetId>() }, getIncrementalCache, { this })
+
+        val compilationCanceledStatus = object : CompilationCanceledStatus {
+            override fun checkCanceled() {}
+        }
+
+        logger.kotlinDebug(""compiling with args ${ArgumentUtils.convertArgumentsToStringList(args)}"")
+
+        val exitCode = compiler.exec(messageCollector, makeCompileServices(incrementalCaches, lookupTracker, compilationCanceledStatus), args)
+
+        return CompileChangedResults(
+                exitCode,
+                outputItemCollector.generatedFiles(
+                        targets = targets,
+                        representativeTarget = targets.first(),
+                        getSources = { sourcesToCompile },
+                        getOutputDir = { outputDir }))
+    }
+
+    private fun compileNotIncremental(sourcesToCompile: List<File>,
+                                      outputDir: File,
+                                      args: K2JVMCompilerArguments)
+            : ExitCode","Minor: formatting
",I'm not sure if thi
686,"@@ -168,6 +168,20 @@ class CommonIntentionActionsTest : LightPlatformCodeInsightFixtureTestCase() {
         """""".trim().trimMargin(), true)
     }
 
+    fun testRemoveConstructorParameters() {
+        myFixture.configureByText(""foo.kt"", """"""
+        |class <caret>Foo(i: Int) {
+        |}
+        """""".trim().trimMargin())
+
+        myFixture.launchAction(codeModifications.createAddCallableMemberActions(MethodInsertionInfo.constructorInfo(
+                atCaret<UClass>(myFixture), makeParams())).findWithText(""Remove 1st parameter from method 'Foo'""))","It's better to change the intention text so that it says ""constructor"" and not ""method"".",I think it would be
687,"@@ -17,12 +17,22 @@
 package org.jetbrains.kotlin.idea.compiler.configuration
 
 import com.intellij.compiler.server.BuildProcessParametersProvider
+import org.jetbrains.kotlin.idea.PluginStartupComponent
 
-public class KotlinBuildProcessParametersProvider(private val compilerWorkspaceSettings: KotlinCompilerWorkspaceSettings): BuildProcessParametersProvider() {
+public class KotlinBuildProcessParametersProvider(private val compilerWorkspaceSettings: KotlinCompilerWorkspaceSettings,
+                                                  private val kotlinPluginStartupComponent: PluginStartupComponent
+): BuildProcessParametersProvider() {
     override fun getVMArguments(): MutableList<String> {
-        return if (compilerWorkspaceSettings.incrementalCompilationEnabled)
-            arrayListOf()
-        else
-            arrayListOf(""-Dkotlin.incremental.compilation=false"")
+        val res = arrayListOf<String>()
+        if (compilerWorkspaceSettings.incrementalCompilationEnabled) {","Is it ok that behavior changed?
",Why do we need this
688,"@@ -17,3 +17,11 @@
 package org.jetbrains.kotlin.cli.common
 
 public val KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY = ""kotlin.environment.keepalive""
+
+
+fun String?.toBooleanLenient(): Boolean? = when (this?.toLowerCase()) {","It seems it is possible to simplify conditional expressions by using the following function instead of `toBooleanLenient`

```
fun String.systemPropertyAsBooleanOrTrueOtherwise(negate: Boolean): Boolean {
    val propValue = System.getProperty(this) ?: return true

    return when (propValue.toLowerCase()) {
        in listOf("""", ""yes"", ""true"", ""on"", ""y"") -> !negate
        in listOf(""no"", ""false"", ""off"", ""n"") -> negate
        else -> true
    }
}
```

See comments below.
",I'm not sure if this is the right place to put this. I think it should be in the `kotlin.cli` package.
689,"@@ -17,6 +17,7 @@
 package kotlin
 
 /**
- * Nothing has no instances
+ * Nothing has no instances. You can use Nothing as the return type of a function to indicate
+ * that it never returns (always throws an exception).","There are more use-cases for Nothing, e.g. Iterable<Nothing> is ok to exist, but it will never enter ""for"" loop, etc. Needs link to lang docs.
",I don't think this is true.
690,"@@ -171,11 +171,21 @@ private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(obj
     public override fun read(b: ByteArray, off: Int, len: Int): Int {
         return System.`in`.read(b, off, len)
     }
-}))}
+})}
 
 /**
  * Reads a line of input from the standard input stream.
  *
  * @return the line read or `null` if the input stream is redirected to a file and the end of file has been reached.
  */
-public fun readLine(): String? = stdin.readLine()
+public fun readLine(): String? {
+    tailrec fun readChars(oldBuffer: StringBuffer? = null): StringBuffer? {",Why do you choose `StringBuffer` instead of `StringBuilder`?,`readLine` and `readChars` don't seem to be used anywhere.
691,"@@ -171,11 +171,21 @@ private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(obj
     public override fun read(b: ByteArray, off: Int, len: Int): Int {
         return System.`in`.read(b, off, len)
     }
-}))}
+})}
 
 /**
  * Reads a line of input from the standard input stream.
  *
  * @return the line read or `null` if the input stream is redirected to a file and the end of file has been reached.
  */
-public fun readLine(): String? = stdin.readLine()
+public fun readLine(): String? {
+    tailrec fun readChars(oldBuffer: StringBuffer? = null): StringBuffer? {
+        val c = mystdin.read()",What is `mystdin` here?,`readLine` and `readChars` have the same signature. Why do we need both?
692,"@@ -171,11 +171,21 @@ private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(obj
     public override fun read(b: ByteArray, off: Int, len: Int): Int {
         return System.`in`.read(b, off, len)
     }
-}))}
+})}
 
 /**
  * Reads a line of input from the standard input stream.
  *
  * @return the line read or `null` if the input stream is redirected to a file and the end of file has been reached.
  */
-public fun readLine(): String? = stdin.readLine()
+public fun readLine(): String? {
+    tailrec fun readChars(oldBuffer: StringBuffer? = null): StringBuffer? {
+        val c = mystdin.read()
+        if(c < 0) return oldBuffer
+        val buffer = oldBuffer ?: StringBuffer()
+        val ch = c.toChar()
+        if(ch == '\r' || ch == '\n') return buffer","We should support ""\n"" and ""\r\n"" line delimiters, and ""\r"" alone can be treated like a plain character.",Why do we need this?
693,"@@ -171,11 +171,21 @@ private val stdin: BufferedReader by lazy { BufferedReader(InputStreamReader(obj
     public override fun read(b: ByteArray, off: Int, len: Int): Int {
         return System.`in`.read(b, off, len)
     }
-}))}
+})}
 
 /**
  * Reads a line of input from the standard input stream.
  *
  * @return the line read or `null` if the input stream is redirected to a file and the end of file has been reached.
  */
-public fun readLine(): String? = stdin.readLine()
+public fun readLine(): String? {
+    tailrec fun readChars(oldBuffer: StringBuffer? = null): StringBuffer? {
+        val c = mystdin.read()
+        if(c < 0) return oldBuffer
+        val buffer = oldBuffer ?: StringBuffer()
+        val ch = c.toChar()
+        if(ch == '\r' || ch == '\n') return buffer
+        return readChars(buffer.append(ch))
+    }
+    return readChars()?.toString()
+}","Overall, `buildString` + imperative loop might be more clear than tail recursion approach.",Why do we need this?
694,"@@ -171,6 +138,36 @@ public open class KotlinCompile() : AbstractKotlinCompile<K2JVMCompilerArguments
             FileUtils.copyDirectory(outputDirFile, getDestinationDir())
         }
     }
+
+    // override setSource to track source directory sets
+    override fun setSource(source: Any?) {
+        srcDirsSources.clear()
+        if (source is SourceDirectorySet) {
+            srcDirsSources.add(source)
+        }
+        super.setSource(source)
+    }
+
+    // override source to track source directory sets
+    override fun source(vararg sources: Any?): SourceTask? {
+        for (source in sources) {
+            if (source is SourceDirectorySet) {
+                srcDirsSources.add(source)
+            }
+        }
+        return super.source(sources)
+    }
+","SourceTask has ""protected final List<Object> source"" field from version 1.10 (or 1.11)
",I don't think we need to override `setSource` here.
695,"@@ -1730,14 +1730,14 @@ public fun <T> Stream<T>.lastOrNull(): T? {
 }
 
 /**
- * Returns last element, or null if collection is empty
+ * Returns the last character, or null if the string is empty
  */
 public fun String.lastOrNull(): Char? {
     return if (isEmpty()) null else this[length() - 1]
 }
 
 /**
- * Returns last element matching the given *predicate*, or null if element was not found
+ * Returns the last element matching the given [predicate], or *null* if no such element was found.","_null_ -> `null`
",I don't think this is correct. It should be `this[length() - 1]`.
696,"@@ -175,6 +175,23 @@ class KotlinQuickDocumentationProvider : AbstractDocumentationProvider() {
                 // element is not an KtReferenceExpression, but KtClass of enum
                 return renderEnum(element, originalElement, quickNavigation)
             }
+            else if (element is KtEnumEntry && !quickNavigation) {
+                val desc = element.resolveToDescriptorIfAny()
+                val ordinal =",It's better to calculate ordinal with `val ordinal = element.containingClassOrObject?.run { getChildrenOfType<KtEnumEntry>().indexOf(element) }`,Why do we need this?
697,"@@ -18,13 +18,15 @@ package org.jetbrains.kotlin.idea.quickfix
 
 import com.intellij.openapi.editor.Editor
 import com.intellij.openapi.project.Project
+import com.intellij.psi.util.PsiTreeUtil
 import org.jetbrains.kotlin.diagnostics.Diagnostic
 import org.jetbrains.kotlin.psi.KtFile
 import org.jetbrains.kotlin.psi.KtIsExpression
 import org.jetbrains.kotlin.psi.KtPsiFactory
+import org.jetbrains.kotlin.psi.KtWhenEntry
 import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
 
-class RemoveUselessIsCheckFix(element: KtIsExpression) : KotlinQuickFixAction<KtIsExpression>(element) {
+class RemoveUselessIsCheckFixForIf(element: KtIsExpression) : KotlinQuickFixAction<KtIsExpression>(element) {","Not a good name, may be it's better to leave it as before. This action is applicable also for when without subject, or just for code like `val a = b is Any`.",I'm not sure if this is the best name for this class. I think it should be `RemoveUselessIsCheckFixFor
698,"@@ -18,18 +18,17 @@ package org.jetbrains.kotlin.idea.intentions
 
 import com.intellij.openapi.editor.Editor
 import org.jetbrains.kotlin.idea.core.replaced
-import org.jetbrains.kotlin.psi.KtCallExpression
-import org.jetbrains.kotlin.psi.KtDotQualifiedExpression
-import org.jetbrains.kotlin.psi.KtPsiFactory
-import org.jetbrains.kotlin.psi.createExpressionByPattern
+import org.jetbrains.kotlin.psi.*
 import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
 
 abstract class ReplaceMathMethodsWithKotlinNativeMethodsIntention(
-        text: String, val replacedMethodName: String, val mathMethodName: String
+        text: String, private val replacedMethodName: String, private val mathMethodName: String
 ) : SelfTargetingOffsetIndependentIntention<KtCallExpression>(KtCallExpression::class.java, text) {
 
     override fun applyTo(element: KtCallExpression, editor: Editor?) {
-        val target = element.getStrictParentOfType<KtDotQualifiedExpression>() ?: element
+        val target = element.getStrictParentOfType<KtDotQualifiedExpression>()?.takeIf {
+            (it.receiverExpression as? KtNameReferenceExpression)?.getReferencedName() == ""Math""
+        } ?: element","It's also not the best way, you can meet something like

```
Math.max(max(1, 3), max(2, 4))
```

and will have the same problem. Will fix it myself.",I don't think we need the `*` here.
699,"@@ -18,246 +18,376 @@ package org.jetbrains.kotlin.rmi.kotlinr
 
 import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
 import org.jetbrains.kotlin.rmi.*
-import java.io.File
-import java.io.OutputStream
-import java.io.PrintStream
+import java.io.*
 import java.rmi.ConnectException
-import java.rmi.Remote
 import java.rmi.registry.LocateRegistry
 import java.util.concurrent.Semaphore
 import java.util.concurrent.TimeUnit
 import kotlin.concurrent.thread
 
-fun Process.isAlive() =
+
+public object KotlinCompilerClient {
+
+    val DAEMON_DEFAULT_STARTUP_TIMEOUT_MS = 10000L
+    val DAEMON_CONNECT_CYCLE_ATTEMPTS = 3
+
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun connectToCompileService(compilerId: CompilerId,
+                                       daemonJVMOptions: DaemonJVMOptions,
+                                       daemonOptions: DaemonOptions,
+                                       reportingTargets: DaemonReportingTargets,
+                                       autostart: Boolean = true,
+                                       checkId: Boolean = true
+    ): CompileService? {
+
+        var attempts = 0
+        var fileLock: FileBasedLock? = null
         try {
-            this.exitValue()
-            false
+            while (attempts++ < DAEMON_CONNECT_CYCLE_ATTEMPTS) {
+                val service = tryFindDaemon(File(daemonOptions.runFilesPath), compilerId, reportingTargets)
+                if (service != null) {
+                    if (!checkId || checkCompilerId(service, compilerId)) {
+                        reportingTargets.report(DaemonReportCategory.DEBUG, ""connected to the daemon"")
+                        return service
+                    }
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""shutdown the daemon"")
+                    service.shutdown()
+                    // TODO: find more reliable way
+                    Thread.sleep(1000)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon shut down correctly, restarting search"")
+                }
+                else {
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""no suitable daemon found, starting a new one"")
+                }
+
+                if (fileLock == null || !fileLock.isLocked()) {
+                    File(daemonOptions.runFilesPath).mkdirs()
+                    fileLock = FileBasedLock(compilerId, daemonOptions)
+                    // need to check the daemons again here, because of possible racing conditions
+                    // note: the algorithm could be simpler if we'll acquire lock right from the beginning, but it may be costly
+                    attempts--
+                }
+                else {
+                    startDaemon(compilerId, daemonJVMOptions, daemonOptions, reportingTargets)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon started, trying to resolve"")
+                }
+            }
         }
-        catch (e: IllegalThreadStateException) {
-            true
+        catch (e: Exception) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, e.toString())
+        }
+        finally {
+            fileLock?.release()
         }
+        return null
+    }
 
-public class KotlinCompilerClient {
 
-    companion object {
+    public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+        KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, DaemonReportingTargets(out = System.out), autostart = false, checkId = false)
+                ?.shutdown()
+    }
 
-        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
 
-        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+    public fun shutdownCompileService(): Unit {
+        shutdownCompileService(DaemonOptions())
+    }
 
-            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
-            return compilerObj as? CompileService ?:
-                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+
+    public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+        val outStrm = RemoteOutputStreamServer(out)
+        try {
+            return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN, outStrm)
         }
+        finally {
+            outStrm.disconnect()
+        }
+    }
 
-        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
-            try {
-                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
-                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
-                if (daemon != null)
-                    return daemon
-                errStream.println(""[daemon client] daemon not found"")
-            }
-            catch (e: ConnectException) {
-                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
-                // ignoring it - processing below
-            }
-            return null
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, compilerOut: OutputStream, daemonOut: OutputStream): Int {
+
+        val compilerOutStreamServer = RemoteOutputStreamServer(compilerOut)
+        val daemonOutStreamServer = RemoteOutputStreamServer(daemonOut)
+        val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+        try {
+            caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer(it.getValue()) })
+            return compiler.remoteIncrementalCompile(args, cacheServers, compilerOutStreamServer, CompileService.OutputFormat.XML, daemonOutStreamServer)
+        }
+        finally {
+            cacheServers.forEach { it.getValue().disconnect() }
+            compilerOutStreamServer.disconnect()
+            daemonOutStreamServer.disconnect()
         }
+    }
 
 
-        private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
-            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
-                val javaw = File(it, ""javaw.exe"")
-                if (javaw.exists()) javaw
-                else File(it, ""java"")
-            }
-            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
-            val args = listOf(javaExecutable.absolutePath,
-                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
-                       daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
-                       COMPILER_DAEMON_CLASS_FQN +
-                       daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
-                       compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
-            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
-            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
-            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
-            val daemon = processBuilder.start()
-
-            var isEchoRead = Semaphore(1)
-            isEchoRead.acquire()
-
-            val stdoutThread =
-                    thread {
-                        daemon.getInputStream()
-                              .reader()
-                              .forEachLine {
-                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
-                                      isEchoRead.release()
-                                      return@forEachLine
-                                  }
-                                  errStream.println(""[daemon] "" + it)
-                              }
-                    }
-            try {
-                // trying to wait for process
-                if (daemonOptions.startEcho.isNotEmpty()) {
-                    errStream.println(""[daemon client] waiting for daemon to respond"")
-                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
-                    if (!daemon.isAlive())
-                        throw Exception(""Daemon terminated unexpectedly"")
-                    if (!succeeded)
-                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
-                }
-                else
-                // without startEcho defined waiting for max timeout
-                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
-            }
-            finally {
-                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
-                if (stdoutThread.isAlive)
-                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
-                    stdoutThread.stop()
+    data class ClientOptions(
+            public var stop: Boolean = false
+    ) : OptionsGroup {
+        override val mappers: List<PropMapper<*, *, *>>
+            get() = listOf(BoolPropMapper(this, ::stop))
+    }
+
+
+    jvmStatic public fun main(vararg args: String) {
+        val compilerId = CompilerId()
+        val daemonOptions = DaemonOptions()
+        val daemonLaunchingOptions = DaemonJVMOptions()
+        val clientOptions = ClientOptions()
+        val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
+
+        if (!clientOptions.stop) {
+            if (compilerId.compilerClasspath.none()) {
+                // attempt to find compiler to use
+                System.err.println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
+                System.getProperty(""java.class.path"")
+                        ?.split(File.pathSeparator)
+                        ?.map { File(it).parentFile }
+                        ?.distinct()
+                        ?.map {
+                            it?.walk()
+                                    ?.firstOrNull { it.name.equals(COMPILER_JAR_NAME, ignoreCase = true) }
+                        }
+                        ?.filterNotNull()
+                        ?.firstOrNull()
+                        ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
             }
-        }
+            if (compilerId.compilerClasspath.none())
+                throw IllegalArgumentException(""Cannot find compiler jar"")
+            else
+                println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
 
-        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
-            val remoteId = compiler.getCompilerId()
-            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
-            errStream.println(""[daemon client] localId = "" + localId.toString())
-            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
-                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
-                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+            compilerId.updateDigest()
         }
 
-        public fun connectToCompileService(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
-            val service = connectToService(compilerId, daemonOptions, errStream)
-            if (service != null) {
-                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
-                    errStream.println(""[daemon client] found the suitable daemon"")
-                    return service
-                }
-                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
-                if (!autostart) return null;
-                errStream.println(""[daemon client] shutdown the daemon"")
-                service.shutdown()
-                // TODO: find more reliable way
-                Thread.sleep(1000)
-                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+        val daemon = connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, DaemonReportingTargets(out = System.out), autostart = !clientOptions.stop, checkId = !clientOptions.stop)
+
+        if (daemon == null) {
+            if (clientOptions.stop) {
+                System.err.println(""No daemon found to shut down"")
             }
-            else {
-                if (!autostart) return null;
-                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            else throw Exception(""Unable to connect to daemon"")
+        }
+        else when {
+            clientOptions.stop -> {
+                println(""Shutdown the daemon"")
+                daemon.shutdown()
+                println(""Daemon shut down successfully"")
             }
+            else -> {
+                println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
+                val outStrm = RemoteOutputStreamServer(System.out)
+                try {
+                    val memBefore = daemon.getUsedMemory() / 1024
+                    val startTime = System.nanoTime()
+
+                    val res = daemon.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN, outStrm)
 
-            startDaemon(compilerId, daemonJVMOptions, daemonOptions, errStream)
-            errStream.println(""[daemon client] daemon started, trying to connect"")
-            return connectToService(compilerId, daemonOptions, errStream)
+                    val endTime = System.nanoTime()
+                    println(""Compilation result code: $res"")
+                    val memAfter = daemon.getUsedMemory() / 1024
+                    println(""Compilation time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
+                    println(""Used memory $memAfter (${""%+d"".format(memAfter - memBefore)} kb)"")
+                }
+                finally {
+                    outStrm.disconnect()
+                }
+            }
         }
+    }
 
-        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
-            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, System.out, autostart = false, checkId = false)
-                    ?.shutdown()
+    // --- Implementation ---------------------------------------
+
+    val verboseReporting = System.getProperty(COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY) != null
+
+    fun DaemonReportingTargets.report(category: DaemonReportCategory, message: String, source: String = ""daemon client"") {
+        if (category == DaemonReportCategory.DEBUG && !verboseReporting) return
+        out?.println(""[$source] ${category.name()}: $message"")
+        messages?.add(DaemonReportMessage(category, ""[$source] $message""))
+    }
+
+    private fun tryFindDaemon(registryDir: File, compilerId: CompilerId, reportingTargets: DaemonReportingTargets): CompileService? {
+        val classPathDigest = compilerId.compilerClasspath.map { File(it).absolutePath }.distinctStringsDigest()
+        val daemons = registryDir.walk()
+                .map { Pair(it, makeRunFilenameRegex(digest = classPathDigest, port = ""(\\d+)"").match(it.name)?.groups?.get(1)?.value?.toInt() ?: 0) }
+                .filter { it.second != 0 }
+                .map {
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""found suitable daemon on port ${it.second}, trying to connect"")
+                    val daemon = tryConnectToDaemon(it.second, reportingTargets)
+                    // cleaning orphaned file; note: daemon should shut itself down if it detects that the run file is deleted
+                    if (daemon == null && !it.first.delete()) {
+                        reportingTargets.report(DaemonReportCategory.INFO, ""WARNING: unable to delete seemingly orphaned file '${it.first.absolutePath}', cleanup recommended"")
+                    }
+                    daemon
+                }
+                .filterNotNull()
+                .toList()
+        return when (daemons.size()) {
+            0 -> null
+            1 -> daemons.first()
+            else -> throw IllegalStateException(""Multiple daemons serving the same compiler, reset with the cleanup required"")
+        // TODO: consider implementing automatic recovery instead, e.g. getting the youngest or least used daemon and shut down others
         }
+    }
 
-        public fun shutdownCompileService(): Unit {
-            shutdownCompileService(DaemonOptions())
+    private fun tryConnectToDaemon(port: Int, reportingTargets: DaemonReportingTargets): CompileService? {
+        try {
+            val daemon = LocateRegistry.getRegistry(loopbackAddrName, port)
+                    ?.lookup(COMPILER_SERVICE_RMI_NAME)
+            if (daemon != null)
+                return daemon as? CompileService ?:
+                       throw ClassCastException(""Unable to cast compiler service, actual class received: ${daemon.javaClass}"")
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""daemon not found"")
+        }
+        catch (e: ConnectException) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+            // ignoring it - processing below
         }
+        return null
+    }
 
-        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
 
-            val outStrm = RemoteOutputStreamServer(out)
-            try {
-                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
-            }
-            finally {
-                outStrm.disconnect()
-            }
+    private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, reportingTargets: DaemonReportingTargets) {
+        val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+            val javaw = File(it, ""javaw.exe"")
+            // TODO: doesn't seem reliable enough, consider more checks if OS is of windows flavor, etc.
+            if (javaw.exists() && javaw.isFile && javaw.canExecute()) javaw else File(it, ""java"")
         }
+        val args = listOf(javaExecutable.absolutePath,
+                          ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                   daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
+                   COMPILER_DAEMON_CLASS_FQN +
+                   daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                   compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+        reportingTargets.report(DaemonReportCategory.DEBUG, ""starting the daemon as: "" + args.joinToString("" ""))
+        val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+        // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+        val daemon = processBuilder.start()
 
-        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+        var isEchoRead = Semaphore(1)
+        isEchoRead.acquire()
 
-            val outStrm = RemoteOutputStreamServer(out)
-            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
-            try {
-                caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer( it.getValue()) })
-                return compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+        val stdoutThread =
+                thread {
+                    daemon.inputStream
+                            .reader()
+                            .forEachLine {
+                                if (daemonOptions.runFilesPath.isNotEmpty() && it.contains(daemonOptions.runFilesPath)) {
+                                    isEchoRead.release()
+                                    return@forEachLine
+                                }
+                                reportingTargets.report(DaemonReportCategory.DEBUG, it, ""daemon"")
+                            }
+                }
+        try {
+            // trying to wait for process
+            val daemonStartupTimeout = System.getProperty(COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY)?.let {
+                try {
+                    it.toLong()
+                }
+                catch (e: Exception) {
+                    reportingTargets.report(DaemonReportCategory.INFO, ""unable to interpret $COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY property ('$it'); using default timeout $DAEMON_DEFAULT_STARTUP_TIMEOUT_MS ms"")
+                    null
+                }
+            } ?: DAEMON_DEFAULT_STARTUP_TIMEOUT_MS
+            if (daemonOptions.runFilesPath.isNotEmpty()) {
+                val succeeded = isEchoRead.tryAcquire(daemonStartupTimeout, TimeUnit.MILLISECONDS)
+                if (!daemon.isAlive())
+                    throw Exception(""Daemon terminated unexpectedly"")
+                if (!succeeded)
+                    throw Exception(""Unable to get response from daemon in $daemonStartupTimeout ms"")
             }
-            finally {
-                cacheServers.forEach { it.getValue().disconnect() }
-                outStrm.disconnect()
+            else
+            // without startEcho defined waiting for max timeout
+                Thread.sleep(daemonStartupTimeout)
+        }
+        finally {
+            // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+            if (stdoutThread.isAlive) {
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                stdoutThread.stop()
             }
         }
+    }
 
-        data class ClientOptions(
-                public var stop: Boolean = false
-        ) : OptionsGroup {
-            override val mappers: List<PropMapper<*, *, *>>
-                get() = listOf( BoolPropMapper(this, ::stop))
-        }
 
-        jvmStatic public fun main(vararg args: String) {
-            val compilerId = CompilerId()
-            val daemonOptions = DaemonOptions()
-            val daemonLaunchingOptions = DaemonJVMOptions()
-            val clientOptions = ClientOptions()
-            val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
-
-            if (!clientOptions.stop) {
-                if (compilerId.compilerClasspath.none()) {
-                    // attempt to find compiler to use
-                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
-                    System.getProperty(""java.class.path"")
-                            ?.split(File.pathSeparator)
-                            ?.map { File(it).parent }
-                            ?.distinct()
-                            ?.map {
-                                it?.walk()
-                                        ?.firstOrNull { it.getName().equals(COMPILER_JAR_NAME, ignoreCase = true) }
-                            }
-                            ?.filterNotNull()
-                            ?.firstOrNull()
-                            ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
-                }
-                if (compilerId.compilerClasspath.none())
-                    throw IllegalArgumentException(""Cannot find compiler jar"")
-                else
-                    println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
+    private fun checkCompilerId(compiler: CompileService, localId: CompilerId): Boolean {
+        val remoteId = compiler.getCompilerId()
+        return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+               (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+               (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+    }
 
-                compilerId.updateDigest()
+
+    class FileBasedLock(compilerId: CompilerId, daemonOptions: DaemonOptions) {
+        private val lockFile: File =
+                File(daemonOptions.runFilesPath,","do we need to keep them in home dir? can we use tempdir instead to eliminate possible issues caused by NFS-backed homedir, etc ?
",I think it would be better to use `TimeUnit.MILLISECONDS.toMillis(DAEMON_DEFAULT_STARTUP_TIMEOUT_MS)` 
700,"@@ -18,246 +18,376 @@ package org.jetbrains.kotlin.rmi.kotlinr
 
 import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
 import org.jetbrains.kotlin.rmi.*
-import java.io.File
-import java.io.OutputStream
-import java.io.PrintStream
+import java.io.*
 import java.rmi.ConnectException
-import java.rmi.Remote
 import java.rmi.registry.LocateRegistry
 import java.util.concurrent.Semaphore
 import java.util.concurrent.TimeUnit
 import kotlin.concurrent.thread
 
-fun Process.isAlive() =
+
+public object KotlinCompilerClient {
+
+    val DAEMON_DEFAULT_STARTUP_TIMEOUT_MS = 10000L
+    val DAEMON_CONNECT_CYCLE_ATTEMPTS = 3
+
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun connectToCompileService(compilerId: CompilerId,
+                                       daemonJVMOptions: DaemonJVMOptions,
+                                       daemonOptions: DaemonOptions,
+                                       reportingTargets: DaemonReportingTargets,
+                                       autostart: Boolean = true,
+                                       checkId: Boolean = true
+    ): CompileService? {
+
+        var attempts = 0
+        var fileLock: FileBasedLock? = null
         try {
-            this.exitValue()
-            false
+            while (attempts++ < DAEMON_CONNECT_CYCLE_ATTEMPTS) {
+                val service = tryFindDaemon(File(daemonOptions.runFilesPath), compilerId, reportingTargets)
+                if (service != null) {
+                    if (!checkId || checkCompilerId(service, compilerId)) {
+                        reportingTargets.report(DaemonReportCategory.DEBUG, ""connected to the daemon"")
+                        return service
+                    }
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""shutdown the daemon"")
+                    service.shutdown()
+                    // TODO: find more reliable way
+                    Thread.sleep(1000)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon shut down correctly, restarting search"")
+                }
+                else {
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""no suitable daemon found, starting a new one"")
+                }
+
+                if (fileLock == null || !fileLock.isLocked()) {
+                    File(daemonOptions.runFilesPath).mkdirs()
+                    fileLock = FileBasedLock(compilerId, daemonOptions)
+                    // need to check the daemons again here, because of possible racing conditions
+                    // note: the algorithm could be simpler if we'll acquire lock right from the beginning, but it may be costly
+                    attempts--
+                }
+                else {
+                    startDaemon(compilerId, daemonJVMOptions, daemonOptions, reportingTargets)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon started, trying to resolve"")
+                }
+            }
         }
-        catch (e: IllegalThreadStateException) {
-            true
+        catch (e: Exception) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, e.toString())
+        }
+        finally {
+            fileLock?.release()
         }
+        return null
+    }
 
-public class KotlinCompilerClient {
 
-    companion object {
+    public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+        KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, DaemonReportingTargets(out = System.out), autostart = false, checkId = false)
+                ?.shutdown()
+    }
 
-        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
 
-        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+    public fun shutdownCompileService(): Unit {
+        shutdownCompileService(DaemonOptions())
+    }
 
-            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
-            return compilerObj as? CompileService ?:
-                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+
+    public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+        val outStrm = RemoteOutputStreamServer(out)
+        try {
+            return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN, outStrm)
         }
+        finally {
+            outStrm.disconnect()
+        }
+    }
 
-        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
-            try {
-                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
-                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
-                if (daemon != null)
-                    return daemon
-                errStream.println(""[daemon client] daemon not found"")
-            }
-            catch (e: ConnectException) {
-                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
-                // ignoring it - processing below
-            }
-            return null
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, compilerOut: OutputStream, daemonOut: OutputStream): Int {
+
+        val compilerOutStreamServer = RemoteOutputStreamServer(compilerOut)
+        val daemonOutStreamServer = RemoteOutputStreamServer(daemonOut)
+        val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+        try {
+            caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer(it.getValue()) })
+            return compiler.remoteIncrementalCompile(args, cacheServers, compilerOutStreamServer, CompileService.OutputFormat.XML, daemonOutStreamServer)
+        }
+        finally {
+            cacheServers.forEach { it.getValue().disconnect() }
+            compilerOutStreamServer.disconnect()
+            daemonOutStreamServer.disconnect()
         }
+    }
 
 
-        private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
-            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
-                val javaw = File(it, ""javaw.exe"")
-                if (javaw.exists()) javaw
-                else File(it, ""java"")
-            }
-            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
-            val args = listOf(javaExecutable.absolutePath,
-                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
-                       daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
-                       COMPILER_DAEMON_CLASS_FQN +
-                       daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
-                       compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
-            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
-            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
-            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
-            val daemon = processBuilder.start()
-
-            var isEchoRead = Semaphore(1)
-            isEchoRead.acquire()
-
-            val stdoutThread =
-                    thread {
-                        daemon.getInputStream()
-                              .reader()
-                              .forEachLine {
-                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
-                                      isEchoRead.release()
-                                      return@forEachLine
-                                  }
-                                  errStream.println(""[daemon] "" + it)
-                              }
-                    }
-            try {
-                // trying to wait for process
-                if (daemonOptions.startEcho.isNotEmpty()) {
-                    errStream.println(""[daemon client] waiting for daemon to respond"")
-                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
-                    if (!daemon.isAlive())
-                        throw Exception(""Daemon terminated unexpectedly"")
-                    if (!succeeded)
-                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
-                }
-                else
-                // without startEcho defined waiting for max timeout
-                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
-            }
-            finally {
-                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
-                if (stdoutThread.isAlive)
-                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
-                    stdoutThread.stop()
+    data class ClientOptions(
+            public var stop: Boolean = false
+    ) : OptionsGroup {
+        override val mappers: List<PropMapper<*, *, *>>
+            get() = listOf(BoolPropMapper(this, ::stop))
+    }
+
+
+    jvmStatic public fun main(vararg args: String) {
+        val compilerId = CompilerId()
+        val daemonOptions = DaemonOptions()
+        val daemonLaunchingOptions = DaemonJVMOptions()
+        val clientOptions = ClientOptions()
+        val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
+
+        if (!clientOptions.stop) {
+            if (compilerId.compilerClasspath.none()) {
+                // attempt to find compiler to use
+                System.err.println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
+                System.getProperty(""java.class.path"")
+                        ?.split(File.pathSeparator)
+                        ?.map { File(it).parentFile }
+                        ?.distinct()
+                        ?.map {
+                            it?.walk()
+                                    ?.firstOrNull { it.name.equals(COMPILER_JAR_NAME, ignoreCase = true) }
+                        }
+                        ?.filterNotNull()
+                        ?.firstOrNull()
+                        ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
             }
-        }
+            if (compilerId.compilerClasspath.none())
+                throw IllegalArgumentException(""Cannot find compiler jar"")
+            else
+                println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
 
-        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
-            val remoteId = compiler.getCompilerId()
-            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
-            errStream.println(""[daemon client] localId = "" + localId.toString())
-            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
-                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
-                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+            compilerId.updateDigest()
         }
 
-        public fun connectToCompileService(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
-            val service = connectToService(compilerId, daemonOptions, errStream)
-            if (service != null) {
-                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
-                    errStream.println(""[daemon client] found the suitable daemon"")
-                    return service
-                }
-                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
-                if (!autostart) return null;
-                errStream.println(""[daemon client] shutdown the daemon"")
-                service.shutdown()
-                // TODO: find more reliable way
-                Thread.sleep(1000)
-                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+        val daemon = connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, DaemonReportingTargets(out = System.out), autostart = !clientOptions.stop, checkId = !clientOptions.stop)
+
+        if (daemon == null) {
+            if (clientOptions.stop) {
+                System.err.println(""No daemon found to shut down"")
             }
-            else {
-                if (!autostart) return null;
-                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            else throw Exception(""Unable to connect to daemon"")
+        }
+        else when {
+            clientOptions.stop -> {
+                println(""Shutdown the daemon"")
+                daemon.shutdown()
+                println(""Daemon shut down successfully"")
             }
+            else -> {
+                println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
+                val outStrm = RemoteOutputStreamServer(System.out)
+                try {
+                    val memBefore = daemon.getUsedMemory() / 1024
+                    val startTime = System.nanoTime()
+
+                    val res = daemon.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN, outStrm)
 
-            startDaemon(compilerId, daemonJVMOptions, daemonOptions, errStream)
-            errStream.println(""[daemon client] daemon started, trying to connect"")
-            return connectToService(compilerId, daemonOptions, errStream)
+                    val endTime = System.nanoTime()
+                    println(""Compilation result code: $res"")
+                    val memAfter = daemon.getUsedMemory() / 1024
+                    println(""Compilation time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
+                    println(""Used memory $memAfter (${""%+d"".format(memAfter - memBefore)} kb)"")
+                }
+                finally {
+                    outStrm.disconnect()
+                }
+            }
         }
+    }
 
-        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
-            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, System.out, autostart = false, checkId = false)
-                    ?.shutdown()
+    // --- Implementation ---------------------------------------
+
+    val verboseReporting = System.getProperty(COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY) != null
+
+    fun DaemonReportingTargets.report(category: DaemonReportCategory, message: String, source: String = ""daemon client"") {
+        if (category == DaemonReportCategory.DEBUG && !verboseReporting) return
+        out?.println(""[$source] ${category.name()}: $message"")
+        messages?.add(DaemonReportMessage(category, ""[$source] $message""))
+    }
+
+    private fun tryFindDaemon(registryDir: File, compilerId: CompilerId, reportingTargets: DaemonReportingTargets): CompileService? {
+        val classPathDigest = compilerId.compilerClasspath.map { File(it).absolutePath }.distinctStringsDigest()
+        val daemons = registryDir.walk()
+                .map { Pair(it, makeRunFilenameRegex(digest = classPathDigest, port = ""(\\d+)"").match(it.name)?.groups?.get(1)?.value?.toInt() ?: 0) }
+                .filter { it.second != 0 }
+                .map {
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""found suitable daemon on port ${it.second}, trying to connect"")
+                    val daemon = tryConnectToDaemon(it.second, reportingTargets)
+                    // cleaning orphaned file; note: daemon should shut itself down if it detects that the run file is deleted
+                    if (daemon == null && !it.first.delete()) {
+                        reportingTargets.report(DaemonReportCategory.INFO, ""WARNING: unable to delete seemingly orphaned file '${it.first.absolutePath}', cleanup recommended"")
+                    }
+                    daemon
+                }
+                .filterNotNull()
+                .toList()
+        return when (daemons.size()) {
+            0 -> null
+            1 -> daemons.first()
+            else -> throw IllegalStateException(""Multiple daemons serving the same compiler, reset with the cleanup required"")
+        // TODO: consider implementing automatic recovery instead, e.g. getting the youngest or least used daemon and shut down others
         }
+    }
 
-        public fun shutdownCompileService(): Unit {
-            shutdownCompileService(DaemonOptions())
+    private fun tryConnectToDaemon(port: Int, reportingTargets: DaemonReportingTargets): CompileService? {
+        try {
+            val daemon = LocateRegistry.getRegistry(loopbackAddrName, port)
+                    ?.lookup(COMPILER_SERVICE_RMI_NAME)
+            if (daemon != null)
+                return daemon as? CompileService ?:
+                       throw ClassCastException(""Unable to cast compiler service, actual class received: ${daemon.javaClass}"")
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""daemon not found"")
+        }
+        catch (e: ConnectException) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+            // ignoring it - processing below
         }
+        return null
+    }
 
-        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
 
-            val outStrm = RemoteOutputStreamServer(out)
-            try {
-                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
-            }
-            finally {
-                outStrm.disconnect()
-            }
+    private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, reportingTargets: DaemonReportingTargets) {
+        val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+            val javaw = File(it, ""javaw.exe"")
+            // TODO: doesn't seem reliable enough, consider more checks if OS is of windows flavor, etc.
+            if (javaw.exists() && javaw.isFile && javaw.canExecute()) javaw else File(it, ""java"")
         }
+        val args = listOf(javaExecutable.absolutePath,
+                          ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                   daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
+                   COMPILER_DAEMON_CLASS_FQN +
+                   daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                   compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+        reportingTargets.report(DaemonReportCategory.DEBUG, ""starting the daemon as: "" + args.joinToString("" ""))
+        val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+        // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+        val daemon = processBuilder.start()
 
-        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+        var isEchoRead = Semaphore(1)
+        isEchoRead.acquire()
 
-            val outStrm = RemoteOutputStreamServer(out)
-            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
-            try {
-                caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer( it.getValue()) })
-                return compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+        val stdoutThread =
+                thread {
+                    daemon.inputStream
+                            .reader()
+                            .forEachLine {
+                                if (daemonOptions.runFilesPath.isNotEmpty() && it.contains(daemonOptions.runFilesPath)) {
+                                    isEchoRead.release()
+                                    return@forEachLine
+                                }
+                                reportingTargets.report(DaemonReportCategory.DEBUG, it, ""daemon"")
+                            }
+                }
+        try {
+            // trying to wait for process
+            val daemonStartupTimeout = System.getProperty(COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY)?.let {
+                try {
+                    it.toLong()
+                }
+                catch (e: Exception) {
+                    reportingTargets.report(DaemonReportCategory.INFO, ""unable to interpret $COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY property ('$it'); using default timeout $DAEMON_DEFAULT_STARTUP_TIMEOUT_MS ms"")
+                    null
+                }
+            } ?: DAEMON_DEFAULT_STARTUP_TIMEOUT_MS
+            if (daemonOptions.runFilesPath.isNotEmpty()) {
+                val succeeded = isEchoRead.tryAcquire(daemonStartupTimeout, TimeUnit.MILLISECONDS)
+                if (!daemon.isAlive())
+                    throw Exception(""Daemon terminated unexpectedly"")
+                if (!succeeded)
+                    throw Exception(""Unable to get response from daemon in $daemonStartupTimeout ms"")
             }
-            finally {
-                cacheServers.forEach { it.getValue().disconnect() }
-                outStrm.disconnect()
+            else
+            // without startEcho defined waiting for max timeout
+                Thread.sleep(daemonStartupTimeout)
+        }
+        finally {
+            // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+            if (stdoutThread.isAlive) {
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                stdoutThread.stop()
             }
         }
+    }
 
-        data class ClientOptions(
-                public var stop: Boolean = false
-        ) : OptionsGroup {
-            override val mappers: List<PropMapper<*, *, *>>
-                get() = listOf( BoolPropMapper(this, ::stop))
-        }
 
-        jvmStatic public fun main(vararg args: String) {
-            val compilerId = CompilerId()
-            val daemonOptions = DaemonOptions()
-            val daemonLaunchingOptions = DaemonJVMOptions()
-            val clientOptions = ClientOptions()
-            val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
-
-            if (!clientOptions.stop) {
-                if (compilerId.compilerClasspath.none()) {
-                    // attempt to find compiler to use
-                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
-                    System.getProperty(""java.class.path"")
-                            ?.split(File.pathSeparator)
-                            ?.map { File(it).parent }
-                            ?.distinct()
-                            ?.map {
-                                it?.walk()
-                                        ?.firstOrNull { it.getName().equals(COMPILER_JAR_NAME, ignoreCase = true) }
-                            }
-                            ?.filterNotNull()
-                            ?.firstOrNull()
-                            ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
-                }
-                if (compilerId.compilerClasspath.none())
-                    throw IllegalArgumentException(""Cannot find compiler jar"")
-                else
-                    println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
+    private fun checkCompilerId(compiler: CompileService, localId: CompilerId): Boolean {
+        val remoteId = compiler.getCompilerId()
+        return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+               (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+               (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+    }
 
-                compilerId.updateDigest()
+
+    class FileBasedLock(compilerId: CompilerId, daemonOptions: DaemonOptions) {
+        private val lockFile: File =
+                File(daemonOptions.runFilesPath,
+                     makeRunFilenameString(ts = ""lock"",
+                                           digest = compilerId.compilerClasspath.map { File(it).absolutePath }.distinctStringsDigest(),
+                                           port = ""0""))
+
+        private var locked: Boolean = acquireLockFile(lockFile)
+
+        public fun isLocked(): Boolean = locked
+
+        synchronized public fun release(): Unit {
+            if (locked) {
+                lock?.release()
+                channel?.close()
+                lockFile.delete()
+                locked = false
             }
+        }
 
-            val daemon = connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, System.out, autostart = !clientOptions.stop, checkId = !clientOptions.stop)
+        private val channel = if (locked) RandomAccessFile(lockFile, ""rw"").channel else null
+        private val lock = channel?.lock()
 
-            if (daemon == null) {
-                if (clientOptions.stop) println(""No daemon found to shut down"")
-                else throw Exception(""Unable to connect to daemon"")
+        synchronized private fun acquireLockFile(lockFile: File): Boolean {","~~Why do we have `:Boolean` function that always returns `true` ?~~
I see, sorry
",I think it would be better to use `TimeUnit.MILLISECONDS.toMillis(DAEMON_DEFAULT_STARTUP_TIMEOUT_MS)` 
701,"@@ -18,246 +18,376 @@ package org.jetbrains.kotlin.rmi.kotlinr
 
 import org.jetbrains.kotlin.load.kotlin.incremental.components.IncrementalCache
 import org.jetbrains.kotlin.rmi.*
-import java.io.File
-import java.io.OutputStream
-import java.io.PrintStream
+import java.io.*
 import java.rmi.ConnectException
-import java.rmi.Remote
 import java.rmi.registry.LocateRegistry
 import java.util.concurrent.Semaphore
 import java.util.concurrent.TimeUnit
 import kotlin.concurrent.thread
 
-fun Process.isAlive() =
+
+public object KotlinCompilerClient {
+
+    val DAEMON_DEFAULT_STARTUP_TIMEOUT_MS = 10000L
+    val DAEMON_CONNECT_CYCLE_ATTEMPTS = 3
+
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun connectToCompileService(compilerId: CompilerId,
+                                       daemonJVMOptions: DaemonJVMOptions,
+                                       daemonOptions: DaemonOptions,
+                                       reportingTargets: DaemonReportingTargets,
+                                       autostart: Boolean = true,
+                                       checkId: Boolean = true
+    ): CompileService? {
+
+        var attempts = 0
+        var fileLock: FileBasedLock? = null
         try {
-            this.exitValue()
-            false
+            while (attempts++ < DAEMON_CONNECT_CYCLE_ATTEMPTS) {
+                val service = tryFindDaemon(File(daemonOptions.runFilesPath), compilerId, reportingTargets)
+                if (service != null) {
+                    if (!checkId || checkCompilerId(service, compilerId)) {
+                        reportingTargets.report(DaemonReportCategory.DEBUG, ""connected to the daemon"")
+                        return service
+                    }
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""shutdown the daemon"")
+                    service.shutdown()
+                    // TODO: find more reliable way
+                    Thread.sleep(1000)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon shut down correctly, restarting search"")
+                }
+                else {
+                    if (!autostart) return null
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""no suitable daemon found, starting a new one"")
+                }
+
+                if (fileLock == null || !fileLock.isLocked()) {
+                    File(daemonOptions.runFilesPath).mkdirs()
+                    fileLock = FileBasedLock(compilerId, daemonOptions)
+                    // need to check the daemons again here, because of possible racing conditions
+                    // note: the algorithm could be simpler if we'll acquire lock right from the beginning, but it may be costly
+                    attempts--
+                }
+                else {
+                    startDaemon(compilerId, daemonJVMOptions, daemonOptions, reportingTargets)
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""daemon started, trying to resolve"")
+                }
+            }
         }
-        catch (e: IllegalThreadStateException) {
-            true
+        catch (e: Exception) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, e.toString())
+        }
+        finally {
+            fileLock?.release()
         }
+        return null
+    }
 
-public class KotlinCompilerClient {
 
-    companion object {
+    public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
+        KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, DaemonReportingTargets(out = System.out), autostart = false, checkId = false)
+                ?.shutdown()
+    }
 
-        val DAEMON_STARTUP_TIMEOUT_MS = 10000L
 
-        private fun connectToService(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): CompileService? {
+    public fun shutdownCompileService(): Unit {
+        shutdownCompileService(DaemonOptions())
+    }
 
-            val compilerObj = connectToDaemon(compilerId, daemonOptions, errStream) ?: return null // no registry - no daemon running
-            return compilerObj as? CompileService ?:
-                throw ClassCastException(""Unable to cast compiler service, actual class received: ${compilerObj.javaClass}"")
+
+    public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
+
+        val outStrm = RemoteOutputStreamServer(out)
+        try {
+            return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN, outStrm)
         }
+        finally {
+            outStrm.disconnect()
+        }
+    }
 
-        private fun connectToDaemon(compilerId: CompilerId, daemonOptions: DaemonOptions, errStream: PrintStream): Remote? {
-            try {
-                val daemon = LocateRegistry.getRegistry(""localhost"", daemonOptions.port)
-                        ?.lookup(COMPILER_SERVICE_RMI_NAME)
-                if (daemon != null)
-                    return daemon
-                errStream.println(""[daemon client] daemon not found"")
-            }
-            catch (e: ConnectException) {
-                errStream.println(""[daemon client] cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
-                // ignoring it - processing below
-            }
-            return null
+
+    // TODO: remove jvmStatic after all use sites will switch to kotlin
+    jvmStatic
+    public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, compilerOut: OutputStream, daemonOut: OutputStream): Int {
+
+        val compilerOutStreamServer = RemoteOutputStreamServer(compilerOut)
+        val daemonOutStreamServer = RemoteOutputStreamServer(daemonOut)
+        val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
+        try {
+            caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer(it.getValue()) })
+            return compiler.remoteIncrementalCompile(args, cacheServers, compilerOutStreamServer, CompileService.OutputFormat.XML, daemonOutStreamServer)
+        }
+        finally {
+            cacheServers.forEach { it.getValue().disconnect() }
+            compilerOutStreamServer.disconnect()
+            daemonOutStreamServer.disconnect()
         }
+    }
 
 
-        private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream) {
-            val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
-                val javaw = File(it, ""javaw.exe"")
-                if (javaw.exists()) javaw
-                else File(it, ""java"")
-            }
-            // TODO: add some specific environment variables to the cp and may be command line, to allow some specific startup configs
-            val args = listOf(javaExecutable.absolutePath,
-                              ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
-                       daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
-                       COMPILER_DAEMON_CLASS_FQN +
-                       daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
-                       compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
-            errStream.println(""[daemon client] starting the daemon as: "" + args.joinToString("" ""))
-            val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
-            // assuming daemon process is deaf and (mostly) silent, so do not handle streams
-            val daemon = processBuilder.start()
-
-            var isEchoRead = Semaphore(1)
-            isEchoRead.acquire()
-
-            val stdoutThread =
-                    thread {
-                        daemon.getInputStream()
-                              .reader()
-                              .forEachLine {
-                                  if (daemonOptions.startEcho.isNotEmpty() && it.contains(daemonOptions.startEcho)) {
-                                      isEchoRead.release()
-                                      return@forEachLine
-                                  }
-                                  errStream.println(""[daemon] "" + it)
-                              }
-                    }
-            try {
-                // trying to wait for process
-                if (daemonOptions.startEcho.isNotEmpty()) {
-                    errStream.println(""[daemon client] waiting for daemon to respond"")
-                    val succeeded = isEchoRead.tryAcquire(DAEMON_STARTUP_TIMEOUT_MS, TimeUnit.MILLISECONDS)
-                    if (!daemon.isAlive())
-                        throw Exception(""Daemon terminated unexpectedly"")
-                    if (!succeeded)
-                        throw Exception(""Unable to get response from daemon in $DAEMON_STARTUP_TIMEOUT_MS ms"")
-                }
-                else
-                // without startEcho defined waiting for max timeout
-                    Thread.sleep(DAEMON_STARTUP_TIMEOUT_MS)
-            }
-            finally {
-                // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
-                if (stdoutThread.isAlive)
-                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
-                    stdoutThread.stop()
+    data class ClientOptions(
+            public var stop: Boolean = false
+    ) : OptionsGroup {
+        override val mappers: List<PropMapper<*, *, *>>
+            get() = listOf(BoolPropMapper(this, ::stop))
+    }
+
+
+    jvmStatic public fun main(vararg args: String) {
+        val compilerId = CompilerId()
+        val daemonOptions = DaemonOptions()
+        val daemonLaunchingOptions = DaemonJVMOptions()
+        val clientOptions = ClientOptions()
+        val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
+
+        if (!clientOptions.stop) {
+            if (compilerId.compilerClasspath.none()) {
+                // attempt to find compiler to use
+                System.err.println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
+                System.getProperty(""java.class.path"")
+                        ?.split(File.pathSeparator)
+                        ?.map { File(it).parentFile }
+                        ?.distinct()
+                        ?.map {
+                            it?.walk()
+                                    ?.firstOrNull { it.name.equals(COMPILER_JAR_NAME, ignoreCase = true) }
+                        }
+                        ?.filterNotNull()
+                        ?.firstOrNull()
+                        ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
             }
-        }
+            if (compilerId.compilerClasspath.none())
+                throw IllegalArgumentException(""Cannot find compiler jar"")
+            else
+                println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
 
-        public fun checkCompilerId(compiler: CompileService, localId: CompilerId, errStream: PrintStream): Boolean {
-            val remoteId = compiler.getCompilerId()
-            errStream.println(""[daemon client] remoteId = "" + remoteId.toString())
-            errStream.println(""[daemon client] localId = "" + localId.toString())
-            return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
-                   (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
-                   (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+            compilerId.updateDigest()
         }
 
-        public fun connectToCompileService(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, errStream: PrintStream, autostart: Boolean = true, checkId: Boolean = true): CompileService? {
-            val service = connectToService(compilerId, daemonOptions, errStream)
-            if (service != null) {
-                if (!checkId || checkCompilerId(service, compilerId, errStream)) {
-                    errStream.println(""[daemon client] found the suitable daemon"")
-                    return service
-                }
-                errStream.println(""[daemon client] compiler identity don't match: "" + compilerId.mappers.flatMap { it.toArgs("""") }.joinToString("" ""))
-                if (!autostart) return null;
-                errStream.println(""[daemon client] shutdown the daemon"")
-                service.shutdown()
-                // TODO: find more reliable way
-                Thread.sleep(1000)
-                errStream.println(""[daemon client] daemon shut down correctly, restarting"")
+        val daemon = connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, DaemonReportingTargets(out = System.out), autostart = !clientOptions.stop, checkId = !clientOptions.stop)
+
+        if (daemon == null) {
+            if (clientOptions.stop) {
+                System.err.println(""No daemon found to shut down"")
             }
-            else {
-                if (!autostart) return null;
-                else errStream.println(""[daemon client] cannot connect to Compile Daemon, trying to start"")
+            else throw Exception(""Unable to connect to daemon"")
+        }
+        else when {
+            clientOptions.stop -> {
+                println(""Shutdown the daemon"")
+                daemon.shutdown()
+                println(""Daemon shut down successfully"")
             }
+            else -> {
+                println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
+                val outStrm = RemoteOutputStreamServer(System.out)
+                try {
+                    val memBefore = daemon.getUsedMemory() / 1024
+                    val startTime = System.nanoTime()
+
+                    val res = daemon.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN, outStrm)
 
-            startDaemon(compilerId, daemonJVMOptions, daemonOptions, errStream)
-            errStream.println(""[daemon client] daemon started, trying to connect"")
-            return connectToService(compilerId, daemonOptions, errStream)
+                    val endTime = System.nanoTime()
+                    println(""Compilation result code: $res"")
+                    val memAfter = daemon.getUsedMemory() / 1024
+                    println(""Compilation time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
+                    println(""Used memory $memAfter (${""%+d"".format(memAfter - memBefore)} kb)"")
+                }
+                finally {
+                    outStrm.disconnect()
+                }
+            }
         }
+    }
 
-        public fun shutdownCompileService(daemonOptions: DaemonOptions): Unit {
-            KotlinCompilerClient.connectToCompileService(CompilerId(), DaemonJVMOptions(), daemonOptions, System.out, autostart = false, checkId = false)
-                    ?.shutdown()
+    // --- Implementation ---------------------------------------
+
+    val verboseReporting = System.getProperty(COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY) != null
+
+    fun DaemonReportingTargets.report(category: DaemonReportCategory, message: String, source: String = ""daemon client"") {
+        if (category == DaemonReportCategory.DEBUG && !verboseReporting) return
+        out?.println(""[$source] ${category.name()}: $message"")
+        messages?.add(DaemonReportMessage(category, ""[$source] $message""))
+    }
+
+    private fun tryFindDaemon(registryDir: File, compilerId: CompilerId, reportingTargets: DaemonReportingTargets): CompileService? {
+        val classPathDigest = compilerId.compilerClasspath.map { File(it).absolutePath }.distinctStringsDigest()
+        val daemons = registryDir.walk()
+                .map { Pair(it, makeRunFilenameRegex(digest = classPathDigest, port = ""(\\d+)"").match(it.name)?.groups?.get(1)?.value?.toInt() ?: 0) }
+                .filter { it.second != 0 }
+                .map {
+                    reportingTargets.report(DaemonReportCategory.DEBUG, ""found suitable daemon on port ${it.second}, trying to connect"")
+                    val daemon = tryConnectToDaemon(it.second, reportingTargets)
+                    // cleaning orphaned file; note: daemon should shut itself down if it detects that the run file is deleted
+                    if (daemon == null && !it.first.delete()) {
+                        reportingTargets.report(DaemonReportCategory.INFO, ""WARNING: unable to delete seemingly orphaned file '${it.first.absolutePath}', cleanup recommended"")
+                    }
+                    daemon
+                }
+                .filterNotNull()
+                .toList()
+        return when (daemons.size()) {
+            0 -> null
+            1 -> daemons.first()
+            else -> throw IllegalStateException(""Multiple daemons serving the same compiler, reset with the cleanup required"")
+        // TODO: consider implementing automatic recovery instead, e.g. getting the youngest or least used daemon and shut down others
         }
+    }
 
-        public fun shutdownCompileService(): Unit {
-            shutdownCompileService(DaemonOptions())
+    private fun tryConnectToDaemon(port: Int, reportingTargets: DaemonReportingTargets): CompileService? {
+        try {
+            val daemon = LocateRegistry.getRegistry(loopbackAddrName, port)
+                    ?.lookup(COMPILER_SERVICE_RMI_NAME)
+            if (daemon != null)
+                return daemon as? CompileService ?:
+                       throw ClassCastException(""Unable to cast compiler service, actual class received: ${daemon.javaClass}"")
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""daemon not found"")
+        }
+        catch (e: ConnectException) {
+            reportingTargets.report(DaemonReportCategory.EXCEPTION, ""cannot connect to registry: "" + (e.getCause()?.getMessage() ?: e.getMessage() ?: ""unknown exception""))
+            // ignoring it - processing below
         }
+        return null
+    }
 
-        public fun compile(compiler: CompileService, args: Array<out String>, out: OutputStream): Int {
 
-            val outStrm = RemoteOutputStreamServer(out)
-            try {
-                return compiler.remoteCompile(args, outStrm, CompileService.OutputFormat.PLAIN)
-            }
-            finally {
-                outStrm.disconnect()
-            }
+    private fun startDaemon(compilerId: CompilerId, daemonJVMOptions: DaemonJVMOptions, daemonOptions: DaemonOptions, reportingTargets: DaemonReportingTargets) {
+        val javaExecutable = File(System.getProperty(""java.home""), ""bin"").let {
+            val javaw = File(it, ""javaw.exe"")
+            // TODO: doesn't seem reliable enough, consider more checks if OS is of windows flavor, etc.
+            if (javaw.exists() && javaw.isFile && javaw.canExecute()) javaw else File(it, ""java"")
         }
+        val args = listOf(javaExecutable.absolutePath,
+                          ""-cp"", compilerId.compilerClasspath.joinToString(File.pathSeparator)) +
+                   daemonJVMOptions.mappers.flatMap { it.toArgs(""-"") } +
+                   COMPILER_DAEMON_CLASS_FQN +
+                   daemonOptions.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) } +
+                   compilerId.mappers.flatMap { it.toArgs(COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX) }
+        reportingTargets.report(DaemonReportCategory.DEBUG, ""starting the daemon as: "" + args.joinToString("" ""))
+        val processBuilder = ProcessBuilder(args).redirectErrorStream(true)
+        // assuming daemon process is deaf and (mostly) silent, so do not handle streams
+        val daemon = processBuilder.start()
 
-        public fun incrementalCompile(compiler: CompileService, args: Array<out String>, caches: Map<String, IncrementalCache>, out: OutputStream): Int {
+        var isEchoRead = Semaphore(1)
+        isEchoRead.acquire()
 
-            val outStrm = RemoteOutputStreamServer(out)
-            val cacheServers = hashMapOf<String, RemoteIncrementalCacheServer>()
-            try {
-                caches.mapValuesTo(cacheServers, { RemoteIncrementalCacheServer( it.getValue()) })
-                return compiler.remoteIncrementalCompile(args, cacheServers, outStrm, CompileService.OutputFormat.XML)
+        val stdoutThread =
+                thread {
+                    daemon.inputStream
+                            .reader()
+                            .forEachLine {
+                                if (daemonOptions.runFilesPath.isNotEmpty() && it.contains(daemonOptions.runFilesPath)) {
+                                    isEchoRead.release()
+                                    return@forEachLine
+                                }
+                                reportingTargets.report(DaemonReportCategory.DEBUG, it, ""daemon"")
+                            }
+                }
+        try {
+            // trying to wait for process
+            val daemonStartupTimeout = System.getProperty(COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY)?.let {
+                try {
+                    it.toLong()
+                }
+                catch (e: Exception) {
+                    reportingTargets.report(DaemonReportCategory.INFO, ""unable to interpret $COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY property ('$it'); using default timeout $DAEMON_DEFAULT_STARTUP_TIMEOUT_MS ms"")
+                    null
+                }
+            } ?: DAEMON_DEFAULT_STARTUP_TIMEOUT_MS
+            if (daemonOptions.runFilesPath.isNotEmpty()) {
+                val succeeded = isEchoRead.tryAcquire(daemonStartupTimeout, TimeUnit.MILLISECONDS)
+                if (!daemon.isAlive())
+                    throw Exception(""Daemon terminated unexpectedly"")
+                if (!succeeded)
+                    throw Exception(""Unable to get response from daemon in $daemonStartupTimeout ms"")
             }
-            finally {
-                cacheServers.forEach { it.getValue().disconnect() }
-                outStrm.disconnect()
+            else
+            // without startEcho defined waiting for max timeout
+                Thread.sleep(daemonStartupTimeout)
+        }
+        finally {
+            // assuming that all important output is already done, the rest should be routed to the log by the daemon itself
+            if (stdoutThread.isAlive) {
+                // TODO: find better method to stop the thread, but seems it will require asynchronous consuming of the stream
+                stdoutThread.stop()
             }
         }
+    }
 
-        data class ClientOptions(
-                public var stop: Boolean = false
-        ) : OptionsGroup {
-            override val mappers: List<PropMapper<*, *, *>>
-                get() = listOf( BoolPropMapper(this, ::stop))
-        }
 
-        jvmStatic public fun main(vararg args: String) {
-            val compilerId = CompilerId()
-            val daemonOptions = DaemonOptions()
-            val daemonLaunchingOptions = DaemonJVMOptions()
-            val clientOptions = ClientOptions()
-            val filteredArgs = args.asIterable().filterExtractProps(compilerId, daemonOptions, daemonLaunchingOptions, clientOptions, prefix = COMPILE_DAEMON_CMDLINE_OPTIONS_PREFIX)
-
-            if (!clientOptions.stop) {
-                if (compilerId.compilerClasspath.none()) {
-                    // attempt to find compiler to use
-                    println(""compiler wasn't explicitly specified, attempt to find appropriate jar"")
-                    System.getProperty(""java.class.path"")
-                            ?.split(File.pathSeparator)
-                            ?.map { File(it).parent }
-                            ?.distinct()
-                            ?.map {
-                                it?.walk()
-                                        ?.firstOrNull { it.getName().equals(COMPILER_JAR_NAME, ignoreCase = true) }
-                            }
-                            ?.filterNotNull()
-                            ?.firstOrNull()
-                            ?.let { compilerId.compilerClasspath = listOf(it.absolutePath) }
-                }
-                if (compilerId.compilerClasspath.none())
-                    throw IllegalArgumentException(""Cannot find compiler jar"")
-                else
-                    println(""desired compiler classpath: "" + compilerId.compilerClasspath.joinToString(File.pathSeparator))
+    private fun checkCompilerId(compiler: CompileService, localId: CompilerId): Boolean {
+        val remoteId = compiler.getCompilerId()
+        return (localId.compilerVersion.isEmpty() || localId.compilerVersion == remoteId.compilerVersion) &&
+               (localId.compilerClasspath.all { remoteId.compilerClasspath.contains(it) }) &&
+               (localId.compilerDigest.isEmpty() || remoteId.compilerDigest.isEmpty() || localId.compilerDigest == remoteId.compilerDigest)
+    }
 
-                compilerId.updateDigest()
+
+    class FileBasedLock(compilerId: CompilerId, daemonOptions: DaemonOptions) {
+        private val lockFile: File =
+                File(daemonOptions.runFilesPath,
+                     makeRunFilenameString(ts = ""lock"",
+                                           digest = compilerId.compilerClasspath.map { File(it).absolutePath }.distinctStringsDigest(),
+                                           port = ""0""))
+
+        private var locked: Boolean = acquireLockFile(lockFile)
+
+        public fun isLocked(): Boolean = locked
+
+        synchronized public fun release(): Unit {
+            if (locked) {
+                lock?.release()
+                channel?.close()
+                lockFile.delete()
+                locked = false
             }
+        }
 
-            val daemon = connectToCompileService(compilerId, daemonLaunchingOptions, daemonOptions, System.out, autostart = !clientOptions.stop, checkId = !clientOptions.stop)
+        private val channel = if (locked) RandomAccessFile(lockFile, ""rw"").channel else null
+        private val lock = channel?.lock()
 
-            if (daemon == null) {
-                if (clientOptions.stop) println(""No daemon found to shut down"")
-                else throw Exception(""Unable to connect to daemon"")
+        synchronized private fun acquireLockFile(lockFile: File): Boolean {
+            if (lockFile.createNewFile()) return true
+            try {
+                // attempt to delete if file is orphaned
+                if (lockFile.delete() && lockFile.createNewFile())
+                    return true // if orphaned file deleted assuming that the probability of
             }
-            else when {
-                clientOptions.stop -> {
-                    println(""Shutdown the daemon"")
-                    daemon.shutdown()
-                    println(""Daemon shut down successfully"")
-                }
-                else -> {
-                    println(""Executing daemon compilation with args: "" + filteredArgs.joinToString("" ""))
-                    val outStrm = RemoteOutputStreamServer(System.out)
-                    try {
-                        val memBefore = daemon.getUsedMemory() / 1024
-                        val startTime = System.nanoTime()
-                        val res = daemon.remoteCompile(filteredArgs.toArrayList().toTypedArray(), outStrm, CompileService.OutputFormat.PLAIN)
-                        val endTime = System.nanoTime()
-                        println(""Compilation result code: $res"")
-                        val memAfter = daemon.getUsedMemory() / 1024
-                        println(""Compilation time: "" + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + "" ms"")
-                        println(""Used memory $memAfter (${""%+d"".format(memAfter - memBefore)} kb)"")
-                    }
-                    finally {
-                        outStrm.disconnect()
-                    }
-                }
+            catch (e: IOException) {
+                // Ignoring it - assuming it is another client process owning it
             }
+            var attempts = 0L
+            while (lockFile.exists() && attempts++ * COMPILE_DAEMON_STARTUP_LOCK_TIMEOUT_CHECK_MS < COMPILE_DAEMON_STARTUP_LOCK_TIMEOUT_MS) {
+                Thread.sleep(COMPILE_DAEMON_STARTUP_LOCK_TIMEOUT_CHECK_MS)
+            }
+            if (lockFile.exists())
+                throw IOException(""Timeout waiting the release of the lock file '${lockFile.absolutePath}"")
+
+            return lockFile.createNewFile()","Can't we replace it with something like that:

``` kotlin
do {
    if (lockFile.createNewFile()) return true
    Thread.sleep(...)
} while (!timeout)

throw timeout exception
```

It is better because the function has only two cases: return or exception. Now we have true/false/exception
",I think it would be better to use `TimeUnit.MILLISECONDS.toMillis(DAEMON_DEFAULT_STARTUP_TIMEOUT_MS)` 
702,"@@ -18,64 +18,89 @@ package org.jetbrains.kotlin.gradle.plugin
 
 import org.gradle.BuildAdapter
 import org.gradle.BuildResult
+import org.gradle.api.invocation.Gradle
 import org.gradle.api.logging.Logging
 import java.lang.ref.Reference
 import java.util.concurrent.ScheduledExecutorService
+import kotlin.text.MatchGroup
 
-class FinishBuildListener(var pluginClassLoader: ParentLastURLClassLoader?) : BuildAdapter() {
+internal fun getUsedMemoryKb(): Long {
+    System.gc()
+    val rt = Runtime.getRuntime()
+    return (rt.totalMemory() - rt.freeMemory()) / 1024
+}
+
+
+private fun comparableVersionStr(version: String) =
+        ""(\\d+)\\.(\\d+).*""
+                .toRegex()
+                .match(version)
+                ?.groups
+                ?.drop(1)?.take(2)
+                // checking if two subexpression groups are found and length of each is >0 and <4
+                ?.let { if (it.all { (it?.value?.length() ?: 0).let { it > 0 && it < 4 }}) it else null }
+                ?.map { ""%3s"".format(it?.value ?: 0).replace(' ', '0') }
+                ?.joinToString(""."")","We can omit some of safe calls using `filterNotNull` and `padStart` trick:

``` kotlin
private fun comparableVersionStr(version: String) =
        ""(\\d+)\\.(\\d+).*""
                .toRegex()
                .match(version)
                ?.groups
                ?.drop(1)?.take(2)
                ?.filterNotNull()
                // checking if two subexpression groups are found and length of each is >0 and <4
                ?.let { if (it.size() == 2 && it.all { it.value.length() in 1..3 }) it else null }
                ?.map { it.value.padStart(3, '0') }
                ?.joinToString(""."")
```
",I'm not sure if this is the best way to do this. I think it would be better to use the `KotlinVersion`
703,"@@ -18,72 +18,118 @@
 
 package kotlin
 
+/** A function that takes 0 arguments. */
 public trait Function0<out R> {
+    /** Invokes the function with the specified arguments. */","no arguments
",/** A function that takes 0 arguments. */
704,"@@ -18,72 +18,118 @@
 
 package kotlin
 
+/** A function that takes 0 arguments. */
 public trait Function0<out R> {
+    /** Invokes the function with the specified arguments. */
     public fun invoke(): R
 }
+/** A function that takes 1 arguments. */","plural use for 1
",This should be `Function0<R>`.
705,"@@ -18,72 +18,118 @@
 
 package kotlin
 
+/** An extension function that takes 0 arguments. */
 public trait ExtensionFunction0<in T, out R> {
+    /** Invokes the function with the specified arguments. */","There are no arguments, so just ""Invokes the function""
",This should be `ExtensionFunct
706,"@@ -18,72 +18,118 @@
 
 package kotlin
 
+/** An extension function that takes 0 arguments. */
 public trait ExtensionFunction0<in T, out R> {
+    /** Invokes the function with the specified arguments. */
     public fun T.invoke(): R
 }
+/** An extension function that takes 1 arguments. */","""argument"", no ""s""
",This should be `ExtensionFunct
707,"@@ -181,7 +183,7 @@ object TopDownAnalyzerFacadeForJVM {
         // TODO: get rid of duplicate invocation of CodeAnalyzerInitializer#initialize, or refactor CliLightClassGenerationSupport
         val container = createContainerForTopDownAnalyzerForJvm(
                 moduleContext, trace, declarationProviderFactory(storageManager, files), sourceScope, lookupTracker,
-                partProvider, moduleClassResolver, jvmTarget, languageVersionSettings
+                partProvider, moduleClassResolver, jvmTarget, languageVersionSettings, useJavac",Not to this PR but just to note: this TODO above should be handled somehow,">useJavac [](start = 28, lengt"
708,"@@ -1839,6 +1844,14 @@
                      language=""kotlin""
     />
 
+    <localInspection implementationClass=""org.jetbrains.kotlin.idea.intentions.RemoveEmptyClassBodyInspection""
+                     displayName=""Replace empty class body""
+                     groupName=""Kotlin""
+                     enabledByDefault=""true""
+                     level=""WARNING""","There is nothing bad about an empty class body, so this should be severity INFO, not WARNING
",I don't think this is needed.
709,"@@ -184,6 +184,22 @@ public inline fun <K> BooleanArray.groupByTo(result: MutableMap<K, MutableList<B
 }
 
 /**
+ * Returns first index of item, or -1 if the array does not contain item
+ */
+public fun BooleanArray.indexOf(item : Boolean) : Int {
+    if (item == null) {","Value of 'Boolean' type cannot be 'null' in Kotlin.
",Why not just `return -1;`?
710,"@@ -185,6 +169,15 @@ object LightClassUtil {
         return null
     }
 
+    private fun getWrappingClasses(declaration: KtDeclaration): List<PsiClass> {","You can simplify this code by changing the return type to `Sequence<PsiClass>` and using `generateSequence()`
",
711,"@@ -186,6 +187,14 @@ class K2JVMCompiler : CLICompiler<K2JVMCompilerArguments>() {
                 val environment = createEnvironmentWithScriptingSupport(rootDisposable, configuration, arguments, messageCollector)
                                   ?: return COMPILATION_ERROR
 
+                if (arguments.useJavac) {",Looks like this if / else is better to be moved above (just before environment definition). It's more consistent with previous code.,Why do we need this?
712,"@@ -186,6 +187,14 @@ class K2JVMCompiler : CLICompiler<K2JVMCompilerArguments>() {
                 val environment = createEnvironmentWithScriptingSupport(rootDisposable, configuration, arguments, messageCollector)
                                   ?: return COMPILATION_ERROR
 
+                if (arguments.useJavac) {
+                    environment.configuration.put(JVMConfigurationKeys.USE_JAVAC, true)
+                    environment.registerJavac(outDir = File(destination),
+                                              messageCollector = messageCollector,
+                                              arguments = arguments.javacArguments)
+                }
+                else environment.configuration.put(JVMConfigurationKeys.USE_JAVAC, false)",Use {} here,Why do we need this?
713,"@@ -187,5 +185,26 @@ fun arrays(): List<GenericFunction> {
         }
     }
 
+    templates add f(""nullIfEmpty()"") {
+        only(ArraysOfObjects, ArraysOfPrimitives, Collections)
+        doc { f ->
+            """"""
+            Returns `this` value if it is not empty or `null`, if it is.
+
+            ${if (f == ArraysOfObjects || f == ArraysOfPrimitives)
+                ""@sample samples.collections.Arrays.nullIfEmpty""
+            else if (f == Collections)
+                ""@sample samples.collections.Collections.nullIfEmpty""
+            else
+                """"
+            }
+            """"""
+        }
+        returns(""SELF?"")
+        body {
+            ""return if (this == null || this.isEmpty()) null else this""","`this == null` 
^ expression is always false",I'm not sure if this is the be
714,"@@ -1893,7 +1893,7 @@ public inline fun String.lastOrNull(predicate: (Char) -> Boolean): Char? {
 }
 
 /**
- * Returns single element, or throws exception if there is no or more than one element
+ * Returns the single element, or throws an exception if if the collection is empty or has more than one element.","if if
",I don't think this is correct.
715,"@@ -19,18 +19,39 @@ package kotlin.jvm
 import java.lang.annotation.Retention
 import java.lang.annotation.RetentionPolicy
 
+/**
+ * Marks the JVM backing field of the annotated property as `volatile`, meaning that it can
+ * be modified asynchronously by concurrently running threads.","""can be modified async"" is strange wording. Even if field is not volatile, you still can modify it async by concurrent threads, but effect may be different. Need better description.
",I don't think we need this.
716,"@@ -19,6 +19,7 @@ package org.jetbrains.kotlin.codegen
 import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
 import org.jetbrains.kotlin.psi.KtExpression
 import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
+import org.jetbrains.kotlin.codegen.binding.CodegenBinding.*","Unused import
",import java.util.*;
717,"@@ -195,6 +195,7 @@ enum class TraversalOrder {
     BACKWARD
 }
 
+",Remove me,
718,"@@ -195,6 +205,11 @@ class K2JVMCompiler : CLICompiler<K2JVMCompilerArguments>() {
                 }
 
                 KotlinToJVMBytecodeCompiler.compileBunchOfSources(environment)
+
+                if (arguments.useJavac) {
+                    val success = JavacWrapper.getInstance(environment.project).use(JavacWrapper::compile)
+                    if (!success) return COMPILATION_ERROR
+                }",And this code should also be performed for previous branches,Why do we need this?
719,"@@ -198,6 +202,8 @@
             <fileset dir=""compiler/builtins-serializer/src""/>
             <fileset dir=""compiler/cli/src""/>
             <fileset dir=""compiler/cli/cli-common/src""/>
+            <include name=""compiler/rmi/rmi-server/src""/>
+            <include name=""compiler/rmi/rmi-interface/src""/>","Other lines here use `<fileset dir=...>`
",Why is this needed?
720,"@@ -199,6 +199,22 @@ public inline fun <T, K> Array<out T>.groupByTo(result: MutableMap<K, MutableLis
 }
 
 /**
+ * Returns first index of item, or -1 if the array does not contain item
+ */
+public fun <T> Array<out T>.indexOf(item : T) : Int {","We usually don't add space before colon in parameters list
",This should be `public int IndexOf(T item)`
721,"@@ -199,6 +199,22 @@ public inline fun <T, K> Array<out T>.groupByTo(result: MutableMap<K, MutableLis
 }
 
 /**
+ * Returns first index of item, or -1 if the array does not contain item
+ */
+public fun <T> Array<out T>.indexOf(item : T) : Int {
+    if (item == null) {","Why do you need to handle 'item==null' case separately? '==' operator works properly with nulls.
",Why not just `Array<T>.IndexOf(T item)`?
722,"@@ -199,6 +199,22 @@ public inline fun <T, K> Array<out T>.groupByTo(result: MutableMap<K, MutableLis
 }
 
 /**
+ * Returns first index of item, or -1 if the array does not contain item
+ */
+public fun <T> Array<out T>.indexOf(item : T) : Int {
+    if (item == null) {
+        for (i in 0..size - 1) if (this[i] == null) {","size-1 can be replaced by lastIndex.
",I think this should be `this[i]` instead of
723,"@@ -2,36 +2,65 @@ package kotlin.concurrent
 
 import java.util.concurrent.*
 
+/**
+ * Return the current thread.","Returns
",
724,"@@ -20,6 +20,15 @@ package kotlin.script.dependencies
 
 import java.io.File
 
+// discuss
+
+// Currently File is used to disambiguate between plain strings and paths
+// One of the ideas is to use java.nio.Path but this requires JDK 7
+// that means that script templates would require higher JDK (but since script are run by calling koltinc it seems ok to me after consideration)",I think requiring JDK 8 in scripts is fine,I don't think this is the right way to do t
725,"@@ -20,6 +20,15 @@ package kotlin.script.dependencies
 
 import java.io.File
 
+// discuss
+
+// Currently File is used to disambiguate between plain strings and paths
+// One of the ideas is to use java.nio.Path but this requires JDK 7
+// that means that script templates would require higher JDK (but since script are run by calling koltinc it seems ok to me after consideration)
+// Andrey expressed the idea that File (or Path) does not support other protocols, should we use URL/URI? (is it viable to support non-file protocols in compiler and IDE?)","> File (or Path) does not support other protocols

Path _does_ support other protocols AFAIK. You can create a custom `java.nio.file.FileSystem` and resolve paths within that file system.",I don't think this is the right way to do t
726,"@@ -20,6 +20,15 @@ package kotlin.script.dependencies
 
 import java.io.File
 
+// discuss
+
+// Currently File is used to disambiguate between plain strings and paths
+// One of the ideas is to use java.nio.Path but this requires JDK 7
+// that means that script templates would require higher JDK (but since script are run by calling koltinc it seems ok to me after consideration)
+// Andrey expressed the idea that File (or Path) does not support other protocols, should we use URL/URI? (is it viable to support non-file protocols in compiler and IDE?)
+//
+// Explicitly references javaHome, what if it's not a jvm targeted script?
+// Currently it's convenient for IDE code and for the user because including jdk classes in classpath is a mess
 data class ScriptDependencies(",What's the difference between `sources` and `scripts`?,I don't think it's a good idea to use URL/U
727,"@@ -20,6 +20,15 @@ package kotlin.script.dependencies
 
 import java.io.File
 
+// discuss
+
+// Currently File is used to disambiguate between plain strings and paths
+// One of the ideas is to use java.nio.Path but this requires JDK 7
+// that means that script templates would require higher JDK (but since script are run by calling koltinc it seems ok to me after consideration)
+// Andrey expressed the idea that File (or Path) does not support other protocols, should we use URL/URI? (is it viable to support non-file protocols in compiler and IDE?)
+//
+// Explicitly references javaHome, what if it's not a jvm targeted script?
+// Currently it's convenient for IDE code and for the user because including jdk classes in classpath is a mess
 data class ScriptDependencies(
         val javaHome: File? = null,","What is `javaHome`: is it required to be a path to the JDK, or a path to the JRE is enough?",I'm not sure if this is the right way to do
728,"@@ -20,6 +20,15 @@ package kotlin.script.dependencies
 
 import java.io.File
 
+// discuss
+
+// Currently File is used to disambiguate between plain strings and paths
+// One of the ideas is to use java.nio.Path but this requires JDK 7
+// that means that script templates would require higher JDK (but since script are run by calling koltinc it seems ok to me after consideration)
+// Andrey expressed the idea that File (or Path) does not support other protocols, should we use URL/URI? (is it viable to support non-file protocols in compiler and IDE?)
+//
+// Explicitly references javaHome, what if it's not a jvm targeted script?
+// Currently it's convenient for IDE code and for the user because including jdk classes in classpath is a mess
 data class ScriptDependencies(
         val javaHome: File? = null,
         val classpath: List<File> = emptyList(),","Can we use here directories/jars/individual files? 
Maybe it's worth to document it somewhere",I'm not sure this is the right way to do th
729,"@@ -200,4 +201,13 @@ public static PsiElement createPrimaryConstructor(Project project) {
         JetClass aClass = createClass(project, ""class A()"");
         return aClass.findElementAt(7).getParent();
     }
+
+    public static JetSimpleNameExpression createClassLabel(Project project, @NotNull String labelName) {
+        JetThisExpression expression = (JetThisExpression) createExpression(project, ""this@"" + labelName);
+        return expression.getTargetLabel();
+    }
+
+    public static JetExpression createFieldIdentifier(Project project, @NotNull String fieldName) {
+        return createExpression(project, ""$"" + fieldName);
+    }","Maybe this one will be final :)
","`createExpression(project, ""this@"" + fieldN"
730,"@@ -200,4 +202,14 @@ public static PsiElement createPrimaryConstructor(Project project) {
         JetClass aClass = createClass(project, ""class A()"");
         return aClass.findElementAt(7).getParent();
     }
+
+    public static PsiElement createClassLabel(Project project, @NotNull String labelName) {
+        JetExpression expression = createExpression(project, ""this@"" + labelName);
+        return expression.getLastChild();","However I have one question: in current variant org.jetbrains.jet.JetNodeTypes#LABEL_QUALIFIER returned - this is normal that org.jetbrains.jet.lexer.JetTokens#FIELD_IDENTIFIER replaced by org.jetbrains.jet.JetNodeTypes#LABEL_QUALIFIER?
",Why do we need this?
731,"@@ -200,4 +202,14 @@ public static PsiElement createPrimaryConstructor(Project project) {
         JetClass aClass = createClass(project, ""class A()"");
         return aClass.findElementAt(7).getParent();
     }
+
+    public static PsiElement createClassLabel(Project project, @NotNull String labelName) {
+        JetExpression expression = createExpression(project, ""this@"" + labelName);
+        return expression.getLastChild();
+    }
+
+    public static PsiElement createFieldIdentifier(Project project, @NotNull String fieldName) {
+        JetExpression expression = createExpression(project, ""$"" + fieldName);
+        return expression.getFirstChild();","Much nice
",Why do we need this method?
732,"@@ -200,4 +202,19 @@ public static PsiElement createPrimaryConstructor(Project project) {
         JetClass aClass = createClass(project, ""class A()"");
         return aClass.findElementAt(7).getParent();
     }
+
+    public static PsiElement createClassLabel(Project project, @NotNull String labelName) {
+        final String labelTemplate = ""class {0}()'{' fun aFun()'{' this@{0}'}'}"";
+        JetClass aClass = createClass(project, MessageFormat.format(labelTemplate, labelName));
+        final int offset = 18;    // @labelName
+        return aClass.getBody().findElementAt(offset);
+    }
+
+    public static PsiElement createFieldIdentifier(Project project, @NotNull String fieldName){
+        final String labelTemplate = ""class aClass()'{'var {0}:Int=0;set(value)'{'${0}'} '}"";
+        JetClass aClass = createClass(project, MessageFormat.format(labelTemplate, fieldName));
+        final JetDeclaration declaration = aClass.getBody().getDeclarations().get(0);
+        final int offset = 11;   // $fieldName
+        return declaration.getLastChild().findElementAt(offset);","Ok, now it looks better
",This should be `createFieldIdentifier`.
733,"@@ -205,7 +241,9 @@ public inline fun <K, V> Map<K, V>.filterValues(predicate: (V) -> Boolean): Map<
 
 
 /**
- * Appends all elements matching the given *predicate* into the given *destination*
+ * Appends all entries matching the given [predicate] into the given [destination] mutable map.","""[destination] mutable map."", looks confusing a bit.
",I think this should be `mutable map` instea
734,"@@ -209,7 +209,7 @@ public void generateMethod(
             generateMethodBody(mv, functionDescriptor, methodContext, jvmSignature, strategy, memberCodegen);
         }
         else if (staticInCompanionObject) {
-            // native platformStatic foo() in companion object should delegate to the static native function moved to the outer class
+            // native @JvmStatic foo() in companion object should delegate to the static native function moved to the outer class
             mv.visitCode();
             FunctionDescriptor staticFunctionDescriptor = PlatformStaticGenerator.createStaticFunctionDescriptor(functionDescriptor);","rename `PlatformStaticGenerator` -> `JvmStaticGenerator`?
",I think this should be `@PlatformStatic`
735,"@@ -21,15 +21,18 @@ private object EmptyMap : Map<Any, Any> {
 /** Returns an empty read-only map of specified type */
 public fun emptyMap<K, V>(): Map<K, V> = EmptyMap as Map<K, V>
 
-/** Returns a new read-only map of given pairs, where the first value is the key, and the second is value */
+/**
+ * Returns a new read-only map with the specified contents, given as a list of pairs
+ * where the first value is the key and the second is the value.
+ */","specify, that it behaves as sequential `put` calls, so that if conflicting keys exist in source sequence, last one wins.
",I'm not sure if this is the right way to do
736,"@@ -21,17 +21,30 @@ import com.intellij.psi.search.GlobalSearchScope
 import org.jetbrains.kotlin.builtins.BuiltInSerializerProtocol
 import org.jetbrains.kotlin.cli.jvm.index.JavaRoot
 import org.jetbrains.kotlin.cli.jvm.index.JvmDependenciesIndex
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.impl.JavaClassImpl
+import org.jetbrains.kotlin.load.kotlin.KotlinJvmBinaryClass
 import org.jetbrains.kotlin.load.kotlin.VirtualFileFinder
 import org.jetbrains.kotlin.name.ClassId
 import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.name.Name
 import org.jetbrains.kotlin.serialization.deserialization.MetadataPackageFragment
+import org.jetbrains.kotlin.wrappers.trees.computeClassId
 import java.io.InputStream
 
 class CliVirtualFileFinder(
         private val index: JvmDependenciesIndex,
         private val scope: GlobalSearchScope
 ) : VirtualFileFinder() {
+
+    override fun findKotlinClass(javaClass: JavaClass): KotlinJvmBinaryClass? {
+        if (javaClass !is JavaClassImpl) {
+            return javaClass.computeClassId()?.let(this::findKotlinClass) ?: return null",This `return null` is unnecessary,I don't think this is the right place for this method. It should be in `KotlinJvmBinaryClass`.
737,"@@ -21,17 +21,31 @@ import com.intellij.psi.search.GlobalSearchScope
 import org.jetbrains.kotlin.builtins.BuiltInSerializerProtocol
 import org.jetbrains.kotlin.cli.jvm.index.JavaRoot
 import org.jetbrains.kotlin.cli.jvm.index.JvmDependenciesIndex
+import org.jetbrains.kotlin.load.java.structure.JavaClass
+import org.jetbrains.kotlin.load.java.structure.impl.JavaClassImpl
+import org.jetbrains.kotlin.load.java.structure.impl.classFiles.BinaryJavaClass
+import org.jetbrains.kotlin.load.kotlin.KotlinJvmBinaryClass
 import org.jetbrains.kotlin.load.kotlin.VirtualFileFinder
 import org.jetbrains.kotlin.name.ClassId
 import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.name.Name
 import org.jetbrains.kotlin.serialization.deserialization.MetadataPackageFragment
+import org.jetbrains.kotlin.wrappers.trees.computeClassId
 import java.io.InputStream
 
 class CliVirtualFileFinder(
         private val index: JvmDependenciesIndex,
         private val scope: GlobalSearchScope
 ) : VirtualFileFinder() {
+
+    override fun findKotlinClass(javaClass: JavaClass): KotlinJvmBinaryClass? {
+        if (javaClass !is JavaClassImpl && javaClass !is BinaryJavaClass) {
+            return javaClass.computeClassId()?.let(this::findKotlinClass)",I think you should create a custom KotlinJvmBinaryClass implementation here: there's no need to look up the class that is already found and passed in the argument,I'm not sure if this is the right place for this method. I think it should be in `KotlinJvmBin
738,"@@ -21,5 +21,6 @@
     <orderEntry type=""module"" module-name=""tests-common"" scope=""TEST"" />
     <orderEntry type=""module"" module-name=""idea-core"" />
     <orderEntry type=""module"" module-name=""lint-idea"" scope=""TEST"" />
+    <orderEntry type=""module"" module-name=""light-classes"" />","Try to avoid light classes, some explanation below","<orderEntry type=""module"" module-name=""light-classes"" />"
739,"@@ -21,6 +21,24 @@ package kotlin.script.dependencies
 import java.io.File
 import kotlin.script.dependencies.DependenciesResolver.ResolveResult
 
+//discuss
+
+// Provides api to discover dependencies of scripts
+// Dependencies can be content-dependent
+//
+// Some concerns on naming:
+// Environment -> ScriptEnvironment (top level class with too common a name)
+// ResolveResult -> ResolutionResult",+1 for ResolutionResult,I think it would be better to use `kotlin.script.dependencies.DependenciesResolver.Environment
740,"@@ -21,6 +21,24 @@ package kotlin.script.dependencies
 import java.io.File
 import kotlin.script.dependencies.DependenciesResolver.ResolveResult
 
+//discuss
+
+// Provides api to discover dependencies of scripts
+// Dependencies can be content-dependent
+//
+// Some concerns on naming:
+// Environment -> ScriptEnvironment (top level class with too common a name)
+// ResolveResult -> ResolutionResult
+//
+// Admittedly DependenciesResolver is too generic a name, but ScriptDependenciesResolver is already taken by deprecated interface
+// My guess is script.runtime.jar is not gonna be used as application wide dependency in users project (like stdlib)
+// but rather as a dependency for a module that contains DependenciesResolver implementation so maybe this is a non-problem
+//
+// ResolveResult contains resulting dependencies and reports (diagnostics?)
+// reports may contain errors (regardless of result being Success or Failure) which is gonna lead to compiler error and script not run/error highlighting in IDE.
+// Is this semantic reasonable? Are Success and Failure misleading names?
+// Main idea behind Failure is to be able to distinguish between scenarios where resolver could or could not return meaningful ScriptDependencies object.
+// For example, IDE can avoid repainting all external references as errors when Resolver threw an exception or is in inconsistent state.
 typealias Environment = Map<String, Any?>
 
 interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesResolver {",`DependencyResolver` instead of `DependenciesResolver`,I don't think we need to mention `stdlib` here.
741,"@@ -211,6 +220,25 @@ class K2JVMCompiler : CLICompiler<K2JVMCompilerArguments>() {
         }
     }
 
+    private fun registerJavacIfNeeded(environment: KotlinCoreEnvironment,
+                                      arguments: K2JVMCompilerArguments,
+                                      messageCollector: MessageCollector) {
+        if (arguments.useJavac) {
+            environment.configuration.put(JVMConfigurationKeys.USE_JAVAC, true)
+            environment.registerJavac(messageCollector = messageCollector,
+                                      arguments = arguments.javacArguments)
+        } else {
+            environment.configuration.put(JVMConfigurationKeys.USE_JAVAC, false)",There's no need to put `false` as the configuration value if you're using `getBoolean` at call sites,nit: `fun` -> `function`
742,"@@ -212,11 +212,12 @@ fun createSpacingBuilder(settings: CodeStyleSettings, builderUtil: KotlinSpacing
             afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)
             beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)
 
-            betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)
-            betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)
-            betweenInside(WHILE_KEYWORD, LPAR, WHILE).spacing(1, 1, 0, false, 0)
-            betweenInside(WHILE_KEYWORD, LPAR, DO_WHILE).spacing(1, 1, 0, false, 0)
-            betweenInside(WHEN_KEYWORD, LPAR, WHEN).spacing(1, 1, 0, false, 0)
+            betweenInside(FOR_KEYWORD, LPAR, FOR).lineBreakOrForceSpace(false, kotlinCommonSettings.SPACE_BEFORE_FOR_PARENTHESES)","There is never a line break in these locations, so you should better use `spaceIf`.",Why do we need this?
743,"@@ -214,21 +214,32 @@ public static void addTypeAnnotation(Project project, JetParameter parameter, @N
         ReferenceToClassesShortening.compactReferenceToClasses(Collections.singletonList(parameter));
     }
 
-    private static void removeTypeAnnotation(@NotNull JetNamedDeclaration property, @Nullable JetTypeReference typeReference) {
+    private static void removeTypeAnnotation(@NotNull PsiElement removeAfter, @Nullable JetTypeReference typeReference) {","I don't love name 'removeAfter' but I didn't come up with anything better.
",`removeAfter` -> `removeAfter`
744,"@@ -2165,6 +2183,9 @@ public fun Iterable<Int>.sum(): Int {
  */
 @kotlin.jvm.JvmName(""sumOfLong"")
 public fun Iterable<Long>.sum(): Long {
+    if (this is LongProgression) {
+        return (this.first + this.last) * this.count() / 2",Is this as overflow safe as the old approach? `(this.first + this.last) * this.count()` might overflow when `(this.first + this.last) * (this.count() / 2)` wouldn't.,I think it would be better to use `this.count() / 2`.
745,"@@ -217,14 +255,16 @@ public inline fun <K, V, C : MutableMap<K, V>> Map<K, V>.filterTo(destination: C
 }
 
 /**
- * Returns a map containing all key-value pairs matching the given *predicate*
+ * Returns a map containing all key-value pairs matching the given [predicate].","Returns a _new_ map
",I don't think we need the `[` here.
746,"@@ -217,6 +216,34 @@ class KotlinCoreEnvironment private constructor(
         project.registerService(VirtualFileFinderFactory::class.java, finderFactory)
     }
 
+    // Maybe there is another way to obtain all java files
+    private val VirtualFile.javaFiles: List<VirtualFile>","This is rather inefficient because it creates a lot of lists. Try something like this:
```
    private val VirtualFile.javaFiles: List<VirtualFile>
        get() = mutableListOf<VirtualFile>().apply {
            VfsUtilCore.processFilesRecursively(this@javaFiles) { file ->
                if (file.fileType == JavaFileType.INSTANCE) {
                    add(file)
                }
                true
            }
        }
```
",I don't think this is the right way to obtain java files.
747,"@@ -217,6 +216,34 @@ class KotlinCoreEnvironment private constructor(
         project.registerService(VirtualFileFinderFactory::class.java, finderFactory)
     }
 
+    // Maybe there is another way to obtain all java files
+    private val VirtualFile.javaFiles: List<VirtualFile>
+        get() = children.filter { it.extension == ""java"" }
+                .toMutableList()
+                .apply {
+                    children
+                            .filter(VirtualFile::isDirectory)
+                            .forEach { dir -> addAll(dir.javaFiles) }
+                }
+
+    private val javaFiles",`allJavaFiles` maybe?,I don't think this is the right way to obtain all java files.
748,"@@ -217,6 +216,34 @@ class KotlinCoreEnvironment private constructor(
         project.registerService(VirtualFileFinderFactory::class.java, finderFactory)
     }
 
+    // Maybe there is another way to obtain all java files
+    private val VirtualFile.javaFiles: List<VirtualFile>
+        get() = children.filter { it.extension == ""java"" }
+                .toMutableList()
+                .apply {
+                    children
+                            .filter(VirtualFile::isDirectory)
+                            .forEach { dir -> addAll(dir.javaFiles) }
+                }
+
+    private val javaFiles
+        get() = configuration.kotlinSourceRoots
+                .mapNotNull(this::findLocalDirectory)
+                .flatMap { it.javaFiles }
+                .map { File(it.canonicalPath) }
+
+    fun registerJavac(files: List<File> = javaFiles,
+                      kotlinFiles: List<KtFile> = sourceFiles,
+                      messageCollector: MessageCollector? = null,
+                      arguments: Array<String>? = null) {
+        projectEnvironment.project.registerService(JavacWrapper::class.java, JavacWrapper(files,",Please fix formatting here,Why do we need this? Can't we just use `VirtualFile.javaFiles`?
749,"@@ -2180,6 +2180,14 @@
                      language=""kotlin""
     />
 
+    <localInspection implementationClass=""org.jetbrains.kotlin.idea.inspections.MemberVisibilityCanPrivateInspection""
+                     displayName=""Can have 'private' visibility""","Better to show a more full name here: ""Class member can have 'private' visibility""",
750,"@@ -22,13 +22,11 @@ import org.jetbrains.kotlin.descriptors.PropertyAccessorDescriptor
 import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
 import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
 import org.jetbrains.kotlin.descriptors.annotations.Annotations
-import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.resolve.DescriptorUtils
 
 public fun DeclarationDescriptor.hasPlatformStaticAnnotation(): Boolean {","`hasJvmStaticAnnotation`?
",Why did you remove this?
751,"@@ -22,13 +22,28 @@ import kotlin.reflect.KClass
 import kotlin.script.dependencies.DependenciesResolver.NoDependencies
 import kotlin.script.dependencies.ScriptDependenciesResolver
 
+// discuss",Maybe move this file to package `kotlin.script.annotations`? To leave `kotlin.script.templates` for actual templates only,
752,"@@ -22,13 +22,28 @@ import kotlin.reflect.KClass
 import kotlin.script.dependencies.DependenciesResolver.NoDependencies
 import kotlin.script.dependencies.ScriptDependenciesResolver
 
+// discuss
+
+// One of the requests is to allow to share compiler args via script templates: https://youtrack.jetbrains.com/issue/KT-19120
+// Making it a property of ScriptTemplateDefinition is a viable options but it doesn't allow to changes compiler arguments based on script content.
+// For example, it could be possible to allow file level annotation and use it like:
+// @file: ExtraCompilerArgs(""-enableWhatever"")","I think it's fine if we don't support extra compiler arguments based on script content now. If this becomes really needed, we can support it in the future, e.g. with an annotation like you mentioned here.",I think it would be good to add a link to the Jetbrains issue here.
753,"@@ -22,13 +22,28 @@ import kotlin.reflect.KClass
 import kotlin.script.dependencies.DependenciesResolver.NoDependencies
 import kotlin.script.dependencies.ScriptDependenciesResolver
 
+// discuss
+
+// One of the requests is to allow to share compiler args via script templates: https://youtrack.jetbrains.com/issue/KT-19120
+// Making it a property of ScriptTemplateDefinition is a viable options but it doesn't allow to changes compiler arguments based on script content.
+// For example, it could be possible to allow file level annotation and use it like:
+// @file: ExtraCompilerArgs(""-enableWhatever"")
+
 const val DEFAULT_SCRIPT_FILE_PATTERN = "".*\\.kts""
 
+// classes annotated with ScriptTemplateDefinition become script templates.
+// examples: https://github.com/JetBrains/kotlin/blob/5faad493b4cf7bf33bf82475e966a99a8e835720/compiler/tests/org/jetbrains/kotlin/scripts/ScriptTemplateTest.kt#L564-L601
 @Target(AnnotationTarget.CLASS)
 @Retention(AnnotationRetention.RUNTIME)
 annotation class ScriptTemplateDefinition(val resolver: KClass<out ScriptDependenciesResolver> = NoDependencies::class,
                                           val scriptFilePattern: String = DEFAULT_SCRIPT_FILE_PATTERN)","Do we need `scriptFilePattern` in this restricted form at all? 
- IDE uses `ScriptTemplatesProvider.filePattern` that allows to determine scripts without loading script definition annotation.
- There might be scripts of different kind that differentiate by full path or maybe content.",I think it would be good to link to the JetBrains issue here.
754,"@@ -22,13 +22,28 @@ import kotlin.reflect.KClass
 import kotlin.script.dependencies.DependenciesResolver.NoDependencies
 import kotlin.script.dependencies.ScriptDependenciesResolver
 
+// discuss
+
+// One of the requests is to allow to share compiler args via script templates: https://youtrack.jetbrains.com/issue/KT-19120
+// Making it a property of ScriptTemplateDefinition is a viable options but it doesn't allow to changes compiler arguments based on script content.
+// For example, it could be possible to allow file level annotation and use it like:
+// @file: ExtraCompilerArgs(""-enableWhatever"")
+
 const val DEFAULT_SCRIPT_FILE_PATTERN = "".*\\.kts""
 
+// classes annotated with ScriptTemplateDefinition become script templates.
+// examples: https://github.com/JetBrains/kotlin/blob/5faad493b4cf7bf33bf82475e966a99a8e835720/compiler/tests/org/jetbrains/kotlin/scripts/ScriptTemplateTest.kt#L564-L601
 @Target(AnnotationTarget.CLASS)
 @Retention(AnnotationRetention.RUNTIME)
 annotation class ScriptTemplateDefinition(val resolver: KClass<out ScriptDependenciesResolver> = NoDependencies::class,
                                           val scriptFilePattern: String = DEFAULT_SCRIPT_FILE_PATTERN)
 
+// usage example: https://github.com/JetBrains/kotlin/blob/88652154c96402475d42ae0496ab0b423cc0a2b2/libraries/tools/kotlin-script-util/src/main/kotlin/org/jetbrains/kotlin/script/util/resolve.kt#L42-L42","I'm confused, why is this needed? Can't the DependenciesResolver implementation just filter out the unneeded annotations from ScriptContents.annotations?",I think it would be better to use `@file: ExtraCompilerArgs` here.
755,"@@ -22,3 +22,22 @@ class FinalClass() {
 
 <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>public<!> class C
 <!INCOMPATIBLE_MODIFIERS!>private<!> <!INCOMPATIBLE_MODIFIERS!>public<!> object D
+
+class LegalModifiersInConstructorParameters(val a: Int, private var b: String, vararg v: Int)
+
+class IllegalModifiersInConstructorParameters(<!ILLEGAL_MODIFIER!>private<!> a: Int)
+
+class SecondIllegalModifiersInConstructorParameters(<!ILLEGAL_MODIFIER!>public<!> b: String)
+
+class ThirdIllegalModifiersInConstructorParameters(<!ILLEGAL_MODIFIER!>protected<!> vararg v: Int)
+
+abstract class IllegalModifiersInFunctionParameters() {
+
+  abstract fun illegalModifiersInFunctionParameters(<!ILLEGAL_MODIFIER!>public<!> a: Int, vararg v: String)
+
+  private fun illegalModifiersInCatchBlock() {
+    try {
+
+    } catch (<!ILLEGAL_MODIFIER!>public<!> e: Exception) {}
+  }
+}","You should add a test with annotation and modifier like
fun foo(deprecated(""ss"") public a: Int) 
because annotations are parsed in modifier list.

Also a test for more than one modifier on parameter is missed
",I think this should be `IllegalModifiersInCatchBlock`
756,"@@ -22,5 +22,5 @@
 public class CompilerVersion {
     // The value of this constant is generated by the build script
     // DON'T MODIFY IT
-    public static final String VERSION = ""@snapshot@"";
+    public static final String VERSION = ""snapshot"";","This will crash the build miserably.
",// DON'T MODIFY IT
757,"@@ -22,6 +22,9 @@
     <property name=""javax.inject.jar"" value=""${basedir}/lib/javax.inject.jar""/>
     <property name=""gradle.logging.level"" value=""""/>
 
+    <property environment=""env""/>
+    <property name=""tools.jar"" value=""${env.JDK_18}/lib/tools.jar""/>",Do you know if it's possible to download sources of this artifact from somewhere? This would be very useful,I don't think we need this property.
758,"@@ -220,6 +220,7 @@ add.name.to.argument.single=Add name to argument\: ''{0}''
 add.name.to.argument.multiple=Add name to argument...
 add.name.to.argument.action=Add name to argument...
 add.name.to.parameter.name.chooser.title=Choose parameter name
+get.call.replacement=Get Call Replace","That's not a good name for an intention. The name should be ""Do something"", with correct capitalization.

In such cases, always refer to existing UI elements, so the new features will be consistent with common style.
",get.call.replace=Get Call Replace
759,"@@ -225,38 +225,7 @@","ignore this file
",Why is this needed?
760,"@@ -226,6 +226,10 @@ replace.with.dot.qualified.method.call.intention=Replace with simple method call
 replace.with.dot.qualified.method.call.intention.family=Replace with simple method call
 replace.with.infix.function.call.intention=Replace with infix function call
 replace.with.infix.function.call.intention.family=Replace with infix function call
+remove.braces=Remove Braces
+remove.braces.family=Remove Braces
+add.braces=Add Braces
+add.braces.family=Add Braces","Capitalization of family name is correct, but of intention text is not. See other intentions as a reference.
",Line is too long. [83/80]
761,"@@ -226,6 +226,8 @@ replace.with.dot.qualified.method.call.intention=Replace with simple method call
 replace.with.dot.qualified.method.call.intention.family=Replace with simple method call
 replace.with.infix.function.call.intention=Replace with infix function call
 replace.with.infix.function.call.intention.family=Replace with infix function call
+replace.with.operator.assign.intention=Replace with an operator-assign expression
+replace.with.operator.assign.intention.family=Replace with an operator-assign expression","By convention every significant word in the intention family name should be capitalized. Compare `unfold.assignment.to.when` and `unfold.assignment.to.when.family`, for example
",replace.with.dot.qualified.method.call.intention.family=Replace wit
762,"@@ -227,7 +228,7 @@ private void checkForCastImpossibilityOrRedundancy(
                 expression.getLeft(), context.dataFlowInfo, actualType, context);
         for (JetType possibleType : possibleTypes) {
             if (typeChecker.isSubtypeOf(possibleType, targetType)) {
-                context.trace.report(USELESS_CAST_STATIC_ASSERT_IS_FINE.on(expression));
+                context.trace.report(USELESS_CAST.on(expression));","Probably this shouldn't be reported at all here?

Consider this example:

```
trait A
trait B
trait C : A, B

fun foo(a: A) {}
fun foo(b: B) {}

fun bar(c: C) = foo(c as A)   // <-- incorrect warning here, the cast is not useless
```
",I think this should be `USELESS_CAST_STATIC_ASSERT`.
763,"@@ -2278,6 +2278,14 @@
                      language=""kotlin""
     />
 
+    <localInspection implementationClass=""org.jetbrains.kotlin.idea.inspections.RedundantProgressionStepInspection""
+                     displayName=""Redundant progression step""
+                     groupName=""Kotlin""",Please provide a group path and group name for the inspection according to https://github.com/JetBrains/kotlin/commit/a09b31b5680952c56bb3ea5bbcb7939084e9f027,I don't think we need the `groupName` here.
764,"@@ -228,6 +228,8 @@ fun createSpacingBuilder(settings: CodeStyleSettings, builderUtil: KotlinSpacing
             betweenInside(REFERENCE_EXPRESSION, LAMBDA_ARGUMENT, CALL_EXPRESSION).spaces(1)
             betweenInside(TYPE_ARGUMENT_LIST, LAMBDA_ARGUMENT, CALL_EXPRESSION).spaces(1)
 
+            around(IS_KEYWORD).spaces(1)","This is really minor, but still: to make the code easier to follow, I'd move this line next to the rule for the AS keyword.
","betweenInside(IS_KEYWORD, LAMBDA_ARGUMENT).spaces(1)"
765,"@@ -23,14 +23,14 @@
 import org.jetbrains.kotlin.resolve.DescriptorUtils;
 
 public abstract class AbstractClassTypeConstructor implements TypeConstructor {
-    private boolean hashCodeComputed;
+    private volatile boolean hashCodeComputed;
     private int hashCode;
 
     @Override
     public final int hashCode() {","@yole, Maybe there would be best to use String.hashCode() approach? It doesn't require additional volatile field. 
What about caching fqnames for descriptors? Will it waste memory?
",Why is this volatile?
766,"@@ -23,38 +23,57 @@ import org.jetbrains.kotlin.idea.util.addAnnotation
 import org.jetbrains.kotlin.idea.util.findAnnotation
 import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.psi.*
+import org.jetbrains.kotlin.psi.psiUtil.endOffset
+import org.jetbrains.kotlin.psi.psiUtil.startOffset
 
 private val annotationFqName = FqName(""kotlin.jvm.JvmOverloads"")
 
-class AddJvmOverloadsIntention : SelfTargetingIntention<KtParameterList>(
-        KtParameterList::class.java, ""Add '@JvmOverloads' annotation""
+class AddJvmOverloadsIntention : SelfTargetingIntention<KtModifierListOwner>(
+        KtModifierListOwner::class.java, ""Add '@JvmOverloads' annotation""
 ), LowPriorityAction {
 
-    override fun isApplicableTo(element: KtParameterList, caretOffset: Int): Boolean {
-        val parent = element.parent as? KtModifierListOwner ?: return false
-        val target = when (parent) {
-            is KtNamedFunction -> ""function '${parent.name}'""
-            is KtPrimaryConstructor -> ""primary constructor""
-            is KtSecondaryConstructor -> ""secondary constructor""
+    override fun isApplicableTo(element: KtModifierListOwner, caretOffset: Int): Boolean {
+        val (targetName, parameterList) = when (element) {
+            is KtNamedFunction -> {
+                val funKeyword = element.funKeyword ?: return false
+                val valueParameterList = element.valueParameterList ?: return false
+                if (caretOffset !in funKeyword.startOffset..valueParameterList.endOffset) {
+                    return false
+                }
+
+                ""function '${element.name}'"" to valueParameterList
+            }
+            is KtSecondaryConstructor -> {
+                val constructorKeyword = element.getConstructorKeyword()
+                val valueParameterList = element.valueParameterList ?: return false
+                if (caretOffset !in constructorKeyword.startOffset..valueParameterList.endOffset) {
+                    return false
+                }
+
+                ""secondary constructor"" to valueParameterList
+            }
+            is KtPrimaryConstructor -> ""primary constructor"" to element.valueParameterList
             else -> return false
         }
-        text = ""Add '@JvmOverloads' annotation to $target""
+        val parameters = parameterList?.parameters ?: return false
+
+        text = ""Add '@JvmOverloads' annotation to $targetName""
 
         return !ProjectStructureUtil.isJsKotlinModule(element.getContainingKtFile())
-               && element.parameters.any { it.hasDefaultValue() }
-               && parent.findAnnotation(annotationFqName) == null
+               && parameters.size > 1","This is not exactly the check that I meant. Specifically for the primary constructor, Kotlin will generate a no-argument overload when all arguments have default values, even if the @JvmOverloads annotation is not present. This doesn't happen for regular functions.
","I don't think we need to check for `constructorKeyword` here, since"
767,"@@ -235,6 +235,22 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if(indexesRange.first < 0 || indexesRange.last > lastIndex)","What is the value of `last` of empty range and of `lastIndex` of the empty list? Don't they throw an exception? You have to add corresponding tests 
",Why do we need this?
768,"@@ -235,6 +235,22 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if(indexesRange.first < 0 || indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException()","It should be more debug information: exact range bounds and the list size
",Why is this needed?
769,"@@ -235,6 +235,22 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if(indexesRange.first < 0 || indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException()
+        else if(indexesRange.first<=indexesRange.last)","Formatting
",I think this should
770,"@@ -235,6 +235,22 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if(indexesRange.first < 0 || indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException()
+        else if(indexesRange.first<=indexesRange.last)
+            subList(indexesRange.first, indexesRange.last+1)
+        else
+            listOf<T>()
+
+/**
+ * Returns the list multiplication.
+ */
+operator fun <T> List<T>.times(factor: Int): List<T> = (1..factor).flatMap { this }","Negative `factor` should throw an exception 
",I think this should
771,"@@ -235,6 +235,28 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if (indexesRange.first < 0)
+            throw IndexOutOfBoundsException(""Range beginning (${indexesRange.first}) is less than zero."")
+        else if (indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException(""Range end (${indexesRange.last}) is bigger then the end of table ($lastIndex)"")
+        else if (indexesRange.first <= indexesRange.last)
+            subList(indexesRange.first, indexesRange.last + 1)","It should be `toList()` after because we need a copy but `subList` just refers to the original list. 
",I think this should
772,"@@ -235,6 +235,28 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if (indexesRange.first < 0)
+            throw IndexOutOfBoundsException(""Range beginning (${indexesRange.first}) is less than zero."")
+        else if (indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException(""Range end (${indexesRange.last}) is bigger then the end of table ($lastIndex)"")
+        else if (indexesRange.first <= indexesRange.last)
+            subList(indexesRange.first, indexesRange.last + 1)
+        else
+            listOf<T>()
+
+/**
+ * Returns the list multiplication.
+ */
+operator fun <T> List<T>.times(factor: Int): List<T> =
+        if (factor < 0)
+            throw ArithmeticException(""List factor must be bigger then 0"")","You may just do `require(factor >= 0) {""error message ""}`. Also notice that in Java wrong arguments should cause `IllegalArgumentException` (so it is done inside of the `require` function) 
",I think this should
773,"@@ -235,6 +235,30 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+public operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if (indexesRange.isEmpty())
+            listOf<T>()
+        else if (indexesRange.first < 0)
+            throw IndexOutOfBoundsException(""Range beginning (${indexesRange.first}) is less than zero."")
+        else if (indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException(""Range end (${indexesRange.last}) is bigger then the end of table ($lastIndex)"")","typo: than
",I think this should
774,"@@ -235,6 +235,30 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 }
 
 /**
+ * Returns the elements from the list from indexes specified in range.
+ */
+public operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if (indexesRange.isEmpty())
+            listOf<T>()
+        else if (indexesRange.first < 0)
+            throw IndexOutOfBoundsException(""Range beginning (${indexesRange.first}) is less than zero."")
+        else if (indexesRange.last > lastIndex)
+            throw IndexOutOfBoundsException(""Range end (${indexesRange.last}) is bigger then the end of table ($lastIndex)"")
+        else if (indexesRange.first <= indexesRange.last)
+            subList(indexesRange.first, indexesRange.last + 1).toList()
+        else
+            throw Exception(""Unknown exception in getting range of indexes from list"")
+
+/**
+ * Returns the list multiplication.
+ */
+public operator fun <T> List<T>.times(factor: Int): List<T> {
+    require(factor >= 0) { ""List factor must be bigger then 0"" }","Type: than
Also lets include actual value in the message 
",nit: `List<T>.times
775,"@@ -236,7 +276,7 @@ public inline fun <K, V, C : MutableMap<K, V>> Map<K, V>.filterNotTo(destination
 }
 
 /**
- * Returns a map containing all key-value pairs matching the given *predicate*
+ * Returns a map containing all key-value pairs not matching the given [predicate].","Returns a _new_ map
",I don't think we ne
776,"@@ -237,24 +237,26 @@ public fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, com
 /**
  * Returns the elements from the list from indexes specified in range.
  */
-operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
-        if (indexesRange.first < 0)
+public operator fun <T> List<T>.get(indexesRange: IntRange): List<T> =
+        if (indexesRange.isEmpty())
+            listOf<T>()
+        else if (indexesRange.first < 0)
             throw IndexOutOfBoundsException(""Range beginning (${indexesRange.first}) is less than zero."")
         else if (indexesRange.last > lastIndex)
             throw IndexOutOfBoundsException(""Range end (${indexesRange.last}) is bigger then the end of table ($lastIndex)"")
         else if (indexesRange.first <= indexesRange.last)
-            subList(indexesRange.first, indexesRange.last + 1)
+            subList(indexesRange.first, indexesRange.last + 1).toList()
         else
-            listOf<T>()
+            throw Exception(""Unknown exception in getting range of indexes from list"")
 
 /**
  * Returns the list multiplication.
  */
-operator fun <T> List<T>.times(factor: Int): List<T> =
-        if (factor < 0)
-            throw ArithmeticException(""List factor must be bigger then 0"")
-        else
-            (1..factor).flatMap { this }
+public operator fun <T> List<T>.times(factor: Int): List<T> {
+    require(factor >= 0) { ""List factor must be bigger then 0"" }","""than"", also is 0 itself valid or not?
",Why is this needed?
777,"@@ -24,11 +24,11 @@ internal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {
 /**
  * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].
  * This implicit default value is used when properties are delegated to the returned map,
- * and that map doesn't contain value for the key specified.
+ * and that map doesn't contain a value for the key specified.
  *
- * When this map already have an implicit default value provided with a former call to [withDefault], it is being replaced by this call.
+ * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.
  */
-public fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =
+fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =","Missing `public` modifier.
",Why did you remove 
778,"@@ -24,19 +24,38 @@ import org.apache.commons.io.FileUtils
 import org.jetbrains.kotlin.gradle.plugin.*
 import org.gradle.api.Project
 import org.jetbrains.jet.config.Services
-
-public open class KotlinCompile(): AbstractCompile() {
-
+import org.jetbrains.jet.cli.js.K2JSCompiler
+import org.jetbrains.jet.cli.common.arguments.K2JSCompilerArguments
+import org.jetbrains.k2js.config.MetaInfServices
+import org.jetbrains.k2js.config.ClassPathLibraryDefintionsConfig
+import org.jetbrains.jet.cli.common.CLIConfigurationKeys
+import org.jetbrains.jet.config.CompilerConfiguration
+import org.jetbrains.jet.cli.jvm.compiler.CompileEnvironmentUtil
+import org.jetbrains.jet.cli.jvm.compiler.JetCoreEnvironment
+import com.intellij.openapi.Disposable
+import com.intellij.openapi.util.Disposer
+import org.jetbrains.k2js.config.EcmaVersion
+import org.gradle.api.tasks.Copy
+import org.gradle.api.Action
+import org.gradle.api.internal.project.ProjectInternal
+import groovy.lang.Closure
+import org.codehaus.groovy.runtime.MethodClosure
+import org.gradle.api.DefaultTask
+import org.jetbrains.jet.cli.common.arguments.CommonCompilerArguments
+import org.jetbrains.jet.cli.common.CLICompiler
+
+
+abstract class AbstractKotlinCompile<T : CommonCompilerArguments>(): AbstractCompile() {
     val srcDirsSources = HashSet<SourceDirectorySet>()
-    val compiler = K2JVMCompiler()
+    abstract protected val compiler: CLICompiler<T>
+    abstract protected fun createBlankArgs(): T
+    public var kotlinOptions: T = createBlankArgs()
+
+    public var kotlinDestinationDir : File? = getDestinationDir()","Unnecessary space before colon(`:`)
",Why do we need this
779,"@@ -24,7 +24,7 @@ fileAnnotations
   ;
 
 fileAnnotation
-  : ""@"" ""file"" "":"" (""["" annotationEntry+ ""]"" | annotationEntry)
+  : ""@"" ""file"" "":"" (""["" annotation+ ""]"" | annotation)","I think it should be `unescapedAnnotation` instead of `annotation`.
Probably we should also remove `("":"" ""file"")?` part from `annotationPrefix`.
",I don't think we ne
780,"@@ -241,7 +241,8 @@ class DefaultExpressionConverter : JavaElementVisitor(), ExpressionConverter {
         }
         val name = if (primitiveType != null) {
             ""javaPrimitiveType""
-        } else {
+        }
+        else {",It is wrong according to Java Code Conventions,Why is this change 
781,"@@ -244,7 +244,10 @@
     <inspection_tool class=""MethodOverloadsParentMethod"" enabled=""true"" level=""WARNING"" enabled_by_default=""true"" />
     <inspection_tool class=""MethodOverridesPrivateMethod"" enabled=""true"" level=""WARNING"" enabled_by_default=""true"" />
     <inspection_tool class=""MethodOverridesStaticMethod"" enabled=""true"" level=""WARNING"" enabled_by_default=""true"" />
-    <inspection_tool class=""MissingOverrideAnnotation"" enabled=""true"" level=""WARNING"" enabled_by_default=""true"" />
+    <inspection_tool class=""MissingOverrideAnnotation"" enabled=""true"" level=""WARNING"" enabled_by_default=""true"">
+      <option name=""ignoreObjectMethods"" value=""true"" />
+      <option name=""ignoreAnonymousClassMethods"" value=""false"" />
+    </inspection_tool>","This should be reverted
",I don't think we ne
782,"@@ -245,10 +245,12 @@ class KotlinCodeFragmentFactory: CodeFragmentFactory() {
         fun createCodeFragmentForLabeledObjects(project: Project, markupMap: Map<*, ValueMarkup>): Pair<String, Map<String, Value>> {
             val sb = StringBuilder()
             val labeledObjects = HashMap<String, Value>()
+            val psiNameHelper = PsiNameHelper.getInstance(project)
+
             val entrySet: Set<Map.Entry<*, ValueMarkup>> = markupMap.entries
             for ((value, markup) in entrySet) {
                 val labelName = markup.text
-                if (!Name.isValidIdentifier(labelName)) continue
+                if (!Name.isValidIdentifier(labelName) || !psiNameHelper.isIdentifier(labelName)) continue","Do we need Name.isValidIdentifier() here at all?
",Why do we need this
783,"@@ -246,4 +246,32 @@ private fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {
     }
 }
 
+/**
+ * List ""and"" operation that returns elements that are in both lists in number of lower list
+ * Note that listOf(1, 1) and listOf(1, 1, 1) == listOf(1, 1)
+ */
+infix fun <T> List<T>.and(secList: List<T>): List<T> {
+    var tempSecList = secList
+    return filter {
+        if ( it in tempSecList ) {
+            tempSecList -= it
+            true
+        } else {
+            false
+        }
+    }
+}
 
+/**
+ * List ""or"" operation that returns elements that are in both lists in number of lower list
+ * Note that listOf(1, 1) and listOf(1, 1, 1) == listOf(1, 1, 1)","listOf(1, 1) OR listOf(1, 1, 1) == listOf(1, 1, 1) !?
",`infix` -> `infix`
784,"@@ -248,6 +250,18 @@ abstract class AbstractKotlinPlugin @Inject constructor(val scriptHandler: Scrip
             }
         })
     }
+
+    private fun configureResolutionStrategy(project: Project) {
+        val projectVersion = loadKotlinVersionFromResource(project.logger)
+        project.configurations.all(Action<Configuration> { configuration ->
+            configuration.resolutionStrategy.eachDependency { details ->
+                val requested = details.requested
+                if (requested.group.equals(""org.jetbrains.kotlin"") && requested.version.isEmpty()) {
+                    details.useTarget(""${requested.group}:${requested.name}:$projectVersion"")","Why do you put `project.version` here? shouldn't you somehow lookup Kotlin plugin version here?
",Why do we need this?
785,"@@ -25,65 +25,146 @@ package kotlin
 public class Byte private () : Number, Comparable<Byte> {
     default object {}
 
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public override fun compareTo(other: Byte): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Char): Int","Comparing byte with char for ordering probably requires more description about what it really means.
",I don't think this i
786,"@@ -25,65 +25,146 @@ package kotlin
 public class Byte private () : Number, Comparable<Byte> {
     default object {}
 
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public override fun compareTo(other: Byte): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Char): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Short): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Int): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Long): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Float): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Double): Int
 
+    /** Adds the two values. */
     public fun plus(other: Byte): Int
+    /** Adds the two values. */
     public fun plus(other: Char): Int
+    /** Adds the two values. */
     public fun plus(other: Short): Int
+    /** Adds the two values. */
     public fun plus(other: Int): Int
+    /** Adds the two values. */
     public fun plus(other: Long): Long
+    /** Adds the two values. */
     public fun plus(other: Float): Float
+    /** Adds the two values. */","""Adds the other value to this value.""
like in `minus`
",I don't think we nee
787,"@@ -25,65 +25,146 @@ package kotlin
 public class Byte private () : Number, Comparable<Byte> {
     default object {}
 
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public override fun compareTo(other: Byte): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Char): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Short): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Int): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Long): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Float): Int
+/**
+ * Compares this value with the specified value for order.
+ * Returns zero if this value is equal to the specified other value, a negative number if its less than other, 
+ * or a positive number if its greater than other.
+ */
     public fun compareTo(other: Double): Int
 
+    /** Adds the two values. */
     public fun plus(other: Byte): Int
+    /** Adds the two values. */
     public fun plus(other: Char): Int
+    /** Adds the two values. */
     public fun plus(other: Short): Int
+    /** Adds the two values. */
     public fun plus(other: Int): Int
+    /** Adds the two values. */
     public fun plus(other: Long): Long
+    /** Adds the two values. */
     public fun plus(other: Float): Float
+    /** Adds the two values. */
     public fun plus(other: Double): Double
 
+    /** Subtracts the other value from this value. */
     public fun minus(other: Byte): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Char): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Short): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Int): Int
+    /** Subtracts the other value from this value. */
     public fun minus(other: Long): Long
+    /** Subtracts the other value from this value. */
     public fun minus(other: Float): Float
+    /** Subtracts the other value from this value. */
     public fun minus(other: Double): Double
 
+    /** Multiplies the two values. */","Multiplies this value by the other value.
",I don't think we nee
788,"@@ -256,6 +255,16 @@ public KotlinType getBodyExpressionType(
         DataFlowInfo beforeJumpInfo = newContext.dataFlowInfo;
         boolean jumpOutPossible = false;
         for (Iterator<? extends KtElement> iterator = block.iterator(); iterator.hasNext(); ) {
+            // Use filtering trace to keep effect system cache only for one statement","For me this place is not very clear, check it with @erokhins ",// Use filtering tra
789,"@@ -257,7 +258,7 @@ public class KotlinCoreEnvironment private constructor(
             val appEnv = getOrCreateApplicationEnvironmentForProduction(configuration, configFilePaths)
             // Disposing of the environment is unsafe in production then parallel builds are enabled, but turning it off universally
             // breaks a lot of tests, therefore it is disabled for production and enabled for tests
-            if (System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY) == null) {
+            if (!(System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY).toBooleanLenient() ?: false)) {","This could be written as

```
if (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = true)) {
```
",Please use `Boolean.
790,"@@ -264,3 +264,35 @@ public fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {
  * Converts this [Map] to a [LinkedHashMap] so future insertion orders are maintained
  */
 public fun <K, V> Map<K, V>.toLinkedMap(): MutableMap<K, V> = LinkedHashMap(this)
+
+/**
+ * Create a new read-only map from a map and a single new key-value pair
+ */
+public fun <K, V> Map<K, V>.plus(pair: Pair<K, V>): Map<K, V> {
+    val newMap = this.toLinkedMap()
+    newMap.put(pair.first, pair.second)
+    return newMap
+}
+
+/**
+ * Create a new read-only map from a map and a list new key-value pairs
+ */
+public fun <K, V> Map<K, V>.plus(pairs: Collection<Pair<K, V>>): Map<K, V> {
+    val newMap = this.toLinkedMap()
+    newMap.putAll(pairs)
+    return newMap
+}
+
+/**
+ * Create a new read-only map by removing a key
+ */
+public fun <K, V> Map<K, V>.minus(key: K): Map<K, V> {
+    return this.filterKeys { key != it }
+}
+
+/**
+ * Create a new read-only map by removing a list of keys","> list of

oops
",Why do we need this 
791,"@@ -28,41 +28,47 @@ import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
 class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
 
     val patterns = mapOf(
-            ""java.io.PrintStream.println"" to ""println($0)"",
-            ""java.io.PrintStream.print"" to ""print($0)"",
-            ""java.util.Collections.sort"" to ""$0.sort()""
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", false),","This boolean value is quite unclear. Much better to use an enum instead.
",Why do we need this 
792,"@@ -28,41 +28,47 @@ import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
 class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
 
     val patterns = mapOf(
-            ""java.io.PrintStream.println"" to ""println($0)"",
-            ""java.io.PrintStream.print"" to ""print($0)"",
-            ""java.util.Collections.sort"" to ""$0.sort()""
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", false),
+            ""java.io.PrintStream.print"" to Pair(""print($0)"", false),
+            ""java.util.Collections.sort"" to Pair(""$0.sort()"", false),
+            ""java.util.HashMap.put"" to Pair(""$0[$1] = $2"", true)
     )
 
     override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
         return object : KtVisitorVoid() {
             override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
                 super.visitQualifiedExpression(expression)
 
-                val selectorExpression = expression.selectorExpression ?: return
-                if (selectorExpression !is KtCallExpression) return
-                val value = selectorExpression.valueArguments.singleOrNull() ?: return
+                val selectorExpression = expression.selectorExpression
+                if(selectorExpression !is KtCallExpression) return
+                val arguments = selectorExpression.valueArguments
+                if(arguments.isEmpty()) return
 
                 val calleeExpression = selectorExpression.calleeExpression as KtSimpleNameExpression
                 val bindingContext = calleeExpression.analyze(BodyResolveMode.PARTIAL)
                 val target = calleeExpression.mainReference.resolveToDescriptors(bindingContext).singleOrNull() ?: return
-                val pattern = target.fqNameSafe.asString()
-                if (!patterns.containsKey(pattern)) return
-
-                holder.registerProblem(expression,
-                                       ""Unnecessary java usage"",
-                                       ProblemHighlightType.WEAK_WARNING,
-                                       UnnecessaryJavaUsageFix(patterns[pattern]!!, value.text))
+                val pattern = patterns[target.fqNameSafe.asString()] ?: return
+                val javaUsageFix = UnnecessaryJavaUsageFix(pattern, expression.receiverExpression, arguments.map{it.text})
+                holder.registerProblem(expression, ""Unnecessary java usage"", ProblemHighlightType.WEAK_WARNING, javaUsageFix)","Once again ""unnecessary java usage"".
",Why did you remove t
793,"@@ -28,41 +28,47 @@ import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode
 class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalInspectionTool {
 
     val patterns = mapOf(
-            ""java.io.PrintStream.println"" to ""println($0)"",
-            ""java.io.PrintStream.print"" to ""print($0)"",
-            ""java.util.Collections.sort"" to ""$0.sort()""
+            ""java.io.PrintStream.println"" to Pair(""println($0)"", false),
+            ""java.io.PrintStream.print"" to Pair(""print($0)"", false),
+            ""java.util.Collections.sort"" to Pair(""$0.sort()"", false),
+            ""java.util.HashMap.put"" to Pair(""$0[$1] = $2"", true)
     )
 
     override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean, session: LocalInspectionToolSession): PsiElementVisitor {
         return object : KtVisitorVoid() {
             override fun visitQualifiedExpression(expression: KtQualifiedExpression) {
                 super.visitQualifiedExpression(expression)
 
-                val selectorExpression = expression.selectorExpression ?: return
-                if (selectorExpression !is KtCallExpression) return
-                val value = selectorExpression.valueArguments.singleOrNull() ?: return
+                val selectorExpression = expression.selectorExpression
+                if(selectorExpression !is KtCallExpression) return
+                val arguments = selectorExpression.valueArguments
+                if(arguments.isEmpty()) return
 
                 val calleeExpression = selectorExpression.calleeExpression as KtSimpleNameExpression
                 val bindingContext = calleeExpression.analyze(BodyResolveMode.PARTIAL)
                 val target = calleeExpression.mainReference.resolveToDescriptors(bindingContext).singleOrNull() ?: return
-                val pattern = target.fqNameSafe.asString()
-                if (!patterns.containsKey(pattern)) return
-
-                holder.registerProblem(expression,
-                                       ""Unnecessary java usage"",
-                                       ProblemHighlightType.WEAK_WARNING,
-                                       UnnecessaryJavaUsageFix(patterns[pattern]!!, value.text))
+                val pattern = patterns[target.fqNameSafe.asString()] ?: return
+                val javaUsageFix = UnnecessaryJavaUsageFix(pattern, expression.receiverExpression, arguments.map{it.text})
+                holder.registerProblem(expression, ""Unnecessary java usage"", ProblemHighlightType.WEAK_WARNING, javaUsageFix)
             }
         }
     }
 
-    private class UnnecessaryJavaUsageFix(val pattern: String, val value: String) : LocalQuickFix {
+    private class UnnecessaryJavaUsageFix(val pattern: Pair<String, Boolean>,","Better to unpack the pair and to use separate arguments for the text and conversion mode.
",Why did you remove t
794,"@@ -28,60 +28,60 @@ public inline fun TODO(reason: String): Nothing = throw NotImplementedError(""An
  * Calls the specified function [block] and returns its result.
  */
 @kotlin.internal.InlineOnly
-public inline fun <R> run(block: () -> R): R = block()
+public inline fun <R> run(@kotlin.internal.CalledInPlace(kotlin.internal.InvocationCount.EXACTLY_ONCE) block: () -> R): R = block()",Can we annotate also both `TODO` functions?,@kotlin.internal.Inl
795,"@@ -287,16 +314,24 @@ static void replaceFile(File updatedFile, VirtualFile replacedJarFile) {
     @NotNull
     private static Collection<VirtualFile> getLibraryRootsWithAbiIncompatibleVersion(
             @NotNull Project project,
-            @NotNull ScalarIndexExtension<Integer> index
+            @NotNull ScalarIndexExtension<Integer> index,
+            @NotNull Predicate<Module> checkModule,
+            @NotNull Predicate<Integer> checkAbiVersion
     ) {
         ID<Integer, Void> id = index.getName();
-        Collection<Integer> abiVersions = FileBasedIndex.getInstance().getAllKeys(id, project);
-        Set<Integer> badAbiVersions = Sets.newHashSet(Collections2.filter(abiVersions, new Predicate<Integer>() {
-            @Override
-            public boolean apply(Integer abiVersion) {
-                return !AbiVersionUtil.isAbiVersionCompatible(abiVersion);
+
+        Module[] modules = ModuleManager.getInstance(project).getModules();
+
+        List<Module> modulesToCheck = new ArrayList<Module>();
+        for(Module module : modules) {","If you're using `Predicate`, you might as well go ahead and call `Collections2.filter` here. Also I would recommend to use `kotlin.Function1` and `KotlinPackage.filter` instead, but that's up to you
",`checkModule` -> `ch
796,"@@ -287,16 +314,24 @@ static void replaceFile(File updatedFile, VirtualFile replacedJarFile) {
     @NotNull
     private static Collection<VirtualFile> getLibraryRootsWithAbiIncompatibleVersion(
             @NotNull Project project,
-            @NotNull ScalarIndexExtension<Integer> index
+            @NotNull ScalarIndexExtension<Integer> index,
+            @NotNull Predicate<Module> checkModule,
+            @NotNull Predicate<Integer> checkAbiVersion
     ) {
         ID<Integer, Void> id = index.getName();
-        Collection<Integer> abiVersions = FileBasedIndex.getInstance().getAllKeys(id, project);
-        Set<Integer> badAbiVersions = Sets.newHashSet(Collections2.filter(abiVersions, new Predicate<Integer>() {
-            @Override
-            public boolean apply(Integer abiVersion) {
-                return !AbiVersionUtil.isAbiVersionCompatible(abiVersion);
+
+        Module[] modules = ModuleManager.getInstance(project).getModules();
+
+        List<Module> modulesToCheck = new ArrayList<Module>();
+        for(Module module : modules) {
+            if (checkModule.apply(module)) {
+                modulesToCheck.add(module);
             }
-        }));
+        }
+        if (modulesToCheck.isEmpty()) return new ArrayList<VirtualFile>();","`Collections.emptyList()`?
",`checkModule` -> `ch
797,"@@ -287,6 +287,10 @@ convert.negated.expression.with.demorgans.law=Convert negated expression to DeMo
 convert.negated.expression.with.demorgans.law.family=Convert negated expression to DeMorgan's equivalent
 split.if=Split into 2 if's
 split.if.family=Split If
+make.type.explicit.in.lambda=Make types explicit
+make.type.explicit.in.lambda.family=Make Types Explicit
+make.type.implicit.in.lambda=Make types implicit
+make.type.implicit.in.lambda.family=Make Types Implicit","Why not `... in lambda` ?
",I think this should 
798,"@@ -288,8 +288,8 @@ public String render(@NotNull BadNamedArgumentsTarget target) {
 
         MAP.put(MANY_COMPANION_OBJECTS, ""Only one companion object is allowed per class"");
 
-        MAP.put(DEPRECATED_SYMBOL, ""''{0}'' is deprecated."", DEPRECATION_RENDERER);
-        MAP.put(DEPRECATED_SYMBOL_WITH_MESSAGE, ""''{0}'' is deprecated. {1}"", DEPRECATION_RENDERER, STRING);
+        MAP.put(DEPRECATION, ""''{0}'' is deprecated. {1}"", DEPRECATION_RENDERER, STRING);
+        MAP.put(DEPRECATION_ERROR, ""Calling ''{0}'' is an error. {1}"", DEPRECATION_RENDERER, STRING);","I think this error message looks weird on classes in type positions...
",I think it would be 
799,"@@ -288,9 +295,21 @@ public static Type getTraitImplThisParameterType(@NotNull ClassDescriptor traitD
 
     private static Type stringValueOfOrStringBuilderAppendType(Type type) {
         int sort = type.getSort();
-        return sort == Type.OBJECT || sort == Type.ARRAY
-                   ? AsmTypeConstants.OBJECT_TYPE
-                   : sort == Type.BYTE || sort == Type.SHORT ? Type.INT_TYPE : type;
+        switch (sort) {
+            case Type.OBJECT:
+                if(STRINGBULDER_OBJECT_APPEND_ARG_TYPES.contains(type.getClassName())) {","Please add a space after `if`
",I don't think we nee
800,"@@ -29,27 +29,27 @@ fun main(args: Array<String>) {
     generateDomEventsAPI(File(jsCoreDir, ""domEvents.kt""))
 
     iterators().writeTo(File(outDir, ""_Iterators.kt"")) {
-        buildFor(Iterators, """")
+        buildFor(Iterators, null)
     }
 
     val iterables = iterables()
-    iterables.writeTo(File(outDir, ""_Arrays.kt"")) {
-        buildFor(Arrays, """")
+    val sumFunctions = PrimitiveType.values().map(::sumFunction).filterNotNull()
+    (iterables+sumFunctions).writeTo(File(outDir, ""_Arrays.kt"")) {
+        buildFor(Arrays, null)
     }
 
-    val otherArrayNames = arrayListOf(""Boolean"", ""Byte"", ""Char"", ""Short"", ""Int"", ""Long"", ""Float"", ""Double"")
-    for (a in otherArrayNames) {
-        iterables.writeTo(File(outDir, ""_${a}Arrays.kt"")) {
-            buildFor(PrimitiveArrays, a)
+    for (primitive in PrimitiveType.values()) {
+        (iterables+sumFunction(primitive)).filterNotNull().writeTo(File(outDir, ""_${primitive.name}Arrays.kt"")) {","Let's stick to conventions: ""+"" should be surrounded by spaces
",Why is this null?
801,"@@ -292,6 +292,10 @@ convert.negated.boolean.sequence=Replace negated sequence with DeMorgan equivale
 convert.negated.boolean.sequence.family=Replace negated sequence with DeMorgan equivalent
 convert.negated.expression.with.demorgans.law=Convert negated expression to DeMorgan's equivalent
 convert.negated.expression.with.demorgans.law.family=Convert negated expression to DeMorgan's equivalent
+add.for.loop.indices=Add indices to for loop
+add.for.loop.indices.family=Add indices to for loop","Should be `Add Indices to For Loop`, take a look at https://github.com/JetBrains/kotlin/commit/5a0055cbeb90b0c6d80c223d4d68cc451d0ccfc1
",I think this shou
802,"@@ -292,6 +292,10 @@ convert.negated.boolean.sequence=Replace negated sequence with DeMorgan equivale
 convert.negated.boolean.sequence.family=Replace negated sequence with DeMorgan equivalent
 convert.negated.expression.with.demorgans.law=Convert negated expression to DeMorgan's equivalent
 convert.negated.expression.with.demorgans.law.family=Convert negated expression to DeMorgan's equivalent
+add.for.loop.indices=Add indices to for loop
+add.for.loop.indices.family=Add indices to for loop
+remove.for.loop.indices=Remove indices from for loop
+remove.for.loop.indices.family=Remove indices from for loop","`Remove Indices from For Loop`
",I don't think you
803,"@@ -2945,6 +2946,12 @@ public Unit invoke(InstructionAdapter v) {
         });
     }
 
+    private static boolean isInRangeValueType(Type type) {","There's `AsmUtil#isIntPrimitive`
",
804,"@@ -295,7 +295,10 @@ simplify.boolean.with.constants=Simplify boolean expression
 simplify.boolean.with.constants.family=Simplify boolean expression
 insert.explicit.type.arguments=Add explicit type arguments
 insert.explicit.type.arguments.family=Add explicit type arguments
->>>>>>> Intention for adding explicit type arguments at function calls
+make.type.explicit.in.lambda=Make types explicit
+make.type.explicit.in.lambda.family=Make Types Explicit
+make.type.implicit.in.lambda=Make types implicit
+make.type.implicit.in.lambda.family=Make Types Implicit","Why not ""Make types explicit/implicit **in lambda**""? I believe I asked you this the first time
",I don't think thi
805,"@@ -295,7 +295,10 @@ simplify.boolean.with.constants=Simplify boolean expression
 simplify.boolean.with.constants.family=Simplify boolean expression
 insert.explicit.type.arguments=Add explicit type arguments
 insert.explicit.type.arguments.family=Add explicit type arguments
->>>>>>> Intention for adding explicit type arguments at function calls
+make.type.explicit.in.lambda=Make types explicit in lambda
+make.type.explicit.in.lambda.family=Make Types Explicit In Lambda
+make.type.implicit.in.lambda=Make types implicit in lambda(may break code)","Please add a space before `(` :)
",This should be `m
806,"@@ -295,7 +295,10 @@ simplify.boolean.with.constants=Simplify boolean expression
 simplify.boolean.with.constants.family=Simplify boolean expression
 insert.explicit.type.arguments=Add explicit type arguments
 insert.explicit.type.arguments.family=Add explicit type arguments
->>>>>>> Intention for adding explicit type arguments at function calls
+make.type.explicit.in.lambda=Make types explicit in lambda
+make.type.explicit.in.lambda.family=Make Types Explicit In Lambda
+make.type.implicit.in.lambda=Make types implicit in lambda(may break code)
+make.type.implicit.in.lambda.family=Make Types Implicit In Lambda(May Break Code)","Ditto
",This should be `M
807,"@@ -3,12 +3,12 @@ package kotlin
 import java.util.*
 
 /**
- * Returns a new [[SortedSet]] with the initial elements
+ * Returns a new [SortedSet] with the given elements.
  */
 public fun sortedSetOf<T>(vararg values: T): TreeSet<T> = values.toCollection(TreeSet<T>())
 
 /**
- * Returns a new [[SortedSet]] with the given *comparator* and the initial elements
+ * Returns a new [SortedSet] with the given [comparator] and initial elements.","initial -> given as in the function above
",I don't think we 
808,"@@ -3,13 +3,13 @@ import kotlinApi.*
 //TODO: Formatter works incorrectly
 internal class A {
     fun foo(c: KotlinClass): Int {
-        return c.nullableProperty!!.length
-        +c.property.length
-        +KotlinClass.nullableStaticVar!!
-        +KotlinClass.staticVar
-        +KotlinClass.nullableStaticFun(1)!!
-        +KotlinClass.staticFun(1)
-        +nullableGlobalFunction("""")!!.length
-        +globalFunction("""").length
+        return (c.nullableProperty!!.length",After changes TODO comment above your code should be removed. You've already fixed it.,Why is this chang
809,"@@ -3,7 +3,7 @@
     <property file=""resources/kotlinManifest.properties""/>
 
     <!-- Set to false to disable proguard run on kotlin-compiler.jar. Speeds up the build -->
-    <property name=""shrink"" value=""true""/>
+    <property name=""shrink"" value=""false""/>",Why? :(,Why do we need th
810,"@@ -3,7 +3,7 @@ package kotlin
 import java.util.Enumeration
 
 /**
- * Helper to make java.util.Enumeration usable in for
+ * Helper to make [Enumeration] usable in `for` loops.","""Creates `Iterator<T>` for an `Enumeration<T>`""
",This should be `j
811,"@@ -3,9 +3,9 @@ fun foo() {
         fun test() {}
     }
 
-    val d: A
+    val d =
     if (<caret>) {
-        d = A()
+        A()","I expected to generate following code

``` kotlin
    class A {
        fun test() {}
    }
    val d = if () {
        A()
    }
```

I don't think this new line is the problem with this pull request.

If I have following case

``` kotlin
fun foo() {
    <selection>class A {
        fun test() {}
    }



    val d: A = A()</selection>

    d.test()
    A()
}
```

For current kotlin plugin converts them into 

``` kotlin
    class A {
        fun test() {
        }
    }

    val d: A


    if () {
        d = A()
    }
```
",Why did you chang
812,"@@ -30,5 +32,10 @@ class RemoveEmptyClassBodyInspection : IntentionBasedInspection<KtClassBody>(Rem
 class RemoveEmptyClassBodyIntention : SelfTargetingOffsetIndependentIntention<KtClassBody>(KtClassBody::class.java, ""Remove empty class body"") {
     override fun applyTo(element: KtClassBody, editor: Editor?) = element.delete()
 
-    override fun isApplicableTo(element: KtClassBody) = element.text.replace(""{"", """").replace(""}"", """").isBlank()
+    override fun isApplicableTo(element: KtClassBody): Boolean {
+        element.getStrictParentOfType<KtObjectDeclaration>()?.let {","Won't

```
object Foo {
    class Bar {}
}
```

cause a false negative here?
",I'm not sure if t
813,"@@ -31,18 +31,49 @@ class ReplaceSingleLineLetIntention : SelfTargetingOffsetIndependentIntention<Kt
         ""Remove redundant '.let' call""
 ) {
     override fun applyTo(element: KtCallExpression, editor: Editor?) {
-        val lambdaExpression = element.lambdaArguments.firstOrNull()?.getLambdaExpression() ?: return
-        val bodyExpression = lambdaExpression.bodyExpression?.children?.singleOrNull() ?: return
-        val dotQualifiedExpression = bodyExpression as? KtDotQualifiedExpression ?: return
+        element.lambdaArguments.firstOrNull()?.getLambdaExpression()?.bodyExpression?.children?.singleOrNull()?.let {
+            when (it) {
+                is KtDotQualifiedExpression -> it.applyTo(element)
+                is KtBinaryExpression -> it.applyTo(element)
+            }
+        }
+    }
+
+    private fun KtBinaryExpression.applyTo(element: KtCallExpression) {
+        val left = left ?: return
+        val factory = KtPsiFactory(element.project)
+        val parent = element.parent
+        when (parent) {
+            is KtQualifiedExpression -> {
+                val receiver = parent.receiverExpression
+                val newLeft = when (left) {
+                    is KtDotQualifiedExpression -> left.replaceFirstReceiver(factory, receiver, parent.operationSign == KtTokens.SAFE_ACCESS)
+                    else -> receiver
+                }
+                val newExpression = factory.createExpression(""${newLeft.text}${operationReference.text}${right?.text ?: """"}"")","I think `createExpressionByPattern` should be better here and below. I'm trying to avoid using `text`, when possible.
",Why do we need to
814,"@@ -31,7 +31,7 @@ import java.io.InputStream
 class CliVirtualFileFinder(
         private val index: JvmDependenciesIndex,
         private val scope: GlobalSearchScope
-) : VirtualFileFinder() {
+) : JavacVirtualFileFinder() {",Check attentively that nothing is changed without `use-javac` option,Why do we need th
815,"@@ -313,14 +315,21 @@ private boolean shouldInitializeProperty(@NotNull JetProperty property) {
         PropertyDescriptor propertyDescriptor = (PropertyDescriptor) bindingContext.get(VARIABLE, property);
         assert propertyDescriptor != null;
 
-        CompileTimeConstant<?> compileTimeValue = propertyDescriptor.getCompileTimeInitializer();
+        JetExpression initializer = property.getInitializer();
+
+        CompileTimeConstant<?> initializerValue =
+                property.isVar() && initializer != null
+                ? ConstantExpressionEvaluator.OBJECT$.evaluate(initializer, state.getBindingTrace(), null)","I suggest to use a temporary trace here (and discard it) instead of `state.getBindingTrace()` so that `ConstantExpressionEvaluator` won't unexpectedly write to the global trace and alter the subsequent code generation.
",I don't think thi
816,"@@ -32,15 +32,49 @@ public annotation class noinline
  */
 public annotation class inline(public val strategy: InlineStrategy = InlineStrategy.AS_FUNCTION)
 
+/**
+ * Specifies the strategy for JVM bytecode generation for an inline function.","It's not JVM specific.
",* Specifies the strategy for JVM bytecode generation for an inline function.
817,"@@ -32,6 +50,7 @@ interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesReso
 
     sealed class ResolveResult {","I'd simplify this by assuming that the result is ""success"" iff there are no errors:
```
data class ResolutionResult(
    val dependencies: ScriptDependencies, // ScriptDependencies.Empty in case of failure
    val diagnostics: List<ScriptDiagnostic>
) {
    val isSuccess: Boolean get() = diagnostics.none { it.severity == ERROR } // maybe an extension
}
```
",public
818,"@@ -32,6 +50,7 @@ interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesReso
 
     sealed class ResolveResult {
         abstract val dependencies: ScriptDependencies?
+        // reports -> diagnostics",+1 for `val diagnostics: List<ScriptDiagnostic>`,nit: `// reports -> diagnostics`
819,"@@ -327,12 +327,12 @@ else if (containingDescriptor instanceof FunctionDescriptor || containingDescrip
         return defaultVisibility;
     }
 
-    public static Modality getDefaultModality(DeclarationDescriptor containingDescriptor, boolean isBodyPresent) {
+    public static Modality getDefaultModality(DeclarationDescriptor containingDescriptor, Visibility visibility, boolean isBodyPresent) {
         Modality defaultModality;
         if (containingDescriptor instanceof ClassDescriptor) {
             boolean isTrait = ((ClassDescriptor) containingDescriptor).getKind() == ClassKind.TRAIT;
             boolean isDefinitelyAbstract = isTrait && !isBodyPresent;
-            Modality basicModality = isTrait ? Modality.OPEN : Modality.FINAL;
+            Modality basicModality = isTrait && visibility != Visibilities.PRIVATE ? Modality.OPEN : Modality.FINAL;","Please use `Visibilities.isPrivate` instead & add a test on a private-to-this fun/val in a trait
",Shouldn't this be `visibility == Visibilities.PRIVATE`?
820,"@@ -33,10 +33,18 @@ public class StringBuilder(content: String = """") : Appendable, CharSequence {
     override val length: Int
         get() = string.asDynamic().length
 
+    fun setLength(newLength : Int) {
+        string = string.substring(0, newLength)",This implementation doesn't conform to the `setLength` method contract.,
821,"@@ -33,6 +33,7 @@
 public class KotlinEditorOptions implements PersistentStateComponent<KotlinEditorOptions> {
     private boolean donTShowConversionDialog = false;
     private boolean enableJavaToKotlinConversion = true;
+    private boolean enableSmartEditing = true;","I don't like the idea of adding a preference for this behavior. First of all, the name of the preference says nothing at all to the user. Second, if anyone becomes annoyed by the behavior, it's quite hard for them to discover how to change it.",Why do we need this?
822,"@@ -33,7 +33,7 @@
         <dependency>
             <groupId>com.android.tools.build</groupId>
             <artifactId>gradle</artifactId>
-            <version>1.1.0</version>
+            <version>1.3.0</version>","I suppose this isn't strictly needed since the plugin is looked up by name.
",This should be `1.2.0`
823,"@@ -34,33 +34,38 @@ private object EmptySet : Set<Any> {
     override fun toString(): String = set.toString()
 }
 
+/** Returns an empty read-only list. */
 public fun emptyList<T>(): List<T> = EmptyList as List<T>
+/** Returns an empty read-only set. */
 public fun emptySet<T>(): Set<T> = EmptySet as Set<T>
 
 /** Returns a new read-only list of given elements */
 public fun listOf<T>(vararg values: T): List<T> = if (values.size() == 0) emptyList() else arrayListOf(*values)
 
-/** Returns an empty read-only list */
+/** Returns an empty read-only list. */
 public fun listOf<T>(): List<T> = emptyList()
 
-/** Returns a new read-only ordered set of given elements */
+/** Returns a new read-only ordered set with the given elements. */
 public fun setOf<T>(vararg values: T): Set<T> = if (values.size() == 0) emptySet() else values.toCollection(LinkedHashSet<T>())
 
-/** Returns an empty read-only set */
+/** Returns an empty read-only set. */
 public fun setOf<T>(): Set<T> = emptySet()
 
-/** Returns a new LinkedList with a variable number of initial elements */
+/** Returns a new LinkedList with the given elements. */","Linkify LinkedList
",Why did you change this?
824,"@@ -34,33 +34,38 @@ private object EmptySet : Set<Any> {
     override fun toString(): String = set.toString()
 }
 
+/** Returns an empty read-only list. */
 public fun emptyList<T>(): List<T> = EmptyList as List<T>
+/** Returns an empty read-only set. */
 public fun emptySet<T>(): Set<T> = EmptySet as Set<T>
 
 /** Returns a new read-only list of given elements */
 public fun listOf<T>(vararg values: T): List<T> = if (values.size() == 0) emptyList() else arrayListOf(*values)
 
-/** Returns an empty read-only list */
+/** Returns an empty read-only list. */
 public fun listOf<T>(): List<T> = emptyList()
 
-/** Returns a new read-only ordered set of given elements */
+/** Returns a new read-only ordered set with the given elements. */
 public fun setOf<T>(vararg values: T): Set<T> = if (values.size() == 0) emptySet() else values.toCollection(LinkedHashSet<T>())
 
-/** Returns an empty read-only set */
+/** Returns an empty read-only set. */
 public fun setOf<T>(): Set<T> = emptySet()
 
-/** Returns a new LinkedList with a variable number of initial elements */
+/** Returns a new LinkedList with the given elements. */
 public fun linkedListOf<T>(vararg values: T): LinkedList<T> = values.toCollection(LinkedList<T>())
 
-/** Returns a new ArrayList with a variable number of initial elements */
+/** Returns a new ArrayList with the given elements. */
 public fun arrayListOf<T>(vararg values: T): ArrayList<T> = values.toCollection(ArrayList(values.size()))
 
-/** Returns a new HashSet with a variable number of initial elements */
+/** Returns a new HashSet with the given elements. */
 public fun hashSetOf<T>(vararg values: T): HashSet<T> = values.toCollection(HashSet(values.size()))
 
-/** Returns a new LinkedHashSet with a variable number of initial elements */
+/** Returns a new LinkedHashSet with the given elements. */
 public fun linkedSetOf<T>(vararg values: T): LinkedHashSet<T> = values.toCollection(LinkedHashSet(values.size()))
 
+/**
+ * Returns the valid indices for this collection.","Returns an IntRange specifying the valid... 
","""with the given elements"" -> ""with the given elements"""
825,"@@ -35,15 +34,45 @@ class ConvertToForEachFunctionCallIntention : SelfTargetingIntention<KtForExpres
     override fun applyTo(element: KtForExpression, editor: Editor?) {
         val commentSaver = CommentSaver(element)
 
+        val labelName = element.getLabelName()
+
         val body = element.body!!
         val loopParameter = element.loopParameter!!
 
         val functionBodyArgument: Any = if (body is KtBlockExpression) body.contentRange() else body
 
-        val foreachExpression = KtPsiFactory(element).createExpressionByPattern(
+        val psiFactory = KtPsiFactory(element)
+        val foreachExpression = psiFactory.createExpressionByPattern(
                 ""$0.forEach{$1->$2}"", element.loopRange!!, loopParameter, functionBodyArgument)
-        val result = element.replace(foreachExpression)
+        val result = element.replace(foreachExpression) as KtElement
+
+        result.getContinuesWithLabel(labelName).forEach {
+            it.replace(psiFactory.createExpression(""return@forEach""))
+        }
 
         commentSaver.restore(result)
     }
+
+    private fun KtElement.getContinuesWithLabel(labelName: String?): List<KtContinueExpression> {
+        val continueElements = ArrayList<KtContinueExpression>()
+
+        forEachDescendantOfType<KtContinueExpression>({ it !is KtLoopExpression }) {","I think the code will be cleaner if you merge the two loops into one.
",Why do we need this?
826,"@@ -35,33 +34,35 @@
 
 import javax.swing.*;
 
-public class DescriptorClassMember implements ClassMemberWithElement {
+public class DescriptorClassMember extends MemberChooserObjectBase implements ClassMemberWithElement {","Copying replaced with delegation, please, pay attention - I rebased on master and squash fix into existing commit.
",Why is this needed?
827,"@@ -35,6 +35,16 @@ target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.FI
 public annotation(retention = AnnotationRetention.RUNTIME, mustBeDocumented = true) class jvmStatic
 
 /**
+ * Specifies the name for the target platform element (Java method, JavaScript function)","Documentation should probably not mention JavaScript anymore
","* Specifies the name for the target platform element (Java method, JavaScrip"
828,"@@ -354,11 +360,11 @@ fun KtTypeParameterListOwner.addTypeParameter(typeParameter: KtTypeParameter): K
     val list = KtPsiFactory(this).createTypeParameterList(""<X>"")
     list.parameters[0].replace(typeParameter)
     val leftAnchor = when (this) {
-        is KtClass -> nameIdentifier ?: getClassOrInterfaceKeyword()
-        is KtNamedFunction -> funKeyword
-        is KtProperty -> valOrVarKeyword
-        else -> null
-    } ?: return null
+                         is KtClass -> nameIdentifier ?: getClassOrInterfaceKeyword()","There is a lot of unnecessary code formatting, which make harder to find what exactly author of PR changed. @Dimach, did was intentional and done by you or automatically changed by IntelliJ?",Why did you remove this?
829,"@@ -36,15 +40,18 @@ class UnnecessaryJavaUsageInspection : AbstractKotlinInspection(), CleanupLocalI
 
                 val selectorExpression = expression.selectorExpression ?: return
                 if (selectorExpression !is KtCallExpression) return
-                if (selectorExpression.valueArguments.size != 1) return
-                val value = selectorExpression.valueArguments[0].text
-                val pattern = expression.text.replace(value, ""$0"")
+                val value = selectorExpression.valueArguments.singleOrNull() ?: return
+
+                val calleeExpression = selectorExpression.calleeExpression as KtSimpleNameExpression","The calleeExpression is not always a KtSimpleNameExpression, so you should use a safe cast here.
",Why do we need this change?
830,"@@ -367,7 +368,8 @@ class ControlFlowInformationProvider private constructor(
         // Do not consider top-level properties
         if (containingDeclarationDescriptor is PackageFragmentDescriptor) return false
         var parentDeclaration = getElementParentDeclaration(writeValueInstruction.element)
-        while (true) {
+
+        loop@ while (true) {",I recommend some self-describing name for this label,Why is this needed?
831,"@@ -37,18 +37,19 @@ class AnnotatedClassDescriptor(classFqName: String) : AnnotatedElementDescriptor
 }
 
 class AnnotatedMethodDescriptor(classFqName: String, public val methodName: String) : AnnotatedElementDescriptor(classFqName) {
-    override fun equals(other: Any?) = other is AnnotatedMethodDescriptor && methodName == other.methodName
+    override fun equals(other: Any?) = other is AnnotatedMethodDescriptor && methodName == other.methodName && classFqName == other.classFqName
 
-    override fun hashCode() = methodName.hashCode()
+    override fun hashCode() =  methodName.hashCode() + classFqName.hashCode()","Is it the best way to combine hashcodes?
",Why do we need this change?
832,"@@ -371,6 +371,8 @@ class QuickFixRegistrar : QuickFixContributor {
 
         DATA_CLASS_NOT_PROPERTY_PARAMETER.registerFactory(AddValVarToConstructorParameterAction.QuickFixFactory)
 
-        NON_LOCAL_RETURN_NOT_ALLOWED.registerFactory(AddCrossInlineFix)
+        NON_LOCAL_RETURN_NOT_ALLOWED.registerFactory(ConvertExtensionToFunctionTypeFix)","This seems to be an accidental change, please revert
",Why do we need this change?
833,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }","Please, get rid of code duplication.
",I think it would be better 
834,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }
+
+        markLineNumber(expression);
+        v.mark(endLabel);
+
+        return StackValue.onStack(resultType);
+    }
+
+    private void generateSwitchCall(Map<Integer, Label> transitions, Label defaultLabel) {","What does ""call"" mean here?
",I think it would be better 
835,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }
+
+        markLineNumber(expression);
+        v.mark(endLabel);
+
+        return StackValue.onStack(resultType);
+    }
+
+    private void generateSwitchCall(Map<Integer, Label> transitions, Label defaultLabel) {
+        int[] keys = new int[transitions.size()];
+        Label[] labels = new Label[transitions.size()];
+        int i = 0;
+
+        for (Map.Entry<Integer,Label> transition : transitions.entrySet()) {
+            keys[i] = transition.getKey();
+            labels[i] = transition.getValue();
+
+            i++;
+        }
+
+        int hi = keys[keys.length-1];
+        int lo = keys[0];
+        long emptyCells = ((long)hi - (long)lo + 1) - keys.length;
+
+        boolean useTableSwitch = keys.length > 0 &&
+                                 10L * emptyCells <= (long) keys.length; // less then 10% of empty cells
+
+        if (!useTableSwitch) {
+            v.lookupswitch(defaultLabel, keys, labels);
+            return;
+        }
+
+        Label[] sparseLabels = new Label[hi-lo + 1];
+        Arrays.fill(sparseLabels, defaultLabel);
+
+        for (i = 0; i < keys.length; i++) {
+            sparseLabels[keys[i] - lo] = labels[i];
+        }
+
+        v.tableswitch(lo, hi, defaultLabel, sparseLabels);
+    }
+
+    private boolean doesConstantFitForSwitch(CompileTimeConstant constant) {","IDEA says this method can be static. And I believe it ;)
",I think it would be better 
836,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }
+
+        markLineNumber(expression);
+        v.mark(endLabel);
+
+        return StackValue.onStack(resultType);
+    }
+
+    private void generateSwitchCall(Map<Integer, Label> transitions, Label defaultLabel) {
+        int[] keys = new int[transitions.size()];
+        Label[] labels = new Label[transitions.size()];
+        int i = 0;
+
+        for (Map.Entry<Integer,Label> transition : transitions.entrySet()) {
+            keys[i] = transition.getKey();
+            labels[i] = transition.getValue();
+
+            i++;
+        }
+
+        int hi = keys[keys.length-1];
+        int lo = keys[0];
+        long emptyCells = ((long)hi - (long)lo + 1) - keys.length;
+
+        boolean useTableSwitch = keys.length > 0 &&
+                                 10L * emptyCells <= (long) keys.length; // less then 10% of empty cells
+
+        if (!useTableSwitch) {
+            v.lookupswitch(defaultLabel, keys, labels);
+            return;
+        }
+
+        Label[] sparseLabels = new Label[hi-lo + 1];
+        Arrays.fill(sparseLabels, defaultLabel);
+
+        for (i = 0; i < keys.length; i++) {
+            sparseLabels[keys[i] - lo] = labels[i];
+        }
+
+        v.tableswitch(lo, hi, defaultLabel, sparseLabels);
+    }
+
+    private boolean doesConstantFitForSwitch(CompileTimeConstant constant) {
+        if (constant == null || !(constant instanceof IntegerValueConstant)) {","`constant == null` can be removed, because ""instanceof"" is false for null anyway
",I think it would be better 
837,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }
+
+        markLineNumber(expression);
+        v.mark(endLabel);
+
+        return StackValue.onStack(resultType);
+    }
+
+    private void generateSwitchCall(Map<Integer, Label> transitions, Label defaultLabel) {
+        int[] keys = new int[transitions.size()];
+        Label[] labels = new Label[transitions.size()];
+        int i = 0;
+
+        for (Map.Entry<Integer,Label> transition : transitions.entrySet()) {
+            keys[i] = transition.getKey();
+            labels[i] = transition.getValue();
+
+            i++;
+        }
+
+        int hi = keys[keys.length-1];
+        int lo = keys[0];
+        long emptyCells = ((long)hi - (long)lo + 1) - keys.length;
+
+        boolean useTableSwitch = keys.length > 0 &&
+                                 10L * emptyCells <= (long) keys.length; // less then 10% of empty cells
+
+        if (!useTableSwitch) {
+            v.lookupswitch(defaultLabel, keys, labels);
+            return;
+        }
+
+        Label[] sparseLabels = new Label[hi-lo + 1];
+        Arrays.fill(sparseLabels, defaultLabel);
+
+        for (i = 0; i < keys.length; i++) {
+            sparseLabels[keys[i] - lo] = labels[i];
+        }
+
+        v.tableswitch(lo, hi, defaultLabel, sparseLabels);
+    }
+
+    private boolean doesConstantFitForSwitch(CompileTimeConstant constant) {
+        if (constant == null || !(constant instanceof IntegerValueConstant)) {
+            return false;
+        }
+
+        long value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).longValue() : ((Character)constant.getValue()).charValue();
+        return value >= Integer.MIN_VALUE &&
+               value <= Integer.MAX_VALUE;","This check seems redundant, because we already checked that constant is not `long`
",I think it would be better 
838,"@@ -3731,6 +3738,160 @@ else if (condition instanceof JetWhenConditionWithExpression) {
         }
     }
 
+    private StackValue generateSwitch(JetWhenExpression expression, Type subjectType, Type resultType, boolean isStatement) {
+        JetType subjectJetType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression.getSubjectExpression());
+        assert subjectJetType != null;
+
+        Map<Integer, Label> transitions = Maps.newTreeMap();
+
+        Label[] entryLabels = new Label[expression.getEntries().size()];
+        int entryLabelsCounter = 0;
+
+        Label elseLabel = new Label();
+        Label endLabel = new Label();
+        boolean hasElse = expression.getElseExpression() != null;
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            Label entryLabel = new Label();
+
+            for (JetWhenCondition condition : entry.getConditions()) {
+                assert condition instanceof JetWhenConditionWithExpression;
+
+                JetExpression conditionExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+                assert conditionExpression != null;
+
+                CompileTimeConstant constant = getCompileTimeConstant(conditionExpression, bindingContext);
+                assert doesConstantFitForSwitch(constant);
+
+                int value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).intValue() : ((Character)constant.getValue()).charValue();
+
+                if (!transitions.containsKey(value)) {
+                    transitions.put(value, entryLabel);
+                }
+            }
+
+            if (entry.isElse()) {
+                elseLabel = entryLabel;
+            }
+
+            entryLabels[entryLabelsCounter++] = entryLabel;
+        }
+
+        gen(expression.getSubjectExpression(), subjectType);
+        generateSwitchCall(
+                transitions,
+                //if there is no else-entry and it's statement then default --- endLabel
+                (hasElse || !isStatement) ? elseLabel : endLabel
+        );
+
+        //resolving entries' labels
+        int i = 0;
+        for (JetWhenEntry entry : expression.getEntries()) {
+            v.visitLabel(entryLabels[i++]);
+
+            FrameMap.Mark mark = myFrameMap.mark();
+            gen(entry.getExpression(), resultType);
+            mark.dropTo();
+
+            if (!entry.isElse()) {
+                v.goTo(endLabel);
+            }
+        }
+
+        //there is no else-entry but this is not statement, so we should return Unit
+        if (!hasElse && !isStatement) {
+            v.visitLabel(elseLabel);
+            // a result is expected
+            if (Boolean.TRUE.equals(bindingContext.get(BindingContext.EXHAUSTIVE_WHEN, expression))) {
+                // when() is supposed to be exhaustive
+                throwNewException(""kotlin/NoWhenBranchMatchedException"");
+            }
+            else {
+                // non-exhaustive when() with no else -> Unit must be expected
+                StackValue.putUnitInstance(v);
+            }
+        }
+
+        markLineNumber(expression);
+        v.mark(endLabel);
+
+        return StackValue.onStack(resultType);
+    }
+
+    private void generateSwitchCall(Map<Integer, Label> transitions, Label defaultLabel) {
+        int[] keys = new int[transitions.size()];
+        Label[] labels = new Label[transitions.size()];
+        int i = 0;
+
+        for (Map.Entry<Integer,Label> transition : transitions.entrySet()) {
+            keys[i] = transition.getKey();
+            labels[i] = transition.getValue();
+
+            i++;
+        }
+
+        int hi = keys[keys.length-1];
+        int lo = keys[0];
+        long emptyCells = ((long)hi - (long)lo + 1) - keys.length;
+
+        boolean useTableSwitch = keys.length > 0 &&
+                                 10L * emptyCells <= (long) keys.length; // less then 10% of empty cells
+
+        if (!useTableSwitch) {
+            v.lookupswitch(defaultLabel, keys, labels);
+            return;
+        }
+
+        Label[] sparseLabels = new Label[hi-lo + 1];
+        Arrays.fill(sparseLabels, defaultLabel);
+
+        for (i = 0; i < keys.length; i++) {
+            sparseLabels[keys[i] - lo] = labels[i];
+        }
+
+        v.tableswitch(lo, hi, defaultLabel, sparseLabels);
+    }
+
+    private boolean doesConstantFitForSwitch(CompileTimeConstant constant) {
+        if (constant == null || !(constant instanceof IntegerValueConstant)) {
+            return false;
+        }
+
+        long value = (constant.getValue() instanceof Number) ? ((Number)constant.getValue()).longValue() : ((Character)constant.getValue()).charValue();
+        return value >= Integer.MIN_VALUE &&
+               value <= Integer.MAX_VALUE;
+    }
+
+    private boolean canSwitchBeUsedIn(JetWhenExpression expression, Type subjectType) {
+        int typeSort = subjectType.getSort();
+
+        if (typeSort != Type.INT && typeSort != Type.CHAR && typeSort != Type.SHORT && typeSort != Type.BYTE) {
+            return false;
+        }
+
+        for (JetWhenEntry entry : expression.getEntries()) {
+            for (JetWhenCondition condition : entry.getConditions()) {
+                if (!(condition instanceof JetWhenConditionWithExpression)) {
+                    return false;
+                }
+
+                //ensure that expression is constant
+                JetExpression patternExpression = ((JetWhenConditionWithExpression) condition).getExpression();
+
+                if (patternExpression == null) {","Should be replaced with assert, because it can be null only for code with syntax errors.

Common rule: if some method of PSI (`JetExpression`, `JetWhenCondition`, `JetWhatever`...) is annotated as `@Nullable @IfNotParsed`, it returns null only if code has syntax errors. Front-end should be tolerant to nulls here, while back-end can be assert it.
",I think it would be better 
839,"@@ -375,6 +382,7 @@
                 <zipfileset src=""${dependencies}/jline.jar""/>
                 <zipfileset src=""${dependencies}/javaslang-2.0.6.jar""/>
                 <zipfileset src=""${protobuf.jar}""/>
+                <zipfileset src=""${tools.jar}""/>",This string must be removed due to licensing problems,"<zipfileset src=""${dependen"
840,"@@ -38,17 +37,27 @@ class SwitchConverter(private val codeConverter: CodeConverter) {
 
         val result = ArrayList<WhenEntry>()
         var pendingSelectors = ArrayList<WhenEntrySelector>()
+        var defaultSelector: WhenEntrySelector? = null
+        var defaultEntry: WhenEntry? = null
         for ((i, case) in cases.withIndex()) {
             if (case.label == null) { // invalid switch - no case labels
                 result.add(WhenEntry(listOf(ValueWhenEntrySelector(Expression.Empty).assignNoPrototype()), convertCaseStatementsToBody(cases, i)).assignNoPrototype())
                 continue
             }
-            pendingSelectors.add(codeConverter.convertStatement(case.label) as WhenEntrySelector)
+            (codeConverter.convertStatement(case.label) as WhenEntrySelector).run {","I'd extracted selector to a variable, then smart-cast on line 54 will calculate properly.",Why do we need this?
841,"@@ -3833,6 +3833,9 @@ public Unit invoke(InstructionAdapter v) {
                                 v.mark(nonnull);
                             }
                         }
+                        else if (value.type == Type.VOID_TYPE) {
+                            v.aconst(null);
+                        }
                         else {
                             v.dup();
                             generateInstanceOfInstruction(rightType);","Similar code is present in `generateInstanceOf` which probably means `Unit is Int?` is also affected?
",Why is this needed?
842,"@@ -386,6 +386,10 @@ else if (containingDeclaration instanceof PackageFragmentDescriptor) {
     @Override
     public void visitCallExpression(@NotNull JetCallExpression expression) {
         super.visitCallExpression(expression);
+        checkSamCall(expression);
+    }
+
+    public void checkSamCall(@NotNull JetCallElement expression) {","public?
",Why do we need this method?
843,"@@ -39,54 +39,111 @@ import kotlin.concurrent.read
 import kotlin.concurrent.write
 
 
+fun nowSeconds() = System.nanoTime() / 1000000000L
+
 class CompileServiceImpl<Compiler: CLICompiler<*>>(
         val registry: Registry,","How long this thing work? Does it shutdown itself?
",nit: `fun nowSeconds = Syst
844,"@@ -39,7 +39,10 @@ class SwitchConverter(private val codeConverter: CodeConverter) {
                 continue
             }
             pendingSelectors.add(codeConverter.convertStatement(case.label) as WhenEntrySelector)
-            if (case.statements.isNotEmpty()) {
+            if (!case.label.isDefaultCase && case.statements.isEmpty() && cases[i + 1]?.label!!.isDefaultCase){","You are accessing `cases[i+1]` without checking that `i+1` is a valid index in the `cases` collection.
",`cases[i + 1]?.label!!.isDe
845,"@@ -39,7 +39,9 @@ class ClassBody (
         builder append "" "" append lBrace append ""\n""
 
         if (!classKind.isEnum()) {
-            builder.append(membersFiltered, ""\n"")
+            builder.append(membersFiltered.sortedWith(Comparator { o1, o2 ->",Please extract variable to deduplicate this code,Why is this needed?
846,"@@ -39,7 +41,7 @@ class GenericFunction(val signature: String) : Comparable<GenericFunction> {
     var receiverAsterisk = false
     val inlineFamilies = HashMap<Family, Boolean>()
 
-    val buildFamilies = HashSet(defaultFamilies.toList())
+    val buildFamilies = HashSet(defaultFamilies.filter { it != RangesOfPrimitives && it != ProgressionsOfPrimitives }.toList())","Why is this filtering here? It seem to have no effect, anyway.
",Why do we need this?
847,"@@ -394,6 +394,8 @@ public static DiagnosticRenderer getRendererForDiagnostic(@NotNull Diagnostic di
         MAP.put(IS_ENUM_ENTRY, ""'is' over enum entry is not allowed, use comparison instead"");
         MAP.put(ENUM_ENTRY_AS_TYPE, ""Use of enum entry names as types is not allowed, use enum type instead"");
         MAP.put(USELESS_NULLABLE_CHECK, ""Non-null type is checked for instance of nullable type"");
+        MAP.put(USELESS_IS_CHECK, ""'is' check is always true"");
+        MAP.put(USELESS_IS_NOT_CHECK, ""'!is' check is always false"");","Then here:
```
MAP.put(USELESS_IS_CHECK, ""Check for instance is always ''{0}''"", TO_STRING);
```",MAP.put(USELESS_IS_NOT_CHEC
848,"@@ -3975,4 +3981,19 @@ private NonLocalReturnInfo(Type type, String name) {
             labelName = name;
         }
     }
+
+    private StackValue getCompileTimeConstant(@NotNull KtExpression expression) {","Combine this method with original one by adding checkPure flag, and create overload with original signature to keep old invocations
",private StackValue getCompileTimeConstant() {
849,"@@ -398,4 +401,13 @@ class CallCompleter(
         val expressionType = trace.getType(expression.receiverExpression)
         return expressionType != null && TypeUtils.isNullableType(expressionType)
     }
+
+    private fun MutableResolvedCall<*>.updateResultDataFlowInfoUsingEffects(bindingTrace: BindingTrace) {
+        val moduleDescriptor = DescriptorUtils.getContainingModule(this.resultingDescriptor?.containingDeclaration ?: return)
+
+        val resultDFIfromES = effectSystem.getResultDataFlowInfo(this, bindingTrace, moduleDescriptor)
+        this.dataFlowInfoForArguments.updateResultInfo(resultDFIfromES)
+
+        effectSystem.recordDefiniteInvocations(this, bindingTrace, moduleDescriptor)","This line appears in the last but one commit, when the language features were added. It's quite unclear for me, why it appears in this commit.",Why do we need this?
850,"@@ -4,5 +4,110 @@ package kotlin.js
  * Exposes the [Date API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) to Kotlin.
  */
 public external class Date() {
-    public fun getTime(): Double
+
+    constructor(timestamp: Long)
+    constructor(dateString: String)
+    constructor(year: Int,
+                month: Int = definedExternally,
+                date: Int = definedExternally,
+                hours: Int = definedExternally,
+                minutes: Int = definedExternally,
+                seconds: Int = definedExternally,
+                millis: Int = definedExternally)
+
+    public fun getDate(): Int = definedExternally
+    public fun getDay(): Int = definedExternally
+    public fun getFullYear(): Int = definedExternally
+    public fun getHours(): Int = definedExternally
+    public fun getMilliseconds(): Int = definedExternally
+    public fun getMinutes(): Int = definedExternally
+    public fun getMonth(): Int = definedExternally
+    public fun getSeconds(): Int = definedExternally
+    public fun getTime(): Long = definedExternally
+
+    public fun getTimezoneOffset(): Int = definedExternally
+    public fun getUTCDate(): Int = definedExternally
+    public fun getUTCDay(): Int = definedExternally
+    public fun getUTCFullYear(): Int = definedExternally
+    public fun getUTCHours(): Int = definedExternally
+    public fun getUTCMilliseconds(): Int = definedExternally
+    public fun getUTCMinutes(): Int = definedExternally
+    public fun getUTCMonth(): Int = definedExternally
+    public fun getUTCSeconds(): Int = definedExternally
+
+    @Deprecated(""Returns the year (usually 2-3 digits) in the specified date according to local time."",
+                ReplaceWith(""getFullYear""))
+    public fun getYear(): Int = definedExternally
+
+
+
+    public fun setDate(date: Int): Long = definedExternally
+    public fun setFullYear(year: Int,
+                           month: Int = definedExternally,
+                           day: Int = definedExternally): Long = definedExternally
+    public fun setHours(hours: Int,
+                        minutes: Int = definedExternally,
+                        seconds: Int = definedExternally,
+                        millis: Int = definedExternally): Long = definedExternally
+    public fun setMilliseconds(millis: Int): Long = definedExternally
+    public fun setMinutes(minutes: Int,
+                          seconds: Int = definedExternally,
+                          millis: Int = definedExternally): Long = definedExternally
+    public fun setMonth(month: Int,
+                        day: Int = definedExternally)
+    public fun setSeconds(seconds: Int,
+                          millis: Int = definedExternally): Long = definedExternally
+    public fun setTime(timeMillis: Long): Long = definedExternally
+    public fun setUTCDate(day: Int): Long = definedExternally
+    public fun setUTCFullYear(year: Int,
+                              month: Int,
+                              day: Int): Long = definedExternally
+    public fun setUTCHours(hours: Int,
+                           minutes: Int = definedExternally,
+                           seconds: Int = definedExternally,
+                           millis: Int): Long = definedExternally
+    public fun setUTCMilliseconds(millis: Int): Long = definedExternally
+    public fun setUTCMinutes(minutes: Int,
+                             seconds: Int = definedExternally,
+                             millis: Int = definedExternally): Long = definedExternally
+    public fun setUTCMonth(month: Int,
+                           day: Int = definedExternally): Long = definedExternally
+    public fun setUTCSeconds(seconds: Int,
+                             millis: Int = definedExternally): Long = definedExternally
+
+    @Deprecated(""Be aware that this feature may cease to work at any time."", ReplaceWith(""setFullYear""))
+    public fun setYear(year: Int): Long = definedExternally
+
+
+
+    public fun toDateString(): String = definedExternally
+    @Deprecated(""Be aware that this feature may cease to work at any time."", ReplaceWith(""toUTCString""))
+    public fun toGMTString(): String = definedExternally
+    public fun toISOString(): String = definedExternally
+    public fun toJSON(): String = definedExternally
+    public fun toLocaleDateString(locales: dynamic = definedExternally, /* String | Array<String> */
+                                  options: dynamic = definedExternally): String = definedExternally
+    public fun toLocaleString(locales: dynamic = definedExternally, /* String | Array<String> */
+                              options: dynamic = definedExternally): String = definedExternally
+    public fun toLocaleTimeString(locales: dynamic = definedExternally, /* String | Array<String> */
+                                  options: dynamic = definedExternally): String = definedExternally
+    public override fun toString(): String = definedExternally
+    public fun toTimeString(): String = definedExternally
+    public fun toUTCString(): String = definedExternally
+    public fun valueOf(): Long = definedExternally
+
+    companion object {
+        fun now(): Long = definedExternally",I think return type should not be `Long` here since it's not native JS type and it's emulated in Kotlin. Probably it should be `Number` or `Double`.,I don't think we need to deprecate this.
851,"@@ -4,66 +4,121 @@ import java.util.Timer
 import java.util.TimerTask
 import java.util.Date
 
+/**
+ * Schedules an [action] to be executed after the specified [delay] (expressed in milliseconds).
+ */
 public fun Timer.schedule(delay: Long, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     schedule(task, delay)
     return task
 }
 
+/**
+ * Schedules an [action] to be executed at the specified [time].
+ */
 public fun Timer.schedule(time: Date, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     schedule(task, time)
     return task
 }
 
+/**
+ * Schedules an [action] to be executed periodically, starting after the specified [delay] (expressed
+ * in milliseconds) and with the interval of [period] milliseconds between the end of the previous task
+ * and the start of the next one.
+ */
 public fun Timer.schedule(delay: Long, period: Long, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     schedule(task, delay, period)
     return task
 }
 
+/**
+ * Schedules an [action] to be executed periodically, starting at the specified [time] and with the
+ * interval of [period] milliseconds between the end of the previous task and the start of the next one.
+ */
 public fun Timer.schedule(time: Date, period: Long, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     schedule(task, time, period)
     return task
 }
 
+/**
+ * Schedules an [action] to be executed periodically, starting after the specified [delay] (expressed
+ * in milliseconds) and with the interval of [period] milliseconds between the start of the previous task
+ * and the start of the next one.
+ */
 public fun Timer.scheduleAtFixedRate(delay: Long, period: Long, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     scheduleAtFixedRate(task, delay, period)
     return task
 }
 
+/**
+ * Schedules an [action] to be executed periodically, starting at the specified [time] and with the
+ * interval of [period] milliseconds between the start of the previous task and the start of the next one.
+ */
 public fun Timer.scheduleAtFixedRate(time: Date, period: Long, action: TimerTask.() -> Unit): TimerTask {
     val task = timerTask(action)
     scheduleAtFixedRate(task, time, period)
     return task
 }
 
+/**
+ * Creates a timer that executes the specified [action] periodically, starting after the specified [initialDelay]
+ * (expressed in milliseconds) and with the interval of [period] milliseconds between the end of the previous task
+ * and the start of the next one.
+ *
+ * @param name the name to use for the thread which is running the timer.
+ * @param daemon if true, the thread is started as a daemon thread (the VM will exit when only daemon threads are running)
+ */
 public fun timer(name: String? = null, daemon: Boolean = false, initialDelay: Long = 0.toLong(), period: Long, action: TimerTask.() -> Unit): Timer {
     val timer = if (name == null) Timer(daemon) else Timer(name, daemon)
     timer.schedule(initialDelay, period, action)
     return timer
 }
 
+/**
+ * Creates a timer that executes the specified [action] periodically, starting at the specified [startAt] date
+ * and with the interval of [period] milliseconds between the end of the previous task and the start of the next one.
+ *
+ * @param name the name to use for the thread which is running the timer.
+ * @param daemon if true, the thread is started as a daemon thread (the VM will exit when only daemon threads are running)
+ */
 public fun timer(name: String? = null, daemon: Boolean = false, startAt: Date, period: Long, action: TimerTask.() -> Unit): Timer {
     val timer = if (name == null) Timer(daemon) else Timer(name, daemon)
     timer.schedule(startAt, period, action)
     return timer
 }
 
+/**
+ * Creates a timer that executes the specified [action] periodically, starting after the specified [initialDelay]
+ * (expressed in milliseconds) and with the interval of [period] milliseconds between the start of the previous task
+ * and the start of the next one.
+ *
+ * @param name the name to use for the thread which is running the timer.
+ * @param daemon if true, the thread is started as a daemon thread (the VM will exit when only daemon threads are running)
+ */
 public fun fixedRateTimer(name: String? = null, daemon: Boolean = false, initialDelay: Long = 0.toLong(), period: Long, action: TimerTask.() -> Unit): Timer {
     val timer = if (name == null) Timer(daemon) else Timer(name, daemon)
     timer.scheduleAtFixedRate(initialDelay, period, action)
     return timer
 }
 
+/**
+ * Creates a timer that executes the specified [action] periodically, starting at the specified [startAt] date
+ * and with the interval of [period] milliseconds between the start of the previous task and the start of the next one.
+ *
+ * @param name the name to use for the thread which is running the timer.
+ * @param daemon if true, the thread is started as a daemon thread (the VM will exit when only daemon threads are running)
+ */
 public fun fixedRateTimer(name: String? = null, daemon: Boolean = false, startAt: Date, period: Long, action: TimerTask.() -> Unit): Timer {
     val timer = if (name == null) Timer(daemon) else Timer(name, daemon)
     timer.scheduleAtFixedRate(startAt, period, action)
     return timer
 }
 
+deprecated(""Use the built-in SAM conversion instead"")","Shouldn't we update usages in this file to invoke TimerTask constructor directly?
",`expressed` -> `occurred`
852,"@@ -4,7 +4,7 @@ object A {
             ""text3""
 
 
-    val TEXT2 = ""text1\n""
-    + ""text2\n""
-    + ""text3""
+    val TEXT2 = (""text1\n""","If I were you, I would reduce space from 2 to 1 line. I think one is enough to make this object readable.",Why did you change this?
853,"@@ -4,8 +4,8 @@ internal class C {
     fun foo(): Int {
         KotlinObject.property1 = 1
         KotlinObject.property2 = 2
-        return KotlinObject.foo() +
+        return (KotlinObject.foo() +",The parentheses are only required if the line break is before the operator. In this case they should not be added.,I think this should be `KotlinObject.foo()`
854,"@@ -40,10 +40,224 @@ import org.gradle.api.UnknownDomainObjectException
 import org.gradle.api.initialization.dsl.ScriptHandler
 import org.jetbrains.kotlin.gradle.plugin.android.AndroidGradleWrapper
 import javax.inject.Inject
+import org.jetbrains.kotlin.gradle.tasks.Kotlin2JsCompile
+import org.gradle.api.tasks.Copy
+import org.gradle.api.file.SourceDirectorySet
+import kotlin.properties.Delegates
+import org.gradle.api.tasks.Delete
+import org.codehaus.groovy.runtime.MethodClosure
+import org.jetbrains.kotlin.gradle.tasks.RewritePathsInSourceMap
+import groovy.lang.Closure
 
 val DEFAULT_ANNOTATIONS = ""org.jebrains.kotlin.gradle.defaultAnnotations""
 
-open class KotlinPlugin [Inject] (val scriptHandler: ScriptHandler): Plugin<Project> {
+
+abstract class KotlinSourceSetProcessor<T : AbstractCompile>(val project: ProjectInternal,
+                                                             val javaBasePlugin: JavaBasePlugin,
+                                                             val sourceSet: SourceSet,
+                                                             val pluginName: String,
+                                                             val compileTaskNameSuffix: String,
+                                                             val taskDescription: String,
+                                                             val compilerClass: Class<T>) {
+    abstract protected fun doTargetSpecificProcessing()
+    val logger = Logging.getLogger(this.javaClass)
+
+    protected val sourceSetName: String = sourceSet.getName()
+    protected val sourceRootDir: String = ""src/${sourceSetName}/kotlin""
+    protected val absoluteSourceRootDir: String = project.getProjectDir().getPath() + ""/"" + sourceRootDir
+    protected val kotlinSourceSet: KotlinSourceSet? by Delegates.lazy { createKotlinSourceSet() }
+    protected val kotlinDirSet: SourceDirectorySet? by Delegates.lazy { createKotlinDirSet() }
+    protected val kotlinTask: T by Delegates.lazy { createKotlinCompileTask() }
+    protected val kotlinTaskName: String by Delegates.lazy { kotlinTask.getName() }
+
+    public fun run() {
+        if (kotlinSourceSet == null || kotlinDirSet == null) {
+            return
+        }
+        addSourcesToKotlinDirSet()
+        commonTaskConfiguration()
+        doTargetSpecificProcessing()
+    }
+
+    open protected fun createKotlinSourceSet(): KotlinSourceSet? =
+            if (sourceSet is HasConvention) {
+                logger.debug(""Creating KotlinSourceSet for source set ${sourceSet}"")
+                val kotlinSourceSet = KotlinSourceSetImpl(sourceSet.getName(), project.getFileResolver())
+                sourceSet.getConvention().getPlugins().put(pluginName, kotlinSourceSet)
+                kotlinSourceSet
+            } else {
+                null
+            }
+
+    open protected fun createKotlinDirSet(): SourceDirectorySet? {
+        val srcDir = project.file(sourceRootDir)
+        logger.debug(""Creating Kotlin SourceDirectorySet for source set ${kotlinSourceSet} with src dir ${srcDir}"")
+        val kotlinDirSet = kotlinSourceSet?.getKotlin()
+        kotlinDirSet?.srcDir(srcDir)
+        return kotlinDirSet
+    }
+
+    open protected fun addSourcesToKotlinDirSet() {
+        logger.debug(""Adding Kotlin SourceDirectorySet ${kotlinDirSet} to source set ${sourceSet}"")
+        sourceSet.getAllJava()?.source(kotlinDirSet)
+        sourceSet.getAllSource()?.source(kotlinDirSet)
+        sourceSet.getResources()?.getFilter()?.exclude(KSpec({ elem ->
+            kotlinDirSet!!.contains(elem.getFile())
+        }))
+    }
+
+    open protected fun createKotlinCompileTask(): T {
+        val name = sourceSet.getCompileTaskName(compileTaskNameSuffix)
+        logger.debug(""Creating kotlin compile task $name with class $compilerClass"")
+        return project.getTasks().create(name, compilerClass)
+    }
+
+    open protected fun commonTaskConfiguration() {
+        javaBasePlugin.configureForSourceSet(sourceSet, kotlinTask)
+        kotlinTask.setDescription(taskDescription)
+        kotlinTask.source(kotlinDirSet)
+    }
+}
+
+class Kotlin2JvmSourceSetProcessor(
+        project: ProjectInternal,
+        javaBasePlugin: JavaBasePlugin,
+        sourceSet: SourceSet,
+        val scriptHandler: ScriptHandler)
+: KotlinSourceSetProcessor<KotlinCompile>(
+        project, javaBasePlugin, sourceSet,
+        pluginName = ""kotlin"",
+        compileTaskNameSuffix = ""kotlin"",
+        taskDescription = ""Compiles the $sourceSet.kotlin."",
+        compilerClass = javaClass()) {
+
+    override fun doTargetSpecificProcessing() {
+        // store kotlin classes in separate directory. They will serve as class-path to java compiler
+        val kotlinOutputDir = File(project.getBuildDir(), ""kotlin-classes/${sourceSetName}"")
+        kotlinTask.kotlinDestinationDir = kotlinOutputDir
+
+        val javaTask = project.getTasks().findByName(sourceSet.getCompileJavaTaskName()) as AbstractCompile?
+
+        if (javaTask != null) {
+            javaTask.dependsOn(kotlinTaskName)
+            val javacClassPath = javaTask.getClasspath() + project.files(kotlinTask.kotlinDestinationDir);
+            javaTask.setClasspath(javacClassPath)
+        }
+    }
+}
+
+
+class Kotlin2JsSourceSetProcessor(
+        project: ProjectInternal,
+        javaBasePlugin: JavaBasePlugin,
+        sourceSet: SourceSet,
+        val scriptHandler: ScriptHandler
+) : KotlinSourceSetProcessor<Kotlin2JsCompile>(
+        project, javaBasePlugin, sourceSet,
+        pluginName = ""kotlin2js"",
+        taskDescription = ""Compiles the kotlin sources in $sourceSet to JavaScript."",
+        compileTaskNameSuffix = ""kotlin2Js"",
+        compilerClass = javaClass<Kotlin2JsCompile>()) {
+    val copyKotlinJsTaskName = sourceSet.getTaskName(""copy"", ""kotlinJs"")
+    val clean = project.getTasks().findByName(""clean"")
+    val compileJava = project.getTasks().findByName(sourceSet.getCompileJavaTaskName()) as AbstractCompile?","Why we need javaTask?
",Why do we need this?
855,"@@ -40,10 +40,224 @@ import org.gradle.api.UnknownDomainObjectException
 import org.gradle.api.initialization.dsl.ScriptHandler
 import org.jetbrains.kotlin.gradle.plugin.android.AndroidGradleWrapper
 import javax.inject.Inject
+import org.jetbrains.kotlin.gradle.tasks.Kotlin2JsCompile
+import org.gradle.api.tasks.Copy
+import org.gradle.api.file.SourceDirectorySet
+import kotlin.properties.Delegates
+import org.gradle.api.tasks.Delete
+import org.codehaus.groovy.runtime.MethodClosure
+import org.jetbrains.kotlin.gradle.tasks.RewritePathsInSourceMap
+import groovy.lang.Closure
 
 val DEFAULT_ANNOTATIONS = ""org.jebrains.kotlin.gradle.defaultAnnotations""
 
-open class KotlinPlugin [Inject] (val scriptHandler: ScriptHandler): Plugin<Project> {
+
+abstract class KotlinSourceSetProcessor<T : AbstractCompile>(val project: ProjectInternal,
+                                                             val javaBasePlugin: JavaBasePlugin,
+                                                             val sourceSet: SourceSet,
+                                                             val pluginName: String,
+                                                             val compileTaskNameSuffix: String,
+                                                             val taskDescription: String,
+                                                             val compilerClass: Class<T>) {
+    abstract protected fun doTargetSpecificProcessing()
+    val logger = Logging.getLogger(this.javaClass)
+
+    protected val sourceSetName: String = sourceSet.getName()
+    protected val sourceRootDir: String = ""src/${sourceSetName}/kotlin""
+    protected val absoluteSourceRootDir: String = project.getProjectDir().getPath() + ""/"" + sourceRootDir
+    protected val kotlinSourceSet: KotlinSourceSet? by Delegates.lazy { createKotlinSourceSet() }
+    protected val kotlinDirSet: SourceDirectorySet? by Delegates.lazy { createKotlinDirSet() }
+    protected val kotlinTask: T by Delegates.lazy { createKotlinCompileTask() }
+    protected val kotlinTaskName: String by Delegates.lazy { kotlinTask.getName() }
+
+    public fun run() {
+        if (kotlinSourceSet == null || kotlinDirSet == null) {
+            return
+        }
+        addSourcesToKotlinDirSet()
+        commonTaskConfiguration()
+        doTargetSpecificProcessing()
+    }
+
+    open protected fun createKotlinSourceSet(): KotlinSourceSet? =
+            if (sourceSet is HasConvention) {
+                logger.debug(""Creating KotlinSourceSet for source set ${sourceSet}"")
+                val kotlinSourceSet = KotlinSourceSetImpl(sourceSet.getName(), project.getFileResolver())
+                sourceSet.getConvention().getPlugins().put(pluginName, kotlinSourceSet)
+                kotlinSourceSet
+            } else {
+                null
+            }
+
+    open protected fun createKotlinDirSet(): SourceDirectorySet? {
+        val srcDir = project.file(sourceRootDir)
+        logger.debug(""Creating Kotlin SourceDirectorySet for source set ${kotlinSourceSet} with src dir ${srcDir}"")
+        val kotlinDirSet = kotlinSourceSet?.getKotlin()
+        kotlinDirSet?.srcDir(srcDir)
+        return kotlinDirSet
+    }
+
+    open protected fun addSourcesToKotlinDirSet() {
+        logger.debug(""Adding Kotlin SourceDirectorySet ${kotlinDirSet} to source set ${sourceSet}"")
+        sourceSet.getAllJava()?.source(kotlinDirSet)
+        sourceSet.getAllSource()?.source(kotlinDirSet)
+        sourceSet.getResources()?.getFilter()?.exclude(KSpec({ elem ->
+            kotlinDirSet!!.contains(elem.getFile())
+        }))
+    }
+
+    open protected fun createKotlinCompileTask(): T {
+        val name = sourceSet.getCompileTaskName(compileTaskNameSuffix)
+        logger.debug(""Creating kotlin compile task $name with class $compilerClass"")
+        return project.getTasks().create(name, compilerClass)
+    }
+
+    open protected fun commonTaskConfiguration() {
+        javaBasePlugin.configureForSourceSet(sourceSet, kotlinTask)
+        kotlinTask.setDescription(taskDescription)
+        kotlinTask.source(kotlinDirSet)
+    }
+}
+
+class Kotlin2JvmSourceSetProcessor(
+        project: ProjectInternal,
+        javaBasePlugin: JavaBasePlugin,
+        sourceSet: SourceSet,
+        val scriptHandler: ScriptHandler)
+: KotlinSourceSetProcessor<KotlinCompile>(
+        project, javaBasePlugin, sourceSet,
+        pluginName = ""kotlin"",
+        compileTaskNameSuffix = ""kotlin"",
+        taskDescription = ""Compiles the $sourceSet.kotlin."",
+        compilerClass = javaClass()) {
+
+    override fun doTargetSpecificProcessing() {
+        // store kotlin classes in separate directory. They will serve as class-path to java compiler
+        val kotlinOutputDir = File(project.getBuildDir(), ""kotlin-classes/${sourceSetName}"")
+        kotlinTask.kotlinDestinationDir = kotlinOutputDir
+
+        val javaTask = project.getTasks().findByName(sourceSet.getCompileJavaTaskName()) as AbstractCompile?
+
+        if (javaTask != null) {
+            javaTask.dependsOn(kotlinTaskName)
+            val javacClassPath = javaTask.getClasspath() + project.files(kotlinTask.kotlinDestinationDir);
+            javaTask.setClasspath(javacClassPath)
+        }
+    }
+}
+
+
+class Kotlin2JsSourceSetProcessor(
+        project: ProjectInternal,
+        javaBasePlugin: JavaBasePlugin,
+        sourceSet: SourceSet,
+        val scriptHandler: ScriptHandler
+) : KotlinSourceSetProcessor<Kotlin2JsCompile>(
+        project, javaBasePlugin, sourceSet,
+        pluginName = ""kotlin2js"",
+        taskDescription = ""Compiles the kotlin sources in $sourceSet to JavaScript."",
+        compileTaskNameSuffix = ""kotlin2Js"",
+        compilerClass = javaClass<Kotlin2JsCompile>()) {
+    val copyKotlinJsTaskName = sourceSet.getTaskName(""copy"", ""kotlinJs"")
+    val clean = project.getTasks().findByName(""clean"")
+    val compileJava = project.getTasks().findByName(sourceSet.getCompileJavaTaskName()) as AbstractCompile?
+
+    val defaultKotlinDestinationDir = File(project.getBuildDir(), ""kotlin2js/${sourceSetName}"")
+    private fun kotlinTaskDestinationDir(): File? = kotlinTask.kotlinDestinationDir
+    private fun kotlinJsDestinationDir(): File? = if (kotlinTask.outputFile() == null) {
+        null
+    } else {
+        File(kotlinTask.outputFile()).directory
+    }
+
+    private fun copyKotlinJsTaskOutput(): String? = if (kotlinJsDestinationDir() == null) {
+        null
+    } else {
+        val copyTask = project.getTasks().getByName(copyKotlinJsTaskName) as Copy
+        ""${copyTask.getDestinationDir()}/kotlin.js""
+    }
+
+    private fun kotlinSourcePathsForSourceMap() = sourceSet.getAllSource()
+            .map { it.path }
+            .filter { it.endsWith("".kt"") }
+            .map { it.replace(absoluteSourceRootDir, kotlinTask.sourceMapDestinationDir().getPath()) }
+
+    private fun shouldGenerateSourceMap() = kotlinTask.kotlinOptions.sourceMap
+
+    override fun doTargetSpecificProcessing() {
+        val version = project.getProperties()[""kotlin.gradle.plugin.version""] as String
+        val jsLibraryJar = GradleUtils(scriptHandler).resolveDependencies(""org.jetbrains.kotlin:kotlin-js-library:$version"").map { it.getAbsolutePath() }[0]
+
+        kotlinTask.kotlinOptions.libraryFiles = array(jsLibraryJar)
+        kotlinTask.kotlinDestinationDir = defaultKotlinDestinationDir
+
+        compileJava?.dependsOn(kotlinTaskName)
+        clean?.dependsOn(""clean"" + kotlinTaskName.capitalize())
+
+        createCopyKotlinJsTask(jsLibraryJar)
+        createCopyKotlinSourcesForSourceMapTask()","I think we should not be able to copy source files.
",Why do we need this?
856,"@@ -40,9 +41,12 @@ class KotlinClassFinderTest : KotlinTestWithEnvironmentManagement() {
         val environment = createEnvironment(tmpdir)
         val project = environment.project
 
+        val classFinder = createClassFinder(project)","Here you also should create your own separate test, and leave the old one as is. ",Why do we need this?
857,"@@ -41,12 +41,21 @@
 import org.jetbrains.kotlin.utils.KotlinPaths;
 import org.jetbrains.kotlin.utils.PathUtil;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Collections;
 import java.util.List;
 
 public class ScriptTest {
+
+    //@Before
+    //public void setUp() throws Exception {
+    //    // set to false if not present or set to true or unknown (empty considered true)
+    //    if (System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY)?.let { it.toBooleanLenient() ?: true } ?: true )
+    //    System.setProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY, ""false"")
+    //}
+","Why is this needed here?
",Should this be removed?
858,"@@ -410,6 +410,9 @@","ignore this file
",Why is this needed?
859,"@@ -4118,6 +4118,59 @@ public void testTypesAlreadyImplicit() throws Exception {
         
     }
     
+    @TestMetadata(""idea/testData/intentions/invertIfCondition"")
+    public static class InvertIfCondition extends AbstractCodeTransformationTest {
+        public void testAllFilesPresentInInvertIfCondition() throws Exception {
+            JetTestUtils.assertAllTestsPresentByMetadata(this.getClass(), ""org.jetbrains.jet.generators.tests.TestsPackage"", new File(""idea/testData/intentions/invertIfCondition""), Pattern.compile(""^(.+)\\.kt$""), true);
+        }
+        
+        @TestMetadata(""binaryExpression.kt"")
+        public void testBinaryExpression() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/binaryExpression.kt"");
+        }
+        
+        @TestMetadata(""booleanLiteral.kt"")
+        public void testBooleanLiteral() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/booleanLiteral.kt"");
+        }
+        
+        @TestMetadata(""forLoopWithMultipleExpressions.kt"")
+        public void testForLoopWithMultipleExpressions() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/forLoopWithMultipleExpressions.kt"");
+        }
+        
+        @TestMetadata(""functionWithReturnExpression.kt"")
+        public void testFunctionWithReturnExpression() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/functionWithReturnExpression.kt"");
+        }
+        
+        @TestMetadata(""ifExpressionInsideForLoop.kt"")
+        public void testIfExpressionInsideForLoop() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/ifExpressionInsideForLoop.kt"");
+        }
+        
+        @TestMetadata(""ifExpressionWithReturn.kt"")
+        public void testIfExpressionWithReturn() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/ifExpressionWithReturn.kt"");
+        }
+        
+        @TestMetadata(""invertableOperator.kt"")
+        public void testInvertableOperator() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/invertableOperator.kt"");
+        }
+        
+        @TestMetadata(""negatedExpression.kt"")
+        public void testNegatedExpression() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/negatedExpression.kt"");
+        }
+        
+        @TestMetadata(""simple.kt"")
+        public void testSimple() throws Exception {
+            doTestInvertIfCondition(""idea/testData/intentions/invertIfCondition/simple.kt"");
+        }
+        
+    }
+    ","Please add some tests for the cases where ""if"" is used as an expression, like 
`val t = if (a > 0) a else -a`
Combinations of valued ifs with returns and other ""jumps"" is of particular interest, e.g. `return if ...` or `val t = if (a > 0) a else return 0`, etc.
",I don't think we need this file.
860,"@@ -414,6 +414,14 @@ class CollectionTest {
         expect(arrayList(2, 3, 1)) { list }
     }
 
+    test fun sum() {
+        expect(0) {ArrayList<Int>().sum()}
+        expect(14) {arrayListOf(2,3,9).sum()}
+        expect(3.0) {arrayListOf(1.0,2.0).sum()}
+        expect(3000000000000) {arrayListOf<Long>(1000000000000,2000000000000).sum()}","Formatting: space after comma
",This should be `arrayListOf<Long>(10000000000
861,"@@ -423,6 +423,13 @@ public header inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequen
 public header inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M
 
 /**
+ * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations
+ * using the specified [keySelector] function to extract a key from each character.
+ */
+@SinceKotlin(""1.1"")
+public header inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K>",why there is specialization here? the implementations look the same,I think this should be `1.2`
862,"@@ -424,6 +425,24 @@ class Converter private constructor(
         }
     }
 
+
+    private fun specialAnnotationPropertyCases(field: PsiField): Annotations {
+        val javaSerializableInterface = PsiType.getTypeByName(""java.io.Serializable"", project, GlobalSearchScope.allScope(project)).resolve()","It's a minor issue, but the correct way is to use `field.getResolveScope()` instead of `allScope` here. Otherwise you may get incorrect results if the project uses multiple JDKs in different modules.
",Why do we need this?
863,"@@ -428,4 +428,37 @@ class KotlinGradleIT: BaseGradleIT() {
             assertSuccessful()
         }
     }
+
+    @Test
+    fun testGradleJavaIcWorking() {
+        val project = Project(""kotlinJavaProject"", ""2.14.1"")","What about newer Gradle versions?
Btw, it would be interesting to test if Java compile avoidance works in this case with the Gradle 3.4 (in other words that Java is not compiled if Kotlin public API is not changed). ","This should be `@Test(groups = ""functional"")`"
864,"@@ -43,6 +83,15 @@ public trait MutableListIterator<T> : ListIterator<T>, MutableIterator<T> {
 
     // Modification Operations
     override fun remove(): Unit
+
+    /**
+     * Replaces the last element returned by [next] or [previous] with the specified element [e].
+     */
     public fun set(e: T): Unit
+
+    /**
+     * Adds the specified element [e] into the underlying collection immediately before the element that would be
+     * returned by [next].","Will it affect what is returned next? Unclear from the text. What if previous was called?
",I'm not sure if this is the best name for this method. It's not clear to me what it does. Maybe something like `replace`?
865,"@@ -439,6 +443,13 @@ class PatternMatchingTypingVisitor internal constructor(facade: ExpressionTyping
             context.trace.report(Errors.USELESS_NULLABLE_CHECK.on(element as KtNullableType))
         }
         checkTypeCompatibility(context, targetType, subjectType, typeReferenceAfterIs)
+        if (!subjectType.containsError() && !targetType.containsError() && subjectType.isSubtypeOf(targetType)) {","Note that this isn't correct for platform types (see https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)

Currently there will be warning for case like this:
```
// Java
class A {
  static A create() { return null; }
}
--
// Kotlin
fun test() {
  A.create() is A // false warning 
}
```",Why do we need this check?
866,"@@ -44,7 +44,7 @@ object MakeVisibleFactory  : KotlinIntentionActionsFactory() {
 
         val module = DescriptorUtils.getContainingModule(descriptor)
         val targetVisibilities = when (descriptor.visibility) {
-            PRIVATE, INVISIBLE_FAKE -> if (module != usageModule) listOf(PUBLIC) else listOf(PUBLIC, INTERNAL)
+            PRIVATE, INVISIBLE_FAKE -> if (module != usageModule) listOf(PUBLIC) else listOf(PUBLIC, INTERNAL, PROTECTED)","It's not so easy, because `protected` should not be offered if member is referenced not from a subclass. Please add necessary checks here and such a test.",Why is this needed?
867,"@@ -45,15 +46,7 @@ class JoinBlockIntoSingleStatementHandler : JoinRawLinesHandlerDelegate {
             // if outer if has else-branch and inner does not have it, do not remove braces otherwise else-branch will belong to different if!","I can't unify the check because while the intention is simply not available, the join handler still has to go into this branch.
",if
868,"@@ -45,6 +47,13 @@ public abstract class AbstractReplInterpreterTest : UsefulTestCase() {
 
     private data class OneLine(val code: String, val expected: String)
 
+    override fun setUp() {
+        super.setUp()
+        // set to false if not present or set to true or unknown (empty considered true)
+        if (System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY)?.let { it.toBooleanLenient() ?: true } ?: true )","This could be written as

```
if (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = false)) {
```
",I don't think this is needed.
869,"@@ -45,6 +49,37 @@ import org.jetbrains.kotlin.resolve.lazy.KotlinCodeAnalyzer
 import org.jetbrains.kotlin.resolve.lazy.ResolveSession
 import org.jetbrains.kotlin.resolve.lazy.declarations.DeclarationProviderFactory
 
+private fun StorageComponentContainer.configureJavaTopDownAnalysisWithJavac(
+        moduleContentScope: GlobalSearchScope,
+        project: Project,
+        lookupTracker: LookupTracker",I think it's better to remove this function and add boolean flag `useJavac` to the next one instead. The code is mostly the same,nit: `fun` -> `function`
870,"@@ -454,3 +454,17 @@ fun checkReservedPrefixWord(sink: DiagnosticSink, element: PsiElement, word: Str
     }
 }
 
+fun KtNameReferenceExpression.getPrimaryConstructorParameterWithSameName(): KtParameter? {","I think this is far too specific to live in a general PSI utlilities class; I'd move it into the quickfix file.
",
871,"@@ -454,3 +454,17 @@ fun checkReservedPrefixWord(sink: DiagnosticSink, element: PsiElement, word: Str
     }
 }
 
+fun KtNameReferenceExpression.getPrimaryConstructorParameterWithSameName(): KtParameter? {
+    return getPrimaryConstructorParameterWithName(getReferencedName())
+}
+
+private fun KtElement.getPrimaryConstructorParameterWithName(name: String): KtParameter? {","The name of this function doesn't describe what it does. A more descriptive name would be ""findContainingClassConstructorParameterWithName"" (which is long enough to hint that it may be better to split the logic: a function to generate a sequence of outer classes for a class and a single-line call to find the parameter of the class by name).
",`getPrimaryConstructorParameterWithName` -> `getPrimaryConstructorParameter`
872,"@@ -46,15 +84,91 @@ public val File.extension: String
     }
 
 /**
+ * Replaces all separators in the string used to separate directories with system ones and returns the resulting string.
+ */
+public fun String.separatorsToSystem(): String {
+    val otherSep = if (File.separator == ""/"") ""\\"" else ""/""
+    return replace(otherSep, File.separator)
+}
+
+/**
+ * Replaces all path separators in the string with system ones and returns the resulting string.
+ */
+public fun String.pathSeparatorsToSystem(): String {
+    val otherSep = if (File.pathSeparator == "":"") "";"" else "":""
+    return replace(otherSep, File.pathSeparator)
+}
+
+/**
+ * Replaces path and directories separators with corresponding system ones and returns the resulting string.
+ */
+public fun String.allSeparatorsToSystem(): String {
+    return separatorsToSystem().pathSeparatorsToSystem()
+}
+
+/**
+ * Returns a pathname of this file with all path separators replaced with File.pathSeparator
+ */
+public fun File.separatorsToSystem(): String {
+    return toString().separatorsToSystem()
+}
+
+/**
+ * Returns file's name without an extension.
+ */
+public val File.nameWithoutExtension: String
+    get() = name.substringBeforeLast(""."")
+
+/**
  * Returns true if the given file is in the same directory or a descendant directory
  */
 public fun File.isDescendant(file: File): Boolean {
     return file.directory.canonicalPath.startsWith(directory.canonicalPath)
 }
-
 /**
- * Returns the relative path of the given descendant of this file if it is a descendant
+ * Returns path of this file relatively to the given directory.
+ * Note that the base file is treated as a directory.
+ * If this file matches the base directory, then ""."" will be returned.
  */
+public fun File.relativeTo(base: File): String {","Shouldn't it return File instead?
","`replace(File.pathSeparator, File.separator)`"
873,"@@ -46,15 +84,91 @@ public val File.extension: String
     }
 
 /**
+ * Replaces all separators in the string used to separate directories with system ones and returns the resulting string.
+ */
+public fun String.separatorsToSystem(): String {
+    val otherSep = if (File.separator == ""/"") ""\\"" else ""/""
+    return replace(otherSep, File.separator)
+}
+
+/**
+ * Replaces all path separators in the string with system ones and returns the resulting string.
+ */
+public fun String.pathSeparatorsToSystem(): String {
+    val otherSep = if (File.pathSeparator == "":"") "";"" else "":""
+    return replace(otherSep, File.pathSeparator)
+}
+
+/**
+ * Replaces path and directories separators with corresponding system ones and returns the resulting string.
+ */
+public fun String.allSeparatorsToSystem(): String {
+    return separatorsToSystem().pathSeparatorsToSystem()
+}
+
+/**
+ * Returns a pathname of this file with all path separators replaced with File.pathSeparator
+ */
+public fun File.separatorsToSystem(): String {
+    return toString().separatorsToSystem()
+}
+
+/**
+ * Returns file's name without an extension.
+ */
+public val File.nameWithoutExtension: String
+    get() = name.substringBeforeLast(""."")
+
+/**
  * Returns true if the given file is in the same directory or a descendant directory
  */
 public fun File.isDescendant(file: File): Boolean {
     return file.directory.canonicalPath.startsWith(directory.canonicalPath)
 }
-
 /**
- * Returns the relative path of the given descendant of this file if it is a descendant
+ * Returns path of this file relatively to the given directory.
+ * Note that the base file is treated as a directory.
+ * If this file matches the base directory, then ""."" will be returned.
  */
+public fun File.relativeTo(base: File): String {
+    val thisCanonical = canonicalPath
+    val baseCanonical = base.canonicalPath
+    if (thisCanonical.equals(baseCanonical)) {
+        return "".""
+    }
+
+    fun String.longestCommonPrefixLen(o: String): Int {
+        var i = 0
+        val len = length
+        val oLen = o.length
+        while (i < len && i < oLen && this[i] == o[i]) {
+            i++
+        }
+        return i
+    }
+
+    val commonPrefLen = thisCanonical.longestCommonPrefixLen(baseCanonical)
+    val thisSuffix = thisCanonical.substring(commonPrefLen + if (commonPrefLen == baseCanonical.length) 1 else 0)
+    val baseSuffix = baseCanonical.substring(commonPrefLen + if (commonPrefLen == thisCanonical.length) 1 else 0)
+    val separator = File.separator.charAt(0)
+    val ups = if (baseSuffix.isEmpty()) 0 else baseSuffix.count { it == separator } + 1
+    val result = StringBuilder()
+    for (i in 1 .. ups) {
+        if (i != 1) {
+            result.append(separator)
+        }
+        result.append("".."")
+    }
+    if (commonPrefLen != thisCanonical.length) {
+        if (result.length() != 0) {
+            result.append(separator)
+        }
+        result.append(thisSuffix)
+    }
+    return result.toString()
+}
+
+deprecated(""Use relativeTo() functin instead"")","typo: functin 
",Why do we need this?
874,"@@ -46,7 +45,7 @@ internal fun MethodNode.getParametersInfo(containingClass: ClassNode): List<Para
     for (index in startParameterIndex..parameterTypes.lastIndex) {
         val type = parameterTypes[index]
         var name = parameters.getOrNull(index - startParameterIndex)?.name
-                   ?: localVariables.getOrNull(index + (if (isStatic) 0 else 1))?.name
+                   ?: localVariables.getOrNull(index)?.name
                    ?: ""p${index - startParameterIndex}""","@yanex Removing this offset fixes https://youtrack.jetbrains.com/issue/KT-15024, but I'm not sure exactly what the offset was for in the first place. Could you let me know what it's for and I can update this PR if needed. I have included a static method in the test and it still works fine. ",Why this change?
875,"@@ -46,7 +47,17 @@ public String getFamilyName() {
 
     @Override
     public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
-        return file instanceof JetFile && getExclExclElement(editor, file) != null;
+        if (file instanceof JetFile) {
+            PsiElement exclExcl = getExclExclElement(editor, file);
+            if (exclExcl != null) {
+                PsiElement element = PsiTreeUtil.nextLeaf(exclExcl);
+                if (element instanceof LeafPsiElement && ((LeafPsiElement) element).getElementType() != JetTokens.DOT) {","Unfortunately I didn't understand how to easily verify that we are inside the JetDotQualified element, so, I think that the check for the next leaf is not bad too.
",Why do we need this check?
876,"@@ -46,7 +48,18 @@ public static void addDelegatedMembers(@NotNull BindingTrace trace, @NotNull Jet
                             type.getMemberScope().getAllDescriptors(),
                             Predicates.instanceOf(CallableMemberDescriptor.class));
                     Collection<CallableMemberDescriptor> descriptors = generateDelegatedMembers(classDescriptor, callableDescriptors);
+                    outer:
                     for (CallableMemberDescriptor descriptor : descriptors) {
+                        for (CallableMemberDescriptor existingDescriptor : classDescriptor.getAllCallableMembers()) {","Seems like you haven't updated from our trunk for a while. There is a conflict on this change. I'll resolve it manually, but in the future it would be a good idea to update frequently.
",Why do we need this outer label?
877,"@@ -47,18 +66,23 @@ interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesReso
     }
 }
 
+// is File a could type to use here?
+// No way to get script name if file is not present, should add another property (val fileName: String)
 interface ScriptContents {
     val file: File?
     val annotations: Iterable<Annotation>",Maybe use `Collection` here?,I don't think this is the right way to do it.
878,"@@ -47,18 +66,23 @@ interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesReso
     }
 }
 
+// is File a could type to use here?
+// No way to get script name if file is not present, should add another property (val fileName: String)
 interface ScriptContents {
     val file: File?
     val annotations: Iterable<Annotation>
     val text: CharSequence?",Why not `String?`?,I don't think this is the right way to do it.
879,"@@ -47,18 +66,23 @@ interface DependenciesResolver : @Suppress(""DEPRECATION"") ScriptDependenciesReso
     }
 }
 
+// is File a could type to use here?
+// No way to get script name if file is not present, should add another property (val fileName: String)
 interface ScriptContents {
     val file: File?
     val annotations: Iterable<Annotation>
     val text: CharSequence?
 
+    // nothing to discuss, for compatibility with previous version
     @Deprecated(""Use DependenciesResolver interface"")
     data class Position(val line: Int, val col: Int)
 }
 
+// ScriptReport -> ScriptDiagnostic
 data class ScriptReport(val message: String, val severity: Severity = ScriptReport.Severity.ERROR, val position: Position? = null) {
     data class Position(val startLine: Int, val startColumn: Int, val endLine: Int? = null, val endColumn: Int? = null)
     enum class Severity { ERROR, WARNING, INFO, DEBUG }
 }
 
-fun ScriptDependencies.asSuccess(): ResolveResult.Success = ResolveResult.Success(this)
\ No newline at end of file
+// should we expose this helper?
+fun ScriptDependencies.asSuccess(): ResolutionResult.Success = ResolutionResult.Success(this)","I think, we should not",I don't think we need to expose this helper. It's only used in one place.
880,"@@ -47,6 +48,9 @@ public void updateInfo(@NotNull ValueArgument valueArgument, @NotNull DataFlowIn
             throw new IllegalStateException();
         }
 
+        @Override
+        public void updateResultInfo(@NotNull DataFlowInfo dataFlowInfo) { }",Should we throw here `IllegalStateException`?,public void updateResultInfo(DataFlowInfo dataFlowInfo) {
881,"@@ -47,7 +47,7 @@ public class AddBracesIntention : JetSelfTargetingIntention<JetExpressionImpl>(""
         val jetBlockElement = element.findBlockInExpression(expressionKind)","[this is a dummy comment, please ignore it]
",jetBlockElement
882,"@@ -48,7 +48,7 @@ class JCClass<out T : JCTree.JCClassDecl>(tree: T,
         get() = tree.modifiers.isAbstract
 
     override val isStatic
-        get() = outerClass?.isInterface ?: tree.modifiers.isStatic
+        get() = if (outerClass?.isInterface ?: false) true else tree.modifiers.isStatic","It's better to write here

```
(outerClass?.isInterface ?: false) || tree.modifiers.isStatic
```",get() = outerClass?.isInterface ?: tree.modifiers.isStati
883,"@@ -48,7 +48,8 @@ class ReplaceContainsIntention : SelfTargetingRangeIntention<KtDotQualifiedExpre
         if (!element.isReceiverExpressionWithValue()) return null
 
         val functionDescriptor = getFunctionDescriptor(element) ?: return null
-        if (!functionDescriptor.isOperator || !OperatorChecks.check(functionDescriptor).isSuccess) return null
+
+        if (!functionDescriptor.isOperator) return null","This will break the use of the intention with Java methods, which don't use an explicit `operator` modifier but still can be used as operators. The correct fix is to replace || with && in the original check.
",Why is this change needed?
884,"@@ -48,8 +56,11 @@ else if (argument instanceof VarargValueArgument) {
                 generateOther(i, argument);
             }
         }
-
-        return mask;
+        masks.add(mask);
+        if (!maskIsNeeded) {
+            masks = null;","Not sure why you're encoding no masks with `null` when an empty list would work just fine. Might also be a good idea to annotate the return type of the method with `@NotNull`
",Why is this needed?
885,"@@ -49,7 +49,18 @@ public inline fun File.printWriter(charset: Charset = Charsets.UTF_8): PrintWrit
  *
  * @return the entire content of this file as a byte array.
  */
-public fun File.readBytes(): ByteArray = FileInputStream(this).use { it.readBytes(length().toInt()) }
+public fun File.readBytes(): ByteArray = FileInputStream(this).use { input ->",Changed exception type to OutOfMemoryError,I think this should be `input -> it.readBytes(length())`
886,"@@ -5,20 +5,141 @@ import java.nio.charset.*
 import java.util.*
 
 /**
- * Recursively process this file and all children with the given block
+ * Recursively process this file and all children with the given block.
+ * Note that if this file doesn't exist, then the block will be executed on it anyway.
  */
 public fun File.recurse(block: (File) -> Unit): Unit {
     block(this)
-    val children = listFiles()
-    if (children != null) {
-        for (child in children) {
-            child.recurse(block)
+    listFiles()?.forEach { it.recurse(block) }
+}
+
+/**
+ * Stream allowing you to get all files that have the specified file as an ancestor in the depth-first order,
+ * including this file itself.
+ *
+ * If you specify a nonexistent file as a constructor parameter, IllegalArgumentException will be thrown.
+ */
+public class TraverseStream(private val file: File) : Stream<File> {
+    {
+        if (!file.exists()) {
+            throw IllegalArgumentException(""This file doesn't exist: $file"")
+        }
+    }
+
+    override fun iterator(): Iterator<File> = object : Iterator<File> {
+        inner class Cursor(val files: Array<File>, var pos: Int) {
+            val curFile: File
+                get() = files[pos]
+        }
+
+        val cursors = arrayListOf(Cursor(array(file), 0))
+        var childrenVisited = false
+
+        fun prepareCursor() {
+            if (cursors.isEmpty()) {
+                return
+            }
+            var cursor = cursors.last!!","Do not use first/last properties, they will be removed. Use first()/last() methods.
",I don't think this is needed.
887,"@@ -5,6 +5,12 @@
     <!-- Set to false to disable proguard run on kotlin-compiler.jar. Speeds up the build -->
     <property name=""shrink"" value=""true""/>
 
+    <!-- Set to false to disable compiler's javadoc generation. Speeds up the build -->
+    <property name=""generate.javadoc"" value=""false""/>
+
+    <!-- Set to false to prevent jarjar and metadata stripping on kotlin-reflect.jar and reflection sources. Use to debug reflection -->
+    <property name=""obfuscate.reflect"" value=""true""/>
+",I think this should be dropped,I don't think we need a separate property for this.
888,"@@ -5,6 +5,12 @@ import org.junit.Test as test
 
 class StringBuilderTest {
 
+    @test fun stringBuildWithInitialCapacity() {
+        val s = buildString(123) {
+            assertEquals(123, capacity())","This test won't compile in JS because there is no `StringBuilder.capacity` there.
To make this test JVM-only, move it to `StringBuilderJVMTest.kt`
",
889,"@@ -5,8 +5,8 @@ import java.util.concurrent.locks.ReentrantReadWriteLock
 import java.util.concurrent.CountDownLatch
 
 /**
- * Executes given calculation under lock
- * Returns result of the calculation
+ * Executes the given calculation under this lock.","calculation -> action
","I think this should be ""Returns the result"""
890,"@@ -50,6 +52,8 @@ public String render(@NotNull ConflictingJvmDeclarationsData data) {
         MAP.put(ErrorsJvm.OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS, ""''jvmOverloads'' annotation has no effect for methods without default arguments"");
         MAP.put(ErrorsJvm.OVERLOADS_ABSTRACT, ""''jvmOverloads'' annotation cannot be used on abstract methods"");
         MAP.put(ErrorsJvm.OVERLOADS_PRIVATE, ""''jvmOverloads'' annotation has no effect on private and local declarations"");
+        MAP.put(ErrorsJvm.INAPPLICABLE_JVM_NAME, ""''jvmName ''annotation is not applicable to this declaration"");","Mistyped whitespace
","MAP.put(ErrorsJvm.INAPPLICABLE_JVM_NAME, ""''jvmName ''ann"
891,"@@ -51,7 +51,7 @@
   <component name=""ProjectResources"">
     <default-html-doctype>http://www.w3.org/1999/xhtml</default-html-doctype>
   </component>
-  <component name=""ProjectRootManager"" version=""2"" languageLevel=""JDK_1_6"" assert-keyword=""true"" jdk-15=""true"" project-jdk-name=""1.6"" project-jdk-type=""JavaSDK"">
+  <component name=""ProjectRootManager"" version=""2"" languageLevel=""JDK_1_6"" assert-keyword=""true"" jdk-15=""true"" project-jdk-name=""1.7"" project-jdk-type=""JavaSDK"">","This change is harmful, as well.
","<component name=""ProjectRootManager"">"
892,"@@ -513,6 +513,16 @@ public static boolean areParenthesesNecessary(
             return false;
         }
 
+        if (innerExpression instanceof KtBinaryExpression) {
+            PsiElement expr = innerExpression.getFirstChild();
+            while (expr != null) {
+                if (expr instanceof PsiWhiteSpace && (expr.textContains('\n') || expr.textContains('\r'))) {","IntelliJ always normalizes text of files to use \n line breaks, the \r will never be there. Please remove it from the check.",Shouldn't this be `innerExpression.getFirstChild()`?
893,"@@ -52,16 +52,16 @@ object MoveDeclarationsOutHelper {
             val scope = LocalSearchScope(container)
             val lastStatementOffset = statements[statements.size - 1].textRange.endOffset
 
-            for (statement in statements) {
+            statements.forEachIndexed { i, statement ->
                 if (needToDeclareOut(statement, lastStatementOffset, scope)) {
                     if (statement is KtProperty && statement.initializer != null) {
-                        var declaration = createVariableDeclaration(statement, generateDefaultInitializers)
+                        val isLastStatement = i == statements.size - 1
+                        var declaration = createVariableAssignment(statement, generateDefaultInitializers, isLastStatement)","I don't think this code is structured well enough. You have three functions that do three sets of entirely different things based on a value of a boolean parameter. I think it's clearer to pull the check out to the top level and to avoid introducing the functions altogether.
",`i == statements.size - 1` is redundant.
894,"@@ -52,37 +55,65 @@ public fun <K, V> linkedMapOf(vararg values: Pair<K, V>): LinkedHashMap<K, V> {
     return answer
 }
 
-/** Returns the [[Map]] if its not null otherwise it returns the empty [[Map]] */
+/**
+ * Returns the [Map] if its not null, or the empty [Map] otherwise.
+ */
 public fun <K,V> Map<K,V>?.orEmpty() : Map<K,V>
        = if (this != null) this else emptyMap()
 
+/**
+ * Checks if the map contains the given key. This method allows to use the `x in map` syntax for checking
+ * whether an object is contained in the map.
+ */
 public fun <K,V> Map<K,V>.contains(key : K) : Boolean = containsKey(key)
 
-/** Returns the key of the entry */
+/**
+ * Allows to access the key of a map entry as a property. Equivalent to `getKey()`.
+ */
 public val <K, V> Map.Entry<K, V>.key: K
     get() = getKey()
 
-/** Returns the value of the entry */
+/**
+ * Allows to access the value of a map entry as a property. Equivalent to `getValue()`.
+ */
 public val <K, V> Map.Entry<K, V>.value: V
     get() = getValue()
 
-/** Returns the key of the entry */
+/**
+ * Returns the key of the map entry. This method allows to use multi-declarations when working with maps,","""Returns the key component of the map entry""
",This method allows to use multi-declarations when working
895,"@@ -52,37 +55,65 @@ public fun <K, V> linkedMapOf(vararg values: Pair<K, V>): LinkedHashMap<K, V> {
     return answer
 }
 
-/** Returns the [[Map]] if its not null otherwise it returns the empty [[Map]] */
+/**
+ * Returns the [Map] if its not null, or the empty [Map] otherwise.
+ */
 public fun <K,V> Map<K,V>?.orEmpty() : Map<K,V>
        = if (this != null) this else emptyMap()
 
+/**
+ * Checks if the map contains the given key. This method allows to use the `x in map` syntax for checking
+ * whether an object is contained in the map.
+ */
 public fun <K,V> Map<K,V>.contains(key : K) : Boolean = containsKey(key)
 
-/** Returns the key of the entry */
+/**
+ * Allows to access the key of a map entry as a property. Equivalent to `getKey()`.
+ */
 public val <K, V> Map.Entry<K, V>.key: K
     get() = getKey()
 
-/** Returns the value of the entry */
+/**
+ * Allows to access the value of a map entry as a property. Equivalent to `getValue()`.
+ */
 public val <K, V> Map.Entry<K, V>.value: V
     get() = getValue()
 
-/** Returns the key of the entry */
+/**
+ * Returns the key of the map entry. This method allows to use multi-declarations when working with maps,
+ * for example:
+ * ```
+ * for ((key, value) in map) {
+ *     // do something with the key and the value
+ * }
+ * ```
+ */
 public fun <K, V> Map.Entry<K, V>.component1(): K {
     return getKey()
 }
 
-/** Returns the value of the entry */
+/**
+ * Returns the value of the map entry. This method allows to use multi-declarations when working with maps,","""Returns the value component of the map entry""
",I don't think this is correct. It should be `get(key : K)
896,"@@ -52,37 +55,65 @@ public fun <K, V> linkedMapOf(vararg values: Pair<K, V>): LinkedHashMap<K, V> {
     return answer
 }
 
-/** Returns the [[Map]] if its not null otherwise it returns the empty [[Map]] */
+/**
+ * Returns the [Map] if its not null, or the empty [Map] otherwise.
+ */
 public fun <K,V> Map<K,V>?.orEmpty() : Map<K,V>
        = if (this != null) this else emptyMap()
 
+/**
+ * Checks if the map contains the given key. This method allows to use the `x in map` syntax for checking
+ * whether an object is contained in the map.
+ */
 public fun <K,V> Map<K,V>.contains(key : K) : Boolean = containsKey(key)
 
-/** Returns the key of the entry */
+/**
+ * Allows to access the key of a map entry as a property. Equivalent to `getKey()`.
+ */
 public val <K, V> Map.Entry<K, V>.key: K
     get() = getKey()
 
-/** Returns the value of the entry */
+/**
+ * Allows to access the value of a map entry as a property. Equivalent to `getValue()`.
+ */
 public val <K, V> Map.Entry<K, V>.value: V
     get() = getValue()
 
-/** Returns the key of the entry */
+/**
+ * Returns the key of the map entry. This method allows to use multi-declarations when working with maps,
+ * for example:
+ * ```
+ * for ((key, value) in map) {
+ *     // do something with the key and the value
+ * }
+ * ```
+ */
 public fun <K, V> Map.Entry<K, V>.component1(): K {
     return getKey()
 }
 
-/** Returns the value of the entry */
+/**
+ * Returns the value of the map entry. This method allows to use multi-declarations when working with maps,
+ * for example:
+ * ```
+ * for ((key, value) in map) {
+ *     // do something with the key and the value
+ * }
+ * ```
+ */
 public fun <K, V> Map.Entry<K, V>.component2(): V {
     return getValue()
 }
 
-/** Converts entry to Pair with key being first component and value being second */
+/**
+ * Converts entry to [Pair] with key being first component and value being second","This doc uses first/second _component_, while doc for mapOf/hashMapOf/ uses first/second _value_. Should use the same word.
",I don't think this is correct. It should be `Gets the key of the map entry.`
897,"@@ -527,10 +527,15 @@ static void generateConstructorWithoutParametersIfNeeded(
         for (ValueParameterDescriptor parameterDescriptor : constructorDescriptor.getValueParameters()) {
             Type paramType = state.getTypeMapper().mapType(parameterDescriptor.getType());
             pushDefaultValueOnStack(paramType, v);
-            mask |= (1 << parameterDescriptor.getIndex());
+            int i = parameterDescriptor.getIndex();
+            if (i != 0 && i % Integer.SIZE == 0) {
+                v.iconst(mask);
+                mask = 0;
+            }
+            mask |= (1 << (parameterDescriptor.getIndex() % Integer.SIZE));","Use `i` here, introduced a few lines earlier
",I don't think this is correct. It should be `i % Integer.SIZE`.
898,"@@ -527,10 +527,15 @@ static void generateConstructorWithoutParametersIfNeeded(
         for (ValueParameterDescriptor parameterDescriptor : constructorDescriptor.getValueParameters()) {
             Type paramType = state.getTypeMapper().mapType(parameterDescriptor.getType());
             pushDefaultValueOnStack(paramType, v);
-            mask |= (1 << parameterDescriptor.getIndex());
+            int i = parameterDescriptor.getIndex();
+            if (i != 0 && i % Integer.SIZE == 0) {
+                v.iconst(mask);
+                mask = 0;
+            }
+            mask |= (1 << (parameterDescriptor.getIndex() % Integer.SIZE));
         }
         v.iconst(mask);","Should this `iconst` still be done if there's exactly `32*n` parameters?
",Why is this needed?
899,"@@ -53,14 +54,20 @@ class MovePropertyToConstructorIntention :
         applyTo(property, null)
     }
 
-    override fun isApplicableTo(element: KtProperty, caretOffset: Int): Boolean =
-            !element.isLocal
-            && !element.hasDelegate()
-            && element.getter == null
-            && element.setter == null
-            && !element.hasModifier(LATEINIT_KEYWORD)
-            && element.getStrictParentOfType<KtClassOrObject>() is KtClass
-            && (element.initializer?.isValidInConstructor() ?: true)
+    override fun isApplicableTo(element: KtProperty, caretOffset: Int): Boolean {
+        fun KtProperty.isDeclaredInClass() : Boolean {
+            val parent = element.getStrictParentOfType<KtClassOrObject>()
+            return parent != null && !parent.isInterfaceClass()",Here it's also necessary to check that the `KtClassOrObject` is not an object declaration. I'll add this check.,I think this should be `KtClassOrObject.isInterfaceClass()`
900,"@@ -53,15 +82,15 @@ public fun thread(start: Boolean = true, daemon: Boolean = false, contextClassLo
 
 /**
  * Allows you to use the executor as a function to","""Allows you"" - not good for docs.
",*
901,"@@ -53,15 +82,15 @@ public fun thread(start: Boolean = true, daemon: Boolean = false, contextClassLo
 
 /**
  * Allows you to use the executor as a function to
- * execute the given block on the [[Executor]].
+ * execute the given block on the [Executor].
  */
 public fun Executor.invoke(action: () -> Unit) {
     execute(action)
 }
 
 /**
- * Allows you to use the executor as a function to
- * execute the given block on the [[Executor]].
+ * Allows you to use the executor service as a function to","Allows you.
",I don't think we should change this.
902,"@@ -538,6 +538,13 @@ class DefaultExpressionConverter : JavaElementVisitor(), ExpressionConverter {
         val qualifier = expression.qualifierExpression
 
         var identifier = Identifier.withNoPrototype(referenceName, isNullable)
+
+
+        if (expression.getContainingClass()?.getParentOfType<PsiField>(false).let { it != null && it == expression.qualifierExpression?.reference?.resolve() }) {","Why are you checking for `PsiField` specifically? Won't the same problem happen if the anonymous class is used as a local variable initializer?
",I'm not sure if this is the best way to do this. I think it would be better 
903,"@@ -538,6 +538,16 @@
                 <attribute name=""Main-Class"" value=""org.jetbrains.kotlin.cli.jvm.K2JVMCompiler""/>
             </manifest>
         </jar>
+
+        <delete file=""${output}/kotlin-compiler-embeddable.jar"" failonerror=""false""/>
+        <taskdef name=""jarjar"" classname=""com.tonicsystems.jarjar.JarJarTask"" classpath=""dependencies/jarjar.jar""/>
+        <jarjar jarfile=""${output}/kotlin-compiler-embeddable.jar"" filesonly=""true"" filesetmanifest=""merge"">
+            <zipfileset src=""${kotlin-home}/lib/kotlin-compiler.jar"" includes=""**""/>
+            <zipfileset src=""${bootstrap.runtime}"" includes=""**"" excludes=""META-INF/**""/>
+            <zipfileset src=""${bootstrap.reflect}"" includes=""**"" excludes=""META-INF/**""/>
+            <rule pattern=""com.google.**"" result=""kotlin.compiler.jvm.internal.impl.com.google.protobuf.@1""/>
+            <rule pattern=""javax.inject.**"" result=""kotlin.compiler.jvm.internal.impl.javax.inject.@1""/>","Please do not put it under package `kotlin` as this is what's used by our stdlib, reflection and other public API. I propose `org.jetbrains.kotlin.com.google.protobuf` and `org.jetbrains.kotlin.javax.inject`
",I think it would be better to move this file to `kotlin-compiler-embeddable.
904,"@@ -54,13 +62,14 @@ public static void runK2JvmCompiler(
             CompilerSettings compilerSettings,
             MessageCollector messageCollector,
             CompilerEnvironment environment,
-            File moduleFile,
+            Map<String, IncrementalCache> incrementalCaches, File moduleFile,","It seems it is better to have one parameter per line.
",Why do we need a map here?
905,"@@ -54,6 +54,8 @@ enum class LanguageFeature(
     InlineDefaultFunctionalParameters(KOTLIN_1_2),
     SoundSmartCastsAfterTry(KOTLIN_1_2),
     DeprecatedFieldForInvisibleCompanionObject(KOTLIN_1_2),
+    ContractEffects(KOTLIN_1_1),
+    CalledInPlaceEffect(KOTLIN_1_1),","Also, I suspect we require also the third feature, something like ""value analysis in conditions"". I have in mind checks like `if (1 == 2)`.",I don't think this should be here.
906,"@@ -548,7 +548,7 @@ public fun String.elementAt(index: Int): Char {
 }
 
 /**
- * Returns first element
+ * Returns first element. Throws [NoSuchElementException] if the collection is empty.","Should it be `@throws` tag instead?
",Nit: `Returns the first element.`
907,"@@ -55,6 +55,15 @@ import com.intellij.psi.PsiPackage
 import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiMember
 import org.jetbrains.jet.lang.psi.JetNamedDeclaration
+import org.jetbrains.jet.lang.psi.JetExpressionImpl
+import org.jetbrains.jet.lang.psi.JetContainerNode
+import org.jetbrains.jet.lang.psi.JetWhileExpression
+import org.jetbrains.jet.lang.psi.JetDoWhileExpression
+import org.jetbrains.jet.lang.psi.JetForExpression
+import org.jetbrains.jet.lang.psi.JetIfExpression
+import org.jetbrains.jet.JetNodeTypes
+import com.intellij.lang.ASTNode","Some imports are unused here :)
",I don't think we need these imports.
908,"@@ -55,6 +58,8 @@ public enum class InlineStrategy {
  * receiving function are allowed to use non-local control flow statements. Lambdas which are called from
  * a different execution context (for example, from an object contained in the receiving function)
  * are restricted to local control flow statements.
+ *
+ * @property value the inlining options selected for this lambda.","""this lambda"" is unclear, may be ""options for annotated functional parameter""?
",This should be `@property`.
909,"@@ -55,8 +55,8 @@ protected void postProcess(PsiFile createdElement, String templateName, Map<Stri
     @Override
     protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {
         builder
-                .setTitle(JetBundle.message(""new.kotlin.file.action""))
-                .addKind(""Kotlin file"", JetFileType.INSTANCE.getIcon(), ""Kotlin File"")
+                .setTitle(""New Kotlin File/Class"")","Other stuff under the `New...` menu doesn't start with ""New"", this probably shouldn't start as well
","I think this should be ""New Kotlin File/Class"""
910,"@@ -551,8 +552,22 @@ internal open class KotlinAndroidPlugin(
 }
 
 private fun configureJavaTask(kotlinTask: KotlinCompile, javaTask: AbstractCompile, logger: Logger) {
+    // Gradle Java IC in older Gradle versions (before 2.14) cannot check .class directories updates.
+    // To make it work, reset the up-to-date status of compileJava with this flag.
+    kotlinTask.anyClassesCompiled = false
+    javaTask.outputs.upToDateWhen { task ->
+        val gradleSupportsJavaIcWithClassesDirs = ParsedGradleVersion.parse(javaTask.project.gradle.gradleVersion)",I think that version checking should be performed before `upToDateWhen` callback is added,nit: `gradleSupportsJavaIcWithClassesDirs` -> `gradleSupportsJavaIcWithClass
911,"@@ -551,8 +552,22 @@ internal open class KotlinAndroidPlugin(
 }
 
 private fun configureJavaTask(kotlinTask: KotlinCompile, javaTask: AbstractCompile, logger: Logger) {
+    // Gradle Java IC in older Gradle versions (before 2.14) cannot check .class directories updates.
+    // To make it work, reset the up-to-date status of compileJava with this flag.
+    kotlinTask.anyClassesCompiled = false
+    javaTask.outputs.upToDateWhen { task ->
+        val gradleSupportsJavaIcWithClassesDirs = ParsedGradleVersion.parse(javaTask.project.gradle.gradleVersion)
+                                                          ?.let { it >= ParsedGradleVersion(2, 14) } ?: false
+        val kotlinClassesCompiled = kotlinTask.anyClassesCompiled
+        if (!gradleSupportsJavaIcWithClassesDirs && kotlinClassesCompiled) {
+            logger.info(""Marking $task out of date, because kotlin classes are changed"")
+            return@upToDateWhen false
+        }
+        true
+    }
+
     // Make Gradle check if the javaTask up-to-date based on the Kotlin classes
-    javaTask.inputs.dir(kotlinTask.destinationDir!!)
+    javaTask.inputs.dir(kotlinTask.destinationDir)","I think you should also include kapt1 annotations file:
https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/main/kotlin/org/jetbrains/kotlin/gradle/internal/AnnotationProcessingManager.kt#L139

In kapt1 AP is performed by java task, so if this file is not included, AP may be skipped when only source annotations are modified.
Kapt3 should probably work as intended.
I think the test should be added for this case (Java IC + Kapt 1/3 + change only Kotlin source annotations).",I'm not sure if this is the right way to do this. I think it should be `grad
912,"@@ -56,11 +60,37 @@ fun generateIsCheck(
         }
     }
     else {
-        generateInstanceOfInstruction(v)
+        TypeIntrinsics.instanceOf(v, kotlinType, asmType)
+    }
+}
+
+fun generateAsCheck(","`is` is a ""check"", but `as` is not :) `generateCast`?
",`fun` is not used.
913,"@@ -56,6 +57,13 @@ open class AddModifierFix(
 
     override fun invoke(project: Project, editor: Editor?, file: KtFile) {
         element?.addModifier(modifier)
+
+        if (modifier == KtTokens.ABSTRACT_KEYWORD && (element is KtProperty || element is KtNamedFunction)) {
+            element?.containingClass()?.run {
+                if (!hasModifier(KtTokens.ABSTRACT_KEYWORD) && !hasModifier(KtTokens.SEALED_KEYWORD)) addModifier(KtTokens.ABSTRACT_KEYWORD)
+                if (hasModifier(KtTokens.OPEN_KEYWORD)) removeModifier(KtTokens.OPEN_KEYWORD)","Should work without this line, at least in theory. Will check it myself.",I don't think this
914,"@@ -57,11 +58,10 @@ class KotlinMavenArchetypesProvider : MavenArchetypesProvider {
             .asJsonArray
             .map { it.asJsonObject }
             .map { MavenArchetype(it.get(""g"").asString, it.get(""a"").asString, it.get(""v"").asString, null, null) }
-            .filter { it.version.matches(versionRegexp) }
-            .groupBy { it.artifactId + ""-"" + it.version.substringBeforeLast('.') }
-            .mapValues { it.value.maxBy { a -> a.version.substringAfterLast('.').toInt() }!! }
-            .values
-            .toList()
+            .filter { it.version?.startsWith(versionPrefix) ?: false }
+            .maxBy { MavenVersionComparable(it.version) }
+            ?.let { listOf(it) }","It might be cleaner to use `listOfNotNull` instead of `?.let { listOf } ?: emptyList()`
",Shouldn't this be 
915,"@@ -57,6 +58,16 @@ class RedundantSemicolonInspection : AbstractKotlinInspection(), CleanupLocalIns
 
         if (semicolon.parent is KtEnumEntry) return false
 
+        (semicolon.parent.parent as? KtClass)?.let {
+            if (it.isEnum() && it.getChildrenOfType<KtEnumEntry>().isEmpty()) {
+                if (semicolon.prevLeaf { it !is PsiWhiteSpace && it !is PsiComment && !it.isLineBreak() }?.node?.elementType == KtTokens.LBRACE &&
+                    semicolon.nextLeaf { it !is PsiWhiteSpace && it !is PsiComment && !it.isLineBreak() }?.node?.elementType != KtTokens.RBRACE) {","I thinks it's more precise just to check here that `getDeclarations()` isn't empty, instead of doing these operations with `nextLeaf`.",I'm not sure if th
916,"@@ -58,12 +68,22 @@ public fun CharSequence.iterator(): CharIterator = object : CharIterator() {
     public override fun hasNext(): Boolean = index < length
 }
 
-/** Returns the string if it is not null or the empty string if its null */
+/** Returns the string if it is not null, or the empty string otherwise. */
 public fun String?.orEmpty(): String = this ?: """"
 
+/**
+ * Returns the range of valid character indices for this string.
+ */
 public val String.indices: IntRange
     get() = 0..length() - 1
 
+/**
+ * Returns a character at the given index in a [CharSequence]. Allows to use the
+ * brackets notation for working with character sequences:","""brackets notation"" -> ""index operator""
",I don't think this
917,"@@ -59,17 +90,49 @@ class ReplaceSingleLineLetIntention : SelfTargetingOffsetIndependentIntention<Kt
     override fun isApplicableTo(element: KtCallExpression): Boolean {
         if (!isLetMethod(element)) return false
         val lambdaExpression = element.lambdaArguments.firstOrNull()?.getLambdaExpression() ?: return false
-        val bodyExpression = lambdaExpression.bodyExpression?.children?.singleOrNull() ?: return false
-        val dotQualifiedExpression = bodyExpression as? KtDotQualifiedExpression ?: return false
         val parameterName = lambdaExpression.getParameterName() ?: return false
-        val receiverExpression = dotQualifiedExpression.getLeftMostReceiverExpression()
-        if (receiverExpression.text != parameterName) return false
-        dotQualifiedExpression.selectorExpression?.let {
-            if (it.anyDescendantOfType<KtLambdaExpression>()) return false
+        val bodyExpression = lambdaExpression.bodyExpression?.children?.singleOrNull() ?: return false
+
+        return when (bodyExpression) {
+            is KtBinaryExpression -> bodyExpression.isApplication(parameterName)
+            is KtDotQualifiedExpression -> bodyExpression.isApplicable(parameterName)","Why is the first `isApplication`, but the second `isApplicable`?
",I think this shoul
918,"@@ -59,17 +90,49 @@ class ReplaceSingleLineLetIntention : SelfTargetingOffsetIndependentIntention<Kt
     override fun isApplicableTo(element: KtCallExpression): Boolean {
         if (!isLetMethod(element)) return false
         val lambdaExpression = element.lambdaArguments.firstOrNull()?.getLambdaExpression() ?: return false
-        val bodyExpression = lambdaExpression.bodyExpression?.children?.singleOrNull() ?: return false
-        val dotQualifiedExpression = bodyExpression as? KtDotQualifiedExpression ?: return false
         val parameterName = lambdaExpression.getParameterName() ?: return false
-        val receiverExpression = dotQualifiedExpression.getLeftMostReceiverExpression()
-        if (receiverExpression.text != parameterName) return false
-        dotQualifiedExpression.selectorExpression?.let {
-            if (it.anyDescendantOfType<KtLambdaExpression>()) return false
+        val bodyExpression = lambdaExpression.bodyExpression?.children?.singleOrNull() ?: return false
+
+        return when (bodyExpression) {
+            is KtBinaryExpression -> bodyExpression.isApplication(parameterName)
+            is KtDotQualifiedExpression -> bodyExpression.isApplicable(parameterName)
+            else -> false
         }
-        return !dotQualifiedExpression.receiverUsedAsArgument(parameterName)
     }
 
+    private fun KtBinaryExpression.isApplication(parameterName: String): Boolean {
+        val left = left ?: return false
+
+        if (when (left) {
+            is KtNameReferenceExpression -> left.text != parameterName
+            is KtDotQualifiedExpression -> !left.isApplicable(parameterName)
+            else -> return false
+        }) return false","This construction is hard to read. I'd rewrite it like

```
when (...) {
    is ... -> if (...) return false
}
```
",Why not just `isAp
919,"@@ -596,6 +596,12 @@ public void testSpaceBeforeFunctionLiteral() throws Exception {
             doTest(fileName);
         }
 
+        @TestMetadata(""SpaceBeforeIndices.after.kt"")
+        public void testSpaceBeforeIndices() throws Exception {
+            String fileName = KotlinTestUtils.navigationMetadata(""idea/testData/formatter/SpaceBeforeIndices.after.kt"");
+            doTest(fileName);
+        }
+
         @TestMetadata(""SpacedInsideParans.after.kt"")",Lenor ,I think we can rem
920,"@@ -6,7 +6,10 @@ public fun String.trim(text: String): String = trimLeading(text).trimTrailing(te
 /** Returns the string with the prefix and postfix text trimmed */
 public fun String.trim(prefix: String, postfix: String): String = trimLeading(prefix).trimTrailing(postfix)
 
-/** Returns the string with the leading prefix of this string removed */
+/**
+ * If this string starts with the given [prefix], returns a copy of this string","Documentation is backwards. Normally it reads ""Returns a  if , otherwise ""
",I'm not sure if th
921,"@@ -60,6 +60,8 @@ public inline fun String.format(format : String, vararg args : Any?) : String =
 
 public inline fun String.split(regex : String) : Array<String> = (this as java.lang.String).split(regex) as Array<String>
 
+public inline fun String.split(ch : Char) : Array<String> = (this as java.lang.String).split(java.util.regex.Pattern.quote(ch.toString())) as Array<String>","Why here you are casting ""this"" to String? 
",public inline fun 
922,"@@ -61,6 +64,8 @@ protected void applyEditorTo(JetRunConfiguration configuration) throws Configura
         myModuleSelector.applyTo(configuration);
         myCommonProgramParameters.applyTo(configuration);
         configuration.setRunClass(myMainClassField.getText());
+        configuration.setAlternativeJrePath(alternativeJREPanel.getPath());
+        configuration.setAlternativeJrePathEnabled(alternativeJREPanel.isPathEnabled());","Has it real effect during run? Is it enough to just set it to a configuration?
",Why is this needed
923,"@@ -61,6 +66,13 @@ class KotlinIndicesHelper(
 
     private val moduleDescriptor = resolutionFacade.moduleDescriptor
     private val project = resolutionFacade.project
+    private val scopeWithoutKotlin = ScopeWithoutKotlin(scope)","You can use `SearchUtil.excludeKotlinSources`
",private final Scop
924,"@@ -614,10 +614,22 @@ public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull O
     }
 
     @NotNull
+    public static String getDefaultDescriptor(@NotNull String descriptor) {","Take a look on the usages, this method should take a `Method` as a parameter rather than a `String`
",private final Stri
925,"@@ -614,10 +614,22 @@ public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull O
     }
 
     @NotNull
+    public static String getDefaultDescriptor(@NotNull String descriptor) {
+        // read Type.getArgumentsAndReturnSizes documentation for explanations","This comment is useless :) If I don't understand `>> 2`, I'll go and read what the method returns by myself, and if I do, I need not this comment at all
",
926,"@@ -614,10 +614,22 @@ public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull O
     }
 
     @NotNull
+    public static String getDefaultDescriptor(@NotNull String descriptor) {
+        // read Type.getArgumentsAndReturnSizes documentation for explanations
+        int argumentsSize = (Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1;
+        int maskArgumentsCont = argumentsSize / Integer.SIZE + (argumentsSize % Integer.SIZE == 0 ? 0 : 1);","Typo? _count_, not cont
",Why do we need thi
927,"@@ -614,10 +614,22 @@ public JvmMethodSignature mapSignature(@NotNull FunctionDescriptor f, @NotNull O
     }
 
     @NotNull
+    public static String getDefaultDescriptor(@NotNull String descriptor) {
+        // read Type.getArgumentsAndReturnSizes documentation for explanations
+        int argumentsSize = (Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1;
+        int maskArgumentsCont = argumentsSize / Integer.SIZE + (argumentsSize % Integer.SIZE == 0 ? 0 : 1);
+        String maskArguments = ""I"";
+        for (int i = 1; i < maskArgumentsCont; i++) {
+            maskArguments += 'I';
+        }","`StringUtil.repeat(INT_TYPE.getDescriptor(), maskArgumentsCount)`
",Why do we need thi
928,"@@ -63,12 +66,36 @@ private KotlinRuntimeLibraryUtil() {}
 
     @NotNull
     public static Collection<VirtualFile> getLibraryRootsWithAbiIncompatibleKotlinClasses(@NotNull Project project) {
-        return getLibraryRootsWithAbiIncompatibleVersion(project, KotlinAbiVersionIndex.INSTANCE$);
+        return getLibraryRootsWithAbiIncompatibleVersion(project, KotlinAbiVersionIndex.INSTANCE$,
+                            new Predicate<Module>() {
+                             @Override
+                             public boolean apply(@Nullable Module module) {
+                                 return module != null && ProjectStructureUtil.isJavaKotlinModule(module);
+                             }
+                            },
+                            new Predicate<Integer>() {
+                             @Override
+                             public boolean apply(Integer abiVersion) {
+                                 return !AbiVersionUtil.isAbiVersionCompatible(abiVersion);
+                             }
+                            });","Something wrong with formatting in this file I suppose?
",nit: `AbiVersionUtil.isAbiVersionCompatible(abiVersion)` -> `AbiVersionUtil.isAbiVersionCompatible(abiVersion)`
929,"@@ -63,3 +63,16 @@ public inline fun String.count(predicate: (Char) -> Boolean): Int {
     }
     return answer
 }
+
+/**
+ * Repeats a given string n times. With n <= 0, the empty string is returned.","I think it's better to throw IllegalArgumentException if n < 0, because it doesn't make much sense to hide user's error and return empty string in this case.
",
930,"@@ -63,3 +63,16 @@ public inline fun String.count(predicate: (Char) -> Boolean): Int {
     }
     return answer
 }
+
+/**
+ * Repeats a given string n times. With n <= 0, the empty string is returned.
+ * @includeFunctionBody ../../test/StringTest.kt times
+ */
+public inline fun String.times(var n: Int) : String {
+    var answer = """";","semicolons are noise which is unnecessary in Kotlin :)
",nit: typo in `kt`
931,"@@ -63,3 +63,16 @@ public inline fun String.count(predicate: (Char) -> Boolean): Int {
     }
     return answer
 }
+
+/**
+ * Repeats a given string n times. With n <= 0, the empty string is returned.
+ * @includeFunctionBody ../../test/StringTest.kt times
+ */
+public inline fun String.times(var n: Int) : String {
+    var answer = """";
+    while (n > 0) {
+        answer = answer.concat(this)","I think that it'll be good to use StringBuilder#append instead of strings concatenations.
",nit: typo in `kt`
932,"@@ -63,6 +63,13 @@ val PsiElement.parentsWithSelf: Sequence<PsiElement>
 val PsiElement.parents: Sequence<PsiElement>
     get() = parentsWithSelf.drop(1)
 
+fun PsiElement.matchParents(vararg parentClasses: Class<out PsiElement>): Boolean {
+    return this.parents.zip(sequenceOf(*parentClasses)).all {
+        val (elem, clazz) = it
+        clazz.isAssignableFrom(elem.javaClass)","With lambda argument destructuring and `isInstance` method you could write this method as

```
    return this.parents.zip(sequenceOf(*parentClasses)).all { (elem, clazz) ->
        clazz.isInstance(elem)
    }
```",I think this should be `PsiElement.isAssignableFrom(elem.javaClass)`
933,"@@ -63,6 +63,7 @@
       <module fileurl=""file://$PROJECT_DIR$/compiler/ir/ir.tree/ir.tree.iml"" filepath=""$PROJECT_DIR$/compiler/ir/ir.tree/ir.tree.iml"" group=""compiler/ir"" />
       <module fileurl=""file://$PROJECT_DIR$/j2k/j2k.iml"" filepath=""$PROJECT_DIR$/j2k/j2k.iml"" group=""j2k"" />
       <module fileurl=""file://$PROJECT_DIR$/plugins/java-model-wrappers/java-model-wrappers.iml"" filepath=""$PROJECT_DIR$/plugins/java-model-wrappers/java-model-wrappers.iml"" group=""plugins"" />
+      <module fileurl=""file://$PROJECT_DIR$/compiler/javac/javac.iml"" filepath=""$PROJECT_DIR$/compiler/javac/javac.iml"" group=""compiler"" />",I'm not sure `javac` is the best possible name here. May be something like `javac-wrapper`?,"<module fileurl=""file://$PROJECT_DIR$/compiler/javac/javac.iml"" filepath=""$PROJECT_DIR$/compiler/javac/javac.im"
934,"@@ -63,6 +65,10 @@ public abstract class KotlinLightCodeInsightFixtureTestCase : LightCodeInsightFi
                 super.processError(message, t, details, logger)
             }
         })
+
+        // set to false if not present or set to true or unknown (empty considered true)
+        if (System.getProperty(KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY)?.let { it.toBooleanLenient() ?: true } ?: true )","This could be written as

```
if (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = false)) {
```
",I'm not sure if this is the best way to do this. I think it would be better to use `process.env.KOTLIN_COMPILER
935,"@@ -64,4 +66,92 @@ internal annotation class InlineOnly
  */
 @Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
 @Retention(AnnotationRetention.BINARY)
-internal annotation class DynamicExtension
\ No newline at end of file
+internal annotation class DynamicExtension
+
+/**
+ * Specifies effect: annotated function returns specific value when condition provided
+ * by other annotations is true.*
+ */
+@Target(AnnotationTarget.FUNCTION)
+@Retention(AnnotationRetention.BINARY)
+internal annotation class Returns(val value: ConstantValue = ConstantValue.UNKNOWN)
+
+/**
+ * Specifies effect: annotated function throws 'exception' when condition is true
+ */
+@Target(AnnotationTarget.FUNCTION)
+@Retention(AnnotationRetention.BINARY)
+internal annotation class Throws",I didn't notice any use of this annotation (may be I missed something),This should be `throws Exception`
936,"@@ -64,6 +64,13 @@
             KotlinBuiltIns.getInstance().getChar()
     );
 
+    private static final Set<String> STRINGBULDER_OBJECT_APPEND_ARG_TYPES = Sets.newHashSet(","I think declaring a `Set<Type>` would be more straightforward. You can use `Type.getType(Class<?>)` to create corresponding `Type` objects
",Why not use `Collections.singleton`?
937,"@@ -650,7 +650,7 @@ class DefaultExpressionConverter : JavaElementVisitor(), ExpressionConverter {
             result = MethodCallExpression.buildNonNull(operandConverted, typeConversion)
         }
         else {
-            val nullability = if (operandConverted.isNullable && !expression.isQualifier())
+            val nullability = if ((operandConverted.isNullable && !expression.isQualifier()) || operandType == PsiType.NULL)","Better not to hack this check, but fix problem with `operandConverted.isNullable == false` for `null` literal  ",val nullability = operandType == PsiType.NULL ? true : false;
938,"@@ -67,7 +73,15 @@ abstract class KtCodeFragment(
 
     override fun isValid() = true
 
-    override fun getContext() = context
+    override fun getContext(): PsiElement? {
+        if (fakeContextForJavaFile != null) return fakeContextForJavaFile
+        if (context !is KtElement) {
+            LOG.warn(""CodeFragment with non-kotlin context should have fakeContextForJavaFile set: \noriginalContext = ${context?.getElementTextWithContext()}"")","We shouldn't create kotlin codeFragments for scala files. See KotlinCodeFragmentFactory.isContextAccepted
",I'm not sure if this is the right place for this warning. I think it should be in the `KotlinContext` class.
939,"@@ -68,10 +70,14 @@ public inline fun String.startsWith(prefix: String) : Boolean = (this as java.la
 
 public inline fun String.startsWith(prefix: String, toffset: Int) : Boolean = (this as java.lang.String).startsWith(prefix, toffset)
 
+public inline fun String.startsWith(ch: Char) : Boolean = (this as java.lang.String).startsWith(ch.toString())","The same
",public inline fun String.startsWith(ch: Char) : Boolean = (this as java.lang.String).startsWith(ch)
940,"@@ -68,3 +64,9 @@ class ClassBody(
         builder.append(companionObjectMembers, ""\n"", ""companion object {\n"", ""\n}"")
     }
 }
+
+private object PropertyComparator : Comparator<Member> {
+    override fun compare(o1: Member?, o2: Member?): Int {
+        return if (o1 is Property) if (o2 is Property) 0 else -1 else if (o2 is Property) 1 else 0",I'd use when for readability ,I'm not sure if this is the best way to do this. I think it would be better to use `Comparer<Member>.Default` i
941,"@@ -69,6 +68,15 @@ class KotlinRedundantOverrideInspection : AbstractKotlinInspection(), CleanupLoc
                 }
             }
 
+    private fun KtNamedFunction.containsOtherModifier(): Boolean {
+        MODIFIER_EXCLUDE_OVERRIDE.forEach {",You can simplify this to `return MODIFIER_EXCLUDE_OVERRIDE.any { hasModifier(it) }`,
942,"@@ -69,7 +72,18 @@ public TextRange getRangeInElement() {
 
     @Override
     public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {
-        PsiElement element = JetPsiFactory.createNameIdentifier(myExpression.getProject(), newElementName);
+        IElementType type = myExpression.getReferencedNameElementType();
+        final PsiElement element;","We do not mark variables final unless this is required by the compiler.
",Why do we need this change?
943,"@@ -69,7 +78,7 @@ public static void runK2JsCompiler(
             @NotNull CompilerSettings compilerSettings,
             @NotNull MessageCollector messageCollector,
             @NotNull CompilerEnvironment environment,
-            @NotNull OutputItemsCollector collector,
+            Map<String, IncrementalCache> incrementalCaches, @NotNull OutputItemsCollector collector,","Same here --- one parameter per line.
",Why do we need a map here?
944,"@@ -7,127 +7,358 @@ import java.util.regex.MatchResult
 import java.util.regex.Pattern
 import java.nio.charset.Charset
 
+/**
+ * Returns the index within this string of the last occurrence of the specified substring.
+ */
 public fun String.lastIndexOf(str: String): Int = (this as java.lang.String).lastIndexOf(str)
 
+/**
+ * Returns the index within this string of the last occurrence of the specified character.
+ */
 public fun String.lastIndexOf(ch: Char): Int = (this as java.lang.String).lastIndexOf(ch.toString())
 
+/**
+ * Compares this string to another string, ignoring case considerations.
+ */
 public fun String.equalsIgnoreCase(anotherString: String): Boolean = (this as java.lang.String).equalsIgnoreCase(anotherString)
 
+/**
+ * Returns the hash code of this string.
+ */
 public fun String.hashCode(): Int = (this as java.lang.String).hashCode()
 
+/**
+ * Returns the index within this string of the first occurrence of the specified substring.
+ */
 public fun String.indexOf(str: String): Int = (this as java.lang.String).indexOf(str)
 
+/**
+ * Returns the index within this string of the first occurrence of the specified substring, starting from the specified offset.
+ */
 public fun String.indexOf(str: String, fromIndex: Int): Int = (this as java.lang.String).indexOf(str, fromIndex)
 
+/**
+ * Returns a copy of this string with all occurrences of [oldChar] replaced with [newChar].
+ */
 public fun String.replace(oldChar: Char, newChar: Char): String = (this as java.lang.String).replace(oldChar, newChar)
 
+/**
+ * Returns a new string obtained by replacing each substring of this string that matches the given regular expression
+ * with the given [replacement].
+ */
 public fun String.replaceAll(regex: String, replacement: String): String = (this as java.lang.String).replaceAll(regex, replacement)
 
+/**
+ * Returns a copy of this string with leading and trailing whitespace trimmed.
+ */
 public fun String.trim(): String = (this as java.lang.String).trim()
 
+/**
+ * Returns a copy of this string converted to upper case using the rules of the default locale.
+ */
 public fun String.toUpperCase(): String = (this as java.lang.String).toUpperCase()
 
+/**
+ * Returns a copy of this string converted to lower case using the rules of the default locale.
+ */
 public fun String.toLowerCase(): String = (this as java.lang.String).toLowerCase()
 
+/**
+ * Returns a new character array containing the characters from this string.
+ */
 public fun String.toCharArray(): CharArray = (this as java.lang.String).toCharArray()
 
+/**
+ * Uses this string as a format string and returns a string obtained by substituting the specified arguments,
+ * using the default locale.
+ */
 public fun String.format(vararg args: Any?): String = java.lang.String.format(this, *args)
 
+/**
+ * Uses this string as a format string and returns a string obtained by substituting the specified arguments, using
+ * the specified locale.
+ */
 public fun String.format(locale: Locale, vararg args : Any?) : String = java.lang.String.format(locale, this, *args)
 
+/**
+ * Splits this string around matches of the given regular expression.
+ */
 public fun String.split(regex: String): Array<String> = (this as java.lang.String).split(regex)
 
+/**
+ * Splits this string around occurrences of the specified character.
+ */
 public fun String.split(ch: Char): Array<String> = (this as java.lang.String).split(java.util.regex.Pattern.quote(ch.toString()))
 
+/**
+ * Returns a substring of this string starting with the specified index.
+ */
 public fun String.substring(beginIndex: Int): String = (this as java.lang.String).substring(beginIndex)
 
+/**
+ * Returns the substring of this string starting and ending at the specified indices.
+ */
 public fun String.substring(beginIndex: Int, endIndex: Int): String = (this as java.lang.String).substring(beginIndex, endIndex)
 
+/**
+ * Returns `true` if this string starts with the specified prefix.
+ */
 public fun String.startsWith(prefix: String): Boolean = (this as java.lang.String).startsWith(prefix)
 
+/**
+ * Returns `true` if a subsring of this string starting at the specified offset starts with the specified prefix.
+ */
 public fun String.startsWith(prefix: String, toffset: Int): Boolean = (this as java.lang.String).startsWith(prefix, toffset)
 
+/**
+ * Returns `true` if this string starts with the specified character.
+ */
 public fun String.startsWith(ch: Char): Boolean = (this as java.lang.String).startsWith(ch.toString())
 
+/**
+ * Returns `true` if this string contains the specified sequence of characters as a substring.
+ */
 public fun String.contains(seq: CharSequence): Boolean = (this as java.lang.String).contains(seq)
 
+/**
+ * Returns `true` if this string ends with the specified suffix.
+ */
 public fun String.endsWith(suffix: String): Boolean = (this as java.lang.String).endsWith(suffix)
 
+/**
+ * Returns `true` if this string ends with the specified character.
+ */
 public fun String.endsWith(ch: Char): Boolean = (this as java.lang.String).endsWith(ch.toString())
 
 // ""constructors"" for String
 
+/**
+ * Converts the data from a portion of the specified array of bytes to characters using the specified character set
+ * and returns the conversion result as a string.
+ *
+ * @param offset the offset in the array of the data to be converted.
+ * @param length the number of bytes to be converted.","charsetName parameter missing
",I don't think you need the `as` here.
945,"@@ -7,127 +7,358 @@ import java.util.regex.MatchResult
 import java.util.regex.Pattern
 import java.nio.charset.Charset
 
+/**
+ * Returns the index within this string of the last occurrence of the specified substring.
+ */
 public fun String.lastIndexOf(str: String): Int = (this as java.lang.String).lastIndexOf(str)
 
+/**
+ * Returns the index within this string of the last occurrence of the specified character.
+ */
 public fun String.lastIndexOf(ch: Char): Int = (this as java.lang.String).lastIndexOf(ch.toString())
 
+/**
+ * Compares this string to another string, ignoring case considerations.
+ */
 public fun String.equalsIgnoreCase(anotherString: String): Boolean = (this as java.lang.String).equalsIgnoreCase(anotherString)
 
+/**
+ * Returns the hash code of this string.
+ */
 public fun String.hashCode(): Int = (this as java.lang.String).hashCode()
 
+/**
+ * Returns the index within this string of the first occurrence of the specified substring.
+ */
 public fun String.indexOf(str: String): Int = (this as java.lang.String).indexOf(str)
 
+/**
+ * Returns the index within this string of the first occurrence of the specified substring, starting from the specified offset.
+ */
 public fun String.indexOf(str: String, fromIndex: Int): Int = (this as java.lang.String).indexOf(str, fromIndex)
 
+/**
+ * Returns a copy of this string with all occurrences of [oldChar] replaced with [newChar].
+ */
 public fun String.replace(oldChar: Char, newChar: Char): String = (this as java.lang.String).replace(oldChar, newChar)
 
+/**
+ * Returns a new string obtained by replacing each substring of this string that matches the given regular expression
+ * with the given [replacement].
+ */
 public fun String.replaceAll(regex: String, replacement: String): String = (this as java.lang.String).replaceAll(regex, replacement)
 
+/**
+ * Returns a copy of this string with leading and trailing whitespace trimmed.
+ */
 public fun String.trim(): String = (this as java.lang.String).trim()
 
+/**
+ * Returns a copy of this string converted to upper case using the rules of the default locale.
+ */
 public fun String.toUpperCase(): String = (this as java.lang.String).toUpperCase()
 
+/**
+ * Returns a copy of this string converted to lower case using the rules of the default locale.
+ */
 public fun String.toLowerCase(): String = (this as java.lang.String).toLowerCase()
 
+/**
+ * Returns a new character array containing the characters from this string.
+ */
 public fun String.toCharArray(): CharArray = (this as java.lang.String).toCharArray()
 
+/**
+ * Uses this string as a format string and returns a string obtained by substituting the specified arguments,
+ * using the default locale.
+ */
 public fun String.format(vararg args: Any?): String = java.lang.String.format(this, *args)
 
+/**
+ * Uses this string as a format string and returns a string obtained by substituting the specified arguments, using
+ * the specified locale.
+ */
 public fun String.format(locale: Locale, vararg args : Any?) : String = java.lang.String.format(locale, this, *args)
 
+/**
+ * Splits this string around matches of the given regular expression.
+ */
 public fun String.split(regex: String): Array<String> = (this as java.lang.String).split(regex)
 
+/**
+ * Splits this string around occurrences of the specified character.
+ */
 public fun String.split(ch: Char): Array<String> = (this as java.lang.String).split(java.util.regex.Pattern.quote(ch.toString()))
 
+/**
+ * Returns a substring of this string starting with the specified index.
+ */
 public fun String.substring(beginIndex: Int): String = (this as java.lang.String).substring(beginIndex)
 
+/**
+ * Returns the substring of this string starting and ending at the specified indices.
+ */
 public fun String.substring(beginIndex: Int, endIndex: Int): String = (this as java.lang.String).substring(beginIndex, endIndex)
 
+/**
+ * Returns `true` if this string starts with the specified prefix.
+ */
 public fun String.startsWith(prefix: String): Boolean = (this as java.lang.String).startsWith(prefix)
 
+/**
+ * Returns `true` if a subsring of this string starting at the specified offset starts with the specified prefix.
+ */
 public fun String.startsWith(prefix: String, toffset: Int): Boolean = (this as java.lang.String).startsWith(prefix, toffset)
 
+/**
+ * Returns `true` if this string starts with the specified character.
+ */
 public fun String.startsWith(ch: Char): Boolean = (this as java.lang.String).startsWith(ch.toString())
 
+/**
+ * Returns `true` if this string contains the specified sequence of characters as a substring.
+ */
 public fun String.contains(seq: CharSequence): Boolean = (this as java.lang.String).contains(seq)
 
+/**
+ * Returns `true` if this string ends with the specified suffix.
+ */
 public fun String.endsWith(suffix: String): Boolean = (this as java.lang.String).endsWith(suffix)
 
+/**
+ * Returns `true` if this string ends with the specified character.
+ */
 public fun String.endsWith(ch: Char): Boolean = (this as java.lang.String).endsWith(ch.toString())
 
 // ""constructors"" for String
 
+/**
+ * Converts the data from a portion of the specified array of bytes to characters using the specified character set
+ * and returns the conversion result as a string.
+ *
+ * @param offset the offset in the array of the data to be converted.
+ * @param length the number of bytes to be converted.
+ */
 public fun String(bytes: ByteArray, offset: Int, length: Int, charsetName: String): String = java.lang.String(bytes, offset, length, charsetName) as String
 
+/**
+ * Converts the data from a portion of the specified array of bytes to characters using the specified character set
+ * and returns the conversion result as a string.
+ *
+ * @param offset the offset in the array of the data to be converted.
+ * @param length the number of bytes to be converted.
+ */","charset parameter missing
",I don't think you need the `as` here.
946,"@@ -70,7 +72,11 @@ fun KtLambdaArgument.moveInsideParenthesesAndReplaceWith(
     val newCallExpression = oldCallExpression.copy() as KtCallExpression
 
     val psiFactory = KtPsiFactory(project)
-    val argument = if (newCallExpression.getValueArgumentsInParentheses().any { it.isNamed() }) {
+
+    val argument = if (newCallExpression.getValueArgumentsInParentheses().run {",I think this nested `run` expression is far too complex. Better to extract this logic into a method.,val argument = newCallExpression.getV
947,"@@ -71,48 +90,72 @@ public open class KotlinCompile(): AbstractCompile() {
 
     [TaskAction]
     override fun compile() {
-
-        getLogger().debug(""Starting Kotlin compilation task"")
-
-        val args = K2JVMCompilerArguments()
-
-        val javaSrcRoots = HashSet<File>()
-        val sources = ArrayList<File>()
-
-        // collect source directory roots for all java files to allow cross compilation
-        for (file in getSource()) {
-            if (FilenameUtils.getExtension(file.getName()).equalsIgnoreCase(""java"")) {
-                val javaRoot = findSrcDirRoot(file)
-                if (javaRoot != null) {
-                    javaSrcRoots.add(javaRoot)
-                }
-            } else {
-                sources.add(file)
-            }
-        }
-
+        getLogger().debug(""Starting ${javaClass} task"")
+        val args = createBlankArgs()
+        val sources = getKotlinSources()
         if (sources.empty) {
             getLogger().warn(""No Kotlin files found, skipping Kotlin compiler task"")
             return
         }
 
+        populateTargetSpecificArgs(args, sources)
+        populateCommonArgs(args, sources)
+        callCompiler(args)
+        afterCompileHook(args)
+    }
+
+    protected fun isJava(it: File): Boolean = FilenameUtils.getExtension(it.getName()).equalsIgnoreCase(""java"")
+
+    private fun getKotlinSources(): ArrayList<File> = getSource()","The call chain may be written in one line
",Why do we need this?
948,"@@ -71,48 +90,72 @@ public open class KotlinCompile(): AbstractCompile() {
 
     [TaskAction]
     override fun compile() {
-
-        getLogger().debug(""Starting Kotlin compilation task"")
-
-        val args = K2JVMCompilerArguments()
-
-        val javaSrcRoots = HashSet<File>()
-        val sources = ArrayList<File>()
-
-        // collect source directory roots for all java files to allow cross compilation
-        for (file in getSource()) {
-            if (FilenameUtils.getExtension(file.getName()).equalsIgnoreCase(""java"")) {
-                val javaRoot = findSrcDirRoot(file)
-                if (javaRoot != null) {
-                    javaSrcRoots.add(javaRoot)
-                }
-            } else {
-                sources.add(file)
-            }
-        }
-
+        getLogger().debug(""Starting ${javaClass} task"")
+        val args = createBlankArgs()
+        val sources = getKotlinSources()
         if (sources.empty) {
             getLogger().warn(""No Kotlin files found, skipping Kotlin compiler task"")
             return
         }
 
+        populateTargetSpecificArgs(args, sources)
+        populateCommonArgs(args, sources)
+        callCompiler(args)
+        afterCompileHook(args)
+    }
+
+    protected fun isJava(it: File): Boolean = FilenameUtils.getExtension(it.getName()).equalsIgnoreCase(""java"")
+
+    private fun getKotlinSources(): ArrayList<File> = getSource()
+            .filterNot { isJava(it) }","I think more properly to check that it's kotlin file.

P.S. I see that it's legacy code
",Why do we need this?
949,"@@ -71,48 +90,72 @@ public open class KotlinCompile(): AbstractCompile() {
 
     [TaskAction]
     override fun compile() {
-
-        getLogger().debug(""Starting Kotlin compilation task"")
-
-        val args = K2JVMCompilerArguments()
-
-        val javaSrcRoots = HashSet<File>()
-        val sources = ArrayList<File>()
-
-        // collect source directory roots for all java files to allow cross compilation
-        for (file in getSource()) {
-            if (FilenameUtils.getExtension(file.getName()).equalsIgnoreCase(""java"")) {
-                val javaRoot = findSrcDirRoot(file)
-                if (javaRoot != null) {
-                    javaSrcRoots.add(javaRoot)
-                }
-            } else {
-                sources.add(file)
-            }
-        }
-
+        getLogger().debug(""Starting ${javaClass} task"")
+        val args = createBlankArgs()
+        val sources = getKotlinSources()
         if (sources.empty) {
             getLogger().warn(""No Kotlin files found, skipping Kotlin compiler task"")
             return
         }
 
+        populateTargetSpecificArgs(args, sources)
+        populateCommonArgs(args, sources)
+        callCompiler(args)
+        afterCompileHook(args)
+    }
+
+    protected fun isJava(it: File): Boolean = FilenameUtils.getExtension(it.getName()).equalsIgnoreCase(""java"")
+
+    private fun getKotlinSources(): ArrayList<File> = getSource()
+            .filterNot { isJava(it) }
+            .toArrayList()
+
+    protected fun populateCommonArgs(args: T, sources: ArrayList<File>) {","should be it private?
",Why do we need this method?
950,"@@ -71,48 +90,72 @@ public open class KotlinCompile(): AbstractCompile() {
 
     [TaskAction]
     override fun compile() {
-
-        getLogger().debug(""Starting Kotlin compilation task"")
-
-        val args = K2JVMCompilerArguments()
-
-        val javaSrcRoots = HashSet<File>()
-        val sources = ArrayList<File>()
-
-        // collect source directory roots for all java files to allow cross compilation
-        for (file in getSource()) {
-            if (FilenameUtils.getExtension(file.getName()).equalsIgnoreCase(""java"")) {
-                val javaRoot = findSrcDirRoot(file)
-                if (javaRoot != null) {
-                    javaSrcRoots.add(javaRoot)
-                }
-            } else {
-                sources.add(file)
-            }
-        }
-
+        getLogger().debug(""Starting ${javaClass} task"")
+        val args = createBlankArgs()
+        val sources = getKotlinSources()
         if (sources.empty) {
             getLogger().warn(""No Kotlin files found, skipping Kotlin compiler task"")
             return
         }
 
+        populateTargetSpecificArgs(args, sources)
+        populateCommonArgs(args, sources)
+        callCompiler(args)
+        afterCompileHook(args)
+    }
+
+    protected fun isJava(it: File): Boolean = FilenameUtils.getExtension(it.getName()).equalsIgnoreCase(""java"")
+
+    private fun getKotlinSources(): ArrayList<File> = getSource()
+            .filterNot { isJava(it) }
+            .toArrayList()
+
+    protected fun populateCommonArgs(args: T, sources: ArrayList<File>) {
+        args.freeArgs = sources.map { it.getAbsolutePath() }
         args.suppressWarnings = kotlinOptions.suppressWarnings
+        args.verbose = kotlinOptions.verbose
         args.version = kotlinOptions.version
-        args.verbose = logger.isDebugEnabled()
+        args.noInline = kotlinOptions.noInline
+    }
 
-        args.freeArgs = sources.map { it.getAbsolutePath() }
+    abstract protected fun populateTargetSpecificArgs(args: T, sources: ArrayList<File>)","looks like we don't need `sources` in `populateTargetSpecificArgs`
",Why do we need this?
951,"@@ -714,6 +714,43 @@ class StringTest {
         }
     }
 
+    @test fun occurencesOf() {
+        // Multiple overlapping occurances
+        assertEquals(""abaabaaababac"".occurrencesOf(""abaa"", matchOverlapping = true).toList(), listOf(0, 3))","`expected` value comes first, `actual` value second.
",I think you can use `assertThat(listO
952,"@@ -73,10 +73,10 @@ object SwitchDemo {
         val status = """"
         when (status) {
             ""init"", ""dial"", ""transmit"" -> return 0x111111
-            ""ok"" -> return 0xFF006600.toInt()
-            ""cancel"" -> return 0xFF666666.toInt()
-            ""fail"", ""busy"", ""error"" -> return 0xFF660000.toInt()
-            else -> return 0xFF660000.toInt()
+            ""ok"" -> return -16751104","Please, write out these numbers in hex, if input in hex. ",Why did you remove these codes?
953,"@@ -73,6 +73,14 @@ public static ASTNode createColonNode(Project project) {
         return property.getNode().findChildByType(JetTokens.COLON);
     }
 
+    @NotNull
+    public static PsiElement createSemicolon(Project project) {
+        JetProperty property = createProperty(project, ""val x: Int;"");
+        PsiElement colon = property.findElementAt(10);","Colon variable should be renamed to senilicon
",This should be `findElementAt(11)`.
954,"@@ -75,6 +75,9 @@ public fun ByteArray.toString(charset: String): String = String(this, charset)
  */
 public fun ByteArray.toString(charset: Charset): String = String(this, charset)
 
+/**
+ * Returnsn an array containing the elements of this collection.","typo ""returnsn""
",* Returns an array containing the ele
955,"@@ -77,13 +78,18 @@ class ControlFlowInstructionsGenerator : ControlFlowBuilderAdapter() {
         delegateBuilder.enterSubroutine(subroutine)
     }
 
-    override fun exitSubroutine(subroutine: KtElement): Pseudocode {
-        super.exitSubroutine(subroutine)
+    override fun exitSubroutine(subroutine: KtElement, invocationKind: InvocationKind?): Pseudocode {
+        super.exitSubroutine(subroutine, invocationKind)
         delegateBuilder.exitBlockScope(subroutine)
         val worker = popBuilder()
         if (!builders.empty()) {
             val builder = builders.peek()
-            builder.declareFunction(subroutine, worker.pseudocode)
+
+            if (invocationKind == null) {
+                builder.declareFunction(subroutine, worker.pseudocode)
+            } else {",Formatting,Why do we need this?
956,"@@ -77,6 +77,18 @@ private static void addName(ArrayList<String> result, String name, JetNameValida
         if (result.isEmpty()) addName(result, ""value"", validator);
         return ArrayUtil.toStringArray(result);
     }
+
+    public static String[] suggestNamesForType(JetType jetType, JetNameValidator validator) {
+        ArrayList<String> result = new ArrayList<String>();
+        addNamesForType(result, jetType, validator);
+        return ArrayUtil.toStringArray(result);
+    }
+
+    public static String[] suggestNamesForExpression(JetExpression expression, JetNameValidator validator) {
+        ArrayList<String> result = new ArrayList<String>();
+        addNamesForExpression(result, expression, validator);
+        return ArrayUtil.toStringArray(result);","Why converting this to array? Why not return list?
",`suggestNamesForExpression` -> `sugge
957,"@@ -773,7 +773,7 @@ public fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {
 }
 
 /**
- * Returns a list containing elements at specified positions
+ * Returns a string containing characters at specified positions","copypasta: Array is not a string
",I think this should be `<msg><msg>Thi
958,"@@ -78,7 +81,7 @@ private fun collectNullCheckExpressions(expression: KtBinaryExpression): Triple<
 
 private fun isNullChecksToSafeCallFixAvailable(expression: KtBinaryExpression): Boolean {
     val (lte, rte) = collectNullCheckExpressions(expression) ?: return false
-    return getDuplicates(lte, rte)?.parent as? KtDotQualifiedExpression != null
+    return lte.isChainStable() && getDuplicates(lte, rte)?.parent as? KtDotQualifiedExpression != null",At least one or two tests required here,Why is this change needed?
959,"@@ -8,6 +8,7 @@ false
 for
 if
 in
+interface","Why?
",Why is<msg><msg><msg><msg><msg><msg><
960,"@@ -81,16 +81,11 @@ public abstract class AnnotationProcessorWrapper(
             return
         }
 
-        val annotationsFile = processingEnv.getOptions().get(KAPT_ANNOTATION_OPTION)
-        if (annotationsFile != null) {
-            try {
-                kotlinAnnotationsProvider = FileKotlinAnnotationProvider(File(annotationsFile))
-            }
-            catch (e: IOException) {
-                kotlinAnnotationsProvider = EmptyKotlinAnnotationsProvider()
-            }
-        }
-        else kotlinAnnotationsProvider = EmptyKotlinAnnotationsProvider()
+        val annotationsFilePath = processingEnv.getOptions().get(KAPT_ANNOTATION_OPTION)
+        val annotationsFile = if (annotationsFilePath != null) File(annotationsFilePath) else null
+        kotlinAnnotationsProvider = if (annotationsFile != null && annotationsFile.exists()) {
+            FileKotlinAnnotationProvider(annotationsFile)
+        } else EmptyKotlinAnnotationsProvider()","Could you please put `else` on the new line and add `{}` for it? So it would be agreed with our coding conventions.
",You can use `FileUtils.isFile` here.
961,"@@ -82,7 +89,8 @@ public inline fun <T:Any> checkNotNull(value: T?): T = checkNotNull(value) { ""Re
  * @sample samples.misc.Preconditions.failCheckWithLazyMessage
  */
 @kotlin.internal.InlineOnly
-public inline fun <T:Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {
+@kotlin.internal.Returns
+public inline fun <T:Any> checkNotNull(@kotlin.internal.Equals(kotlin.internal.ConstantValue.NOT_NULL) value: T?, lazyMessage: () -> Any): T {",Can we annotate also `error` below?,I think this should be `@kotlin.inte
962,"@@ -824,6 +824,8 @@
     DiagnosticFactory0<KtExpression> ALWAYS_NULL = DiagnosticFactory0.create(WARNING);
 
     DiagnosticFactory0<KtNullableType> USELESS_NULLABLE_CHECK = DiagnosticFactory0.create(WARNING, NULLABLE_TYPE);
+    DiagnosticFactory0<KtElement> USELESS_IS_CHECK = DiagnosticFactory0.create(WARNING);
+    DiagnosticFactory0<KtElement> USELESS_IS_NOT_CHECK = DiagnosticFactory0.create(WARNING);","I'd propose to use one diagnosti: 
```
DiagnosticFactory1<KtElement, Boolean> USELESS_IS_CHECK = DiagnosticFactory1.create(WARNING);
```",DiagnosticFactory0<KtElement> USELES
963,"@@ -83,6 +83,35 @@ object MoveDeclarationsOutHelper {
         return PsiUtilCore.toPsiElementArray(resultStatements)
     }
 
+    private fun addSymbolAfterDeclaration(container: PsiElement, declaration: KtProperty, isLastStatemnt: Boolean) {","typo: statemnt -> statement
",nit: rename to `addSymbolAfterDeclar
964,"@@ -83,6 +83,35 @@ object MoveDeclarationsOutHelper {
         return PsiUtilCore.toPsiElementArray(resultStatements)
     }
 
+    private fun addSymbolAfterDeclaration(container: PsiElement, declaration: KtProperty, isLastStatemnt: Boolean) {
+        if (isLastStatemnt) {
+            container.addAfter(KtPsiFactory(declaration).createEQ(), declaration)
+        }
+        else {
+            container.addAfter(KtPsiFactory(declaration).createNewLine(), declaration)","It should never be necessary to create newlines from text. All newlines should be inserted by the formatter.
",nit: `addSymbolAfterDeclaration` -> 
965,"@@ -83,7 +84,9 @@ sealed class ReplCompileResult : Serializable {
                           val mainClassName: String,
                           val classes: List<CompiledClassData>,
                           val hasResult: Boolean,
-                          val classpathAddendum: List<File>) : ReplCompileResult()
+                          val classpathAddendum: List<File>) : ReplCompileResult() {
+        val type = LastInferredTypeHolder.inferredType.get()","It would be easier to pass the expression type explicitly to `ReplCompileResult.CompiledClasses`'s constructor where it's created at `GenericReplCompiler.compile` with:
```
val expression = psiFile.getChildOfType<KtExpression>()
compilerState.analyzerEngine.trace.bindingContext.getType(expression)
```
(+ handle the case when there's no expression in a REPL line)",Why do we need this?
966,"@@ -84,109 +104,113 @@ public fun CharSequence.slice(indices: Iterable<Int>): CharSequence {
 }
 
 /**
- * Returns a substring specified by given range
+ * Returns a substring specified by the given [range].
  */
 public fun String.substring(range: IntRange): String = substring(range.start, range.end + 1)
 
 /**
- * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
- * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
- * a special *truncated* separator (which defaults to ""..."")
+ * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.
+ * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]
+ * elements will be appended, followed by the [truncated] string (which defaults to ""..."").
  */
 public fun Iterable<String>.join(separator: String = "", "", prefix: String = """", postfix: String = """", limit: Int = -1, truncated: String = ""...""): String {
     return joinToString(separator, prefix, postfix, limit, truncated)
 }
 
 /**
- * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
- * If an array could be huge you can specify a non-negative value of *limit* which will only show a subset of the array then it will
- * a special *truncated* separator (which defaults to ""..."")
+ * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.
+ * If the array could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]
+ * elements will be appended, followed by the [truncated] string (which defaults to ""..."").
  */
 public fun Array<String>.join(separator: String = "", "", prefix: String = """", postfix: String = """", limit: Int = -1, truncated: String = ""...""): String {
     return joinToString(separator, prefix, postfix, limit, truncated)
 }
 
 /**
- * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
- * If a stream could be huge you can specify a non-negative value of *limit* which will only show a subset of the stream then it will
- * a special *truncated* separator (which defaults to ""..."")
+ * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.
+ * If the stream could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]
+ * elements will be appended, followed by the [truncated] string (which defaults to ""..."").
  */
 public fun Stream<String>.join(separator: String = "", "", prefix: String = """", postfix: String = """", limit: Int = -1, truncated: String = ""...""): String {
     return joinToString(separator, prefix, postfix, limit, truncated)
 }
+
 /**
- * Returns a substring before first occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring before the first occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringBefore(delimiter: Char, missingSeparatorValue : String = this): String {
+public fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {
     val index = indexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(0, index)
+    return if (index == -1) missingDelimiterValue else substring(0, index)
 }
 
 /**
- * Returns a substring before first occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring before the first occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringBefore(delimiter: String, missingSeparatorValue : String = this): String {
+public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {
     val index = indexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(0, index)
+    return if (index == -1) missingDelimiterValue else substring(0, index)
 }
+
 /**
- * Returns a substring after first occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring after the first occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringAfter(delimiter: Char, missingSeparatorValue : String = this): String {
+public fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {
     val index = indexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(index + 1, length)
+    return if (index == -1) missingDelimiterValue else substring(index + 1, length)
 }
 
 /**
- * Returns a substring after first occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring after the first occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringAfter(delimiter: String, missingSeparatorValue : String = this): String {
+public fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {
     val index = indexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(index + delimiter.length, length)
+    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)
 }
 
 /**
- * Returns a substring before last occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring before the last occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringBeforeLast(delimiter: Char, missingSeparatorValue : String = this): String {
+public fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {
     val index = lastIndexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(0, index)
+    return if (index == -1) missingDelimiterValue else substring(0, index)
 }
 
 /**
- * Returns a substring before last occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring before the last occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringBeforeLast(delimiter: String, missingSeparatorValue : String = this): String {
+public fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {
     val index = lastIndexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(0, index)
+    return if (index == -1) missingDelimiterValue else substring(0, index)
 }
 
 /**
- * Returns a substring after last occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring after the last occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringAfterLast(delimiter: Char, missingSeparatorValue : String = this): String {
+public fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {
     val index = lastIndexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(index + 1, length)
+    return if (index == -1) missingDelimiterValue else substring(index + 1, length)
 }
 
 /**
- * Returns a substring after last occurrence of delimiter.
- * In case of no delimiter, returns the value of missingSeparatorValue which defaults to original string.
+ * Returns a substring after the last occurrence of [delimiter].
+ * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.
  */
-public fun String.substringAfterLast(delimiter: String, missingSeparatorValue : String = this): String {
+public fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {
     val index = lastIndexOf(delimiter)
-    return if (index == -1) missingSeparatorValue else substring(index + delimiter.length, length)
+    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)
 }
 
 /**
- * Replace part of string at given range with replacement string
+ * Replace the part of string at given the range with the [replacement] string.","""Replaces"", ""of the string""
",This is a breaking change.
967,"@@ -85,30 +87,73 @@ class KotlinShortNamesCache(private val project: Project) : PsiShortNamesCache()
         dest.addAll(allClassNames)
     }
 
-    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod>
-            = emptyArray()
+    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod> {
+        return getMethodSequenceByName(name, scope).toList().toTypedArray()
+    }
+
+    fun getMethodSequenceByName(name: String, scope: GlobalSearchScope): Sequence<PsiMethod> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
+
+        val kotlinFunctionsPsi = functionIndex.get(name, project, scope).asSequence()
+                .flatMap { LightClassUtil.getLightClassMethods(it).asSequence() }
+                .filter { it.name == name }
+
+        val propertyAccessorsPsi = getPropertyNamesCandidatesByAccessorName(Name.identifier(name)).asSequence()
+                .flatMap { propertiesIndex.get(it.asString(), project, scope).asSequence() }
+                .flatMap { LightClassUtil.getLightClassPropertyMethods(it).allDeclarations.asSequence() }
+                .filter { it.name == name }
+                .map { it as? PsiMethod }
 
-    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod>
-            = emptyArray()
+        return (propertyAccessorsPsi + kotlinFunctionsPsi).filterNotNull()","This accesses the property index even if it's not actually necessary (if the sequence enumeration stops before we reach the property names). Would be nice to use something like `sequenceOfLazyValues().flatMap` to avoid this.
",Why do we need to filter here?
968,"@@ -85,30 +87,73 @@ class KotlinShortNamesCache(private val project: Project) : PsiShortNamesCache()
         dest.addAll(allClassNames)
     }
 
-    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod>
-            = emptyArray()
+    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod> {
+        return getMethodSequenceByName(name, scope).toList().toTypedArray()
+    }
+
+    fun getMethodSequenceByName(name: String, scope: GlobalSearchScope): Sequence<PsiMethod> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
+
+        val kotlinFunctionsPsi = functionIndex.get(name, project, scope).asSequence()
+                .flatMap { LightClassUtil.getLightClassMethods(it).asSequence() }
+                .filter { it.name == name }
+
+        val propertyAccessorsPsi = getPropertyNamesCandidatesByAccessorName(Name.identifier(name)).asSequence()
+                .flatMap { propertiesIndex.get(it.asString(), project, scope).asSequence() }
+                .flatMap { LightClassUtil.getLightClassPropertyMethods(it).allDeclarations.asSequence() }
+                .filter { it.name == name }
+                .map { it as? PsiMethod }
 
-    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod>
-            = emptyArray()
+        return (propertyAccessorsPsi + kotlinFunctionsPsi).filterNotNull()
+    }
+
+    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod> {
+        val psiMethods = getMethodSequenceByName(name, scope)
+        val limitedByMaxCount = psiMethods.take(maxCount)
+        psiMethods.drop(maxCount).firstOrNull()?.let { return PsiMethod.EMPTY_ARRAY }","You can avoid repeated iteration of the sequence if you use `take(maxCount+1)` and check if you actually got N+1 elements.
",Why do we need to do this?
969,"@@ -85,30 +87,78 @@ class KotlinShortNamesCache(private val project: Project) : PsiShortNamesCache()
         dest.addAll(allClassNames)
     }
 
-    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod>
-            = emptyArray()
+    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
 
-    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod>
-            = emptyArray()
+        val kotlinFunctionsPsi = functionIndex.get(name, project, scope)
+                .flatMap { LightClassUtil.getLightClassMethods(it) }
 
-    override fun getFieldsByNameIfNotMoreThan(s: String, scope: GlobalSearchScope, i: Int): Array<PsiField>
-            = emptyArray()
+        val propertyAccessorsPsi = getPropertyNamesCandidatesByAccessorName(Name.identifier(name))
+                .flatMap { propertiesIndex.get(it.asString(), project, scope) }
+                .flatMap { LightClassUtil.getLightClassPropertyMethods(it).allDeclarations }
+                .filter { it.name == name }
+                .map { it as? PsiMethod }
+
+        return (propertyAccessorsPsi + kotlinFunctionsPsi).filterNotNull().toList().toTypedArray()
+    }
+
+    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod> {
+        val methods = getMethodsByName(name, scope)
+        if (methods.size > maxCount)","This implementation defeats the purpose of this method. You should calculate the candidates lazily and stop evaluating if you've found more than `maxCount` candidates.
",Why do we need to call `toTypedArray
970,"@@ -85,30 +87,78 @@ class KotlinShortNamesCache(private val project: Project) : PsiShortNamesCache()
         dest.addAll(allClassNames)
     }
 
-    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod>
-            = emptyArray()
+    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
 
-    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod>
-            = emptyArray()
+        val kotlinFunctionsPsi = functionIndex.get(name, project, scope)
+                .flatMap { LightClassUtil.getLightClassMethods(it) }
 
-    override fun getFieldsByNameIfNotMoreThan(s: String, scope: GlobalSearchScope, i: Int): Array<PsiField>
-            = emptyArray()
+        val propertyAccessorsPsi = getPropertyNamesCandidatesByAccessorName(Name.identifier(name))
+                .flatMap { propertiesIndex.get(it.asString(), project, scope) }
+                .flatMap { LightClassUtil.getLightClassPropertyMethods(it).allDeclarations }
+                .filter { it.name == name }
+                .map { it as? PsiMethod }
+
+        return (propertyAccessorsPsi + kotlinFunctionsPsi).filterNotNull().toList().toTypedArray()
+    }
+
+    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod> {
+        val methods = getMethodsByName(name, scope)
+        if (methods.size > maxCount)
+            return PsiMethod.EMPTY_ARRAY
+        return methods
+    }
+
+    override fun getFieldsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiField> {
+        val fields = getFieldsByName(name, scope)
+        if (fields.size > maxCount)
+            return PsiField.EMPTY_ARRAY
+        return fields
+    }
 
     override fun processMethodsWithName(name: String, scope: GlobalSearchScope, processor: Processor<PsiMethod>): Boolean
             = ContainerUtil.process(getMethodsByName(name, scope), processor)
 
-    override fun getAllMethodNames(): Array<String>
-            = emptyArray()
+    override fun getAllMethodNames(): Array<String> {
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
+        val functionNames = functionIndex.getAllKeys(project)
+
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val globalScope = GlobalSearchScope.allScope(project)
+        val propertyAccessorNames = propertiesIndex.getAllKeys(project)
+                .flatMap { propertiesIndex.get(it, project, globalScope) }","This will be extremely slow. It's OK to return names for which `getMethodsByName()` will then not find any methods, but it's not OK to look up every single method in the index. You should only use `getAllKeys()` and then calculate possible accessor names from those, without any lookups to the property index.
",Why do we need to call `getLightClas
971,"@@ -85,30 +87,78 @@ class KotlinShortNamesCache(private val project: Project) : PsiShortNamesCache()
         dest.addAll(allClassNames)
     }
 
-    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod>
-            = emptyArray()
+    override fun getMethodsByName(name: String, scope: GlobalSearchScope): Array<PsiMethod> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
 
-    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod>
-            = emptyArray()
+        val kotlinFunctionsPsi = functionIndex.get(name, project, scope)
+                .flatMap { LightClassUtil.getLightClassMethods(it) }
 
-    override fun getFieldsByNameIfNotMoreThan(s: String, scope: GlobalSearchScope, i: Int): Array<PsiField>
-            = emptyArray()
+        val propertyAccessorsPsi = getPropertyNamesCandidatesByAccessorName(Name.identifier(name))
+                .flatMap { propertiesIndex.get(it.asString(), project, scope) }
+                .flatMap { LightClassUtil.getLightClassPropertyMethods(it).allDeclarations }
+                .filter { it.name == name }
+                .map { it as? PsiMethod }
+
+        return (propertyAccessorsPsi + kotlinFunctionsPsi).filterNotNull().toList().toTypedArray()
+    }
+
+    override fun getMethodsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiMethod> {
+        val methods = getMethodsByName(name, scope)
+        if (methods.size > maxCount)
+            return PsiMethod.EMPTY_ARRAY
+        return methods
+    }
+
+    override fun getFieldsByNameIfNotMoreThan(name: String, scope: GlobalSearchScope, maxCount: Int): Array<PsiField> {
+        val fields = getFieldsByName(name, scope)
+        if (fields.size > maxCount)
+            return PsiField.EMPTY_ARRAY
+        return fields
+    }
 
     override fun processMethodsWithName(name: String, scope: GlobalSearchScope, processor: Processor<PsiMethod>): Boolean
             = ContainerUtil.process(getMethodsByName(name, scope), processor)
 
-    override fun getAllMethodNames(): Array<String>
-            = emptyArray()
+    override fun getAllMethodNames(): Array<String> {
+        val functionIndex = KotlinFunctionShortNameIndex.getInstance()
+        val functionNames = functionIndex.getAllKeys(project)
+
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val globalScope = GlobalSearchScope.allScope(project)
+        val propertyAccessorNames = propertiesIndex.getAllKeys(project)
+                .flatMap { propertiesIndex.get(it, project, globalScope) }
+                .flatMap { it.getAccessorNames() }
+
+        return (functionNames + propertyAccessorNames).toTypedArray()
+    }
 
     override fun getAllMethodNames(set: HashSet<String>) {
+        set.addAll(allMethodNames)
+    }
+
+    override fun getFieldsByName(name: String, scope: GlobalSearchScope): Array<PsiField> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+
+        return propertiesIndex.get(name, project, scope)
+                .map { LightClassUtil.getLightClassBackingField(it) }
+                .filterNotNull()
+                .toTypedArray()
     }
 
-    override fun getFieldsByName(name: String, scope: GlobalSearchScope): Array<PsiField>
-            = emptyArray()
+    override fun getAllFieldNames(): Array<String> {
+        val propertiesIndex = KotlinPropertyShortNameIndex.getInstance()
+        val globalScope = GlobalSearchScope.allScope(project)
 
-    override fun getAllFieldNames(): Array<String>
-            = emptyArray()
+        return propertiesIndex.getAllKeys(project)
+                .flatMap { propertiesIndex.get(it, project, globalScope) }","Same here. No property index lookups please.
",Why do we need to call `getLightClas
972,"@@ -854,4 +854,38 @@ class CollectionTest {
         // we need toString() inside pattern because of KT-8666
         assertEquals(""[1, a, null, ${Long.MAX_VALUE.toString()}]"", listOf(1, ""a"", null, Long.MAX_VALUE).toString())
     }
+
+    @test fun testGetRange() {
+        val listStr = listOf(""a"", ""b"", ""c"", ""d"", ""e"")
+
+        assertTrue(throwsError{listStr[-1..2]})
+        assertTrue(throwsError{listStr[1..10]})
+
+        assertTrue(listStr[1..3] == listOf(""b"", ""c"", ""d""))
+        assertTrue(listStr[1..3] is List<String>)
+        assertTrue(listStr[1..3][0..1] == listOf(""b"", ""c""))
+        assertTrue(listStr[1..3][0..1] is List<String>)
+        assertTrue(listStr[1..3][0..1][0] is String)
+        assertTrue(listStr[1..3][0..1][0] == ""b"")
+
+        assertTrue(listStr[1..1] == listOf(listStr[1]))
+        assertTrue(listStr[3..1] == listOf<String>())
+    }
+
+    fun throwsError(f :()->Unit): Boolean {
+        try{
+            f()
+        } catch(e: Exception){
+            return true
+        }
+        return false
+    }
+
+    @test fun testListTimes(){
+        val shortlistStr = listOf(""a"", ""b"")
+        assertTrue(shortlistStr*0 == listOf<String>())","`assertEquals(expected, actual)` is preferred as it dumps diff on failure
",You can use `assertThrows` here.
973,"@@ -854,4 +854,41 @@ class CollectionTest {
         // we need toString() inside pattern because of KT-8666
         assertEquals(""[1, a, null, ${Long.MAX_VALUE.toString()}]"", listOf(1, ""a"", null, Long.MAX_VALUE).toString())
     }
+
+    @test fun testGetRange() {
+        val listStr = listOf(""a"", ""b"", ""c"", ""d"", ""e"")","I believe we also need tests on an empty list: should fail at any range but empty range on empty list should produce empty list 
","You can use `assertThat(listStr, con"
974,"@@ -854,4 +854,41 @@ class CollectionTest {
         // we need toString() inside pattern because of KT-8666
         assertEquals(""[1, a, null, ${Long.MAX_VALUE.toString()}]"", listOf(1, ""a"", null, Long.MAX_VALUE).toString())
     }
+
+    @test fun testGetRange() {
+        val listStr = listOf(""a"", ""b"", ""c"", ""d"", ""e"")
+
+        assertTrue(throwsError{listStr[-1..2]})
+        assertTrue(throwsError{listStr[1..10]})
+
+        assertEquals(listStr[IntRange.EMPTY], listOf<String>())","I should be expected value at the first place, the second argument is actual, swap these arguments please
",You can use `assertThrows` instead o
975,"@@ -86,6 +86,8 @@
         <include name=""compiler/builtins-serializer/src""/>
         <include name=""compiler/cli/src""/>
         <include name=""compiler/cli/cli-common/src""/>
+        <include name=""compiler/rmi/rmi-server/src""/>
+        <include name=""compiler/rmi/rmi-interface/src""/>","There's another fileset which is used in the `compiler-quick` target and declared just below, please also add these modules there.

Also please add them to `compiler-sources`.
",Why is this needed?
976,"@@ -86,7 +86,8 @@ protected void configureSpecificCompilerArguments(@NotNull K2JSCompilerArguments
             collector.add(new File(outputFile).getParent());
         }
         if (metaInfo) {
-            String metaFile = KotlinPackage.substringBeforeLast(outputFile, JavaScript.DOT_EXTENSION, outputFile) + KotlinJavascriptMetadataUtils.META_JS_SUFFIX;
+            String output = com.google.common.base.Objects.firstNonNull(outputFile, """"); // fqname here because of J8 compatibility issues","Is it not possible with Kotlin stdlib?
",Why do we need this change?
977,"@@ -867,7 +912,8 @@ class DefaultExpressionConverter : JavaElementVisitor(), ExpressionConverter {
                 if (parameters.size == 1 && !isKotlinFunctionType) {
                     // for lambdas all parameters with types should be present
                     emptyList()
-                } else {
+                }
+                else {",Please restore previous code formatting - actual `if-else` statements and spaces are against accepted conceptions.,nit: unnecessary change
978,"@@ -87,15 +87,24 @@ public boolean execute() throws BuildException {
 
         kotlinc.getAdditionalArguments().addAll(additionalArguments);
 
-        kotlinc.execute();
-        if (!Integer.valueOf(0).equals(kotlinc.getExitCode())) {
-            // Don't run javac if failOnError = false and there were errors on Kotlin sources
-            return false;
+        // Javac13#execute passes everything in compileList to javac, which doesn't recognize .kt files
+        File[] compileListForJavac = filterOutKotlinSources(compileList);
+
+        boolean hasKotlinFilesInSources = compileListForJavac.length < compileList.length;
+
+        if (hasKotlinFilesInSources) {
+            kotlinc.execute();
+            if (!Integer.valueOf(0).equals(kotlinc.getExitCode())) {
+                // Don't run javac if failOnError = false and there were errors on Kotlin sources
+                return false;
+            }
+        }
+        else {
+            kotlinc.fillArguments();","what for this?
",I don't think we need to ch
979,"@@ -87,15 +87,24 @@ public boolean execute() throws BuildException {
 
         kotlinc.getAdditionalArguments().addAll(additionalArguments);
 
-        kotlinc.execute();
-        if (!Integer.valueOf(0).equals(kotlinc.getExitCode())) {
-            // Don't run javac if failOnError = false and there were errors on Kotlin sources
-            return false;
+        // Javac13#execute passes everything in compileList to javac, which doesn't recognize .kt files
+        File[] compileListForJavac = filterOutKotlinSources(compileList);
+
+        boolean hasKotlinFilesInSources = compileListForJavac.length < compileList.length;
+
+        if (hasKotlinFilesInSources) {
+            kotlinc.execute();
+            if (!Integer.valueOf(0).equals(kotlinc.getExitCode())) {
+                // Don't run javac if failOnError = false and there were errors on Kotlin sources
+                return false;
+            }
+        }
+        else {
+            kotlinc.fillArguments();
         }
 
         javac.log(""Running javac..."");
 
-        // Javac13#execute passes everything in compileList to javac, which doesn't recognize .kt files
         compileList = filterOutKotlinSources(compileList);","why do you filter it twice?
",I'm not sure if this is the
980,"@@ -88,8 +85,10 @@ class ConvertFunctionToPropertyIntention : SelfTargetingIntention<KtNamedFunctio
             function.setName(newName)
 
             val property = originalFunction.replace(psiFactory.createProperty(function.text)) as KtProperty
-            if (needsExplicitType) {
-                elementsToShorten.add(property.typeReference!!)
+
+            if (!hasExplicitType) {
+                val linebreak = property.getter?.node?.treePrev","Ouch. This should be handled by a formatter rule, not by AST manipulations.",Why do we need this?
981,"@@ -9,11 +9,11 @@ import java.io.Serializable
  * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.
  *
  * An example of decomposing it into values:
- * ${code test.tuples.PairTest.pairMultiAssignment}
+ * @sample test.tuples.PairTest.pairMultiAssignment
  *
- * $constructor: Creates new instance of [Pair]
- * $first: First value
- * $second: Second value
+ * @param first First value","Missing @param for type parameters.
",This should be `@param seco
982,"@@ -9,7 +9,7 @@ internal trait One {
 }
 
 internal trait OneImpl : One {
-    invisible_fake open override /*1*/ /*fake_override*/ fun boo(): kotlin.Int
+    invisible_fake final override /*1*/ /*fake_override*/ fun boo(): kotlin.Int","I suspect that this may lead to some unexpected errors in subclasses
",Why is this change needed?
983,"@@ -9,8 +9,9 @@ import kotlin.test.assertTrue
 import kotlin.test.assertEquals
 import kotlin.test.fail
 
-open class BaseGradleIT {
+open class BaseGradleIT(val resourcesRoot: String = ""src/test/resources"") {","There is no need to make resourcesRoot a property: you can remove val keyword to make it a constructor parameter
",Why do we need this change?
984,"@@ -9,8 +9,9 @@ import kotlin.test.assertTrue
 import kotlin.test.assertEquals
 import kotlin.test.fail
 
-open class BaseGradleIT {
+open class BaseGradleIT(val resourcesRoot: String = ""src/test/resources"") {
 
+    val resourcesRootFile: File = File(resourcesRoot)","You can avoid specifying type for this property: it can be inferred automatically from the initializer. Also it is better to add a private modifier for properties that are used only in this class
",Why do we need this?
985,"@@ -91,3 +205,18 @@ public fun File.listFiles(filter: (file: File) -> Boolean): Array<File>? = listF
             override fun accept(file: File) = filter(file)
         }
                                                                                     )
+
+/**
+ * Returns true if the file is a directory and contains a child file with a given name. Otherwise false is returned.
+ */
+public fun File.contains(name: String): Boolean {","Name of the function is not very good. First, it can be perceived if ""path"" contains ""name"", not contents of the folder. Second, it will fit ""in"" by convention, and while `if (""build.gradle"" in folder)` looks nice, for the overload with predicate it is a little bit strange. Consider using a different name.
",I think this should be `Fil
986,"@@ -92,6 +95,14 @@ fun KtLambdaArgument.moveInsideParenthesesAndReplaceWith(
     return oldCallExpression.replace(newCallExpression) as KtCallExpression
 }
 
+private fun shouldLambdaParameterNamed(args: List<ValueArgument>, callExpr: KtCallExpression): Boolean {
+    return args.any { it.isNamed() } ||","Now that it's a separate function, there's no need to cramp it all into a single expression.

```
if (args.any { it.isNamed () }) return true
val callee = ...resolve as? KtFunction ?: return true
return callee.valueParameters.any { ... }
```

Also the grammatically correct name would be `shouldLambdaParameterBeNamed`.",nit: `return args.any(it =>
987,"@@ -95,6 +95,48 @@ class CollectionTest {
         }
     }
 
+    @test fun filterIsInstanceList() {
+        val values: List<Any> = listOf(1, 2, 3.0, ""abc"", ""cde"")
+
+        val numberValues: List<Number> = values.filterIsInstance<Number>()
+        assertEquals(listOf(1, 2, 3.0), numberValues)
+
+        // doesn't distinguish double from int in JS
+//        val doubleValues: List<Double> = values.filterIsInstance<Double>()
+//        assertEquals(listOf(3.0), doubleValues)
+
+        val stringValues: List<String> = values.filterIsInstance<String>()
+        assertEquals(listOf(""abc"", ""cde""), stringValues)
+
+        // is Any doesn't work in JS
+//        val anyValues: List<Any> = values.filterIsInstance<Any>()","ok, could be mentioned
",Can we remove these?
988,"@@ -96,6 +97,9 @@ class RecursivePropertyAccessorInspection : AbstractKotlinInspection() {
             val bindingContext = element.analyze()
             val target = bindingContext[REFERENCE_TARGET, element]",y :-*,val bindingContext = elemen
989,"@@ -96,6 +97,9 @@ class RecursivePropertyAccessorInspection : AbstractKotlinInspection() {
             val bindingContext = element.analyze()
             val target = bindingContext[REFERENCE_TARGET, element]
             if (target != bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, propertyAccessor.property]) return false
+            (element.parent as? KtDotQualifiedExpression)?.let {
+                if (it.receiverExpression.text != KtTokens.THIS_KEYWORD.value && !it.isCompanionObjectReceiver(bindingContext)) return false
+            }
             return isSameAccessor(element, propertyAccessor.isGetter)",sufjfubi,Why do we need this?
990,"@@ -96,7 +96,10 @@ public boolean accept(File pathname) {
             List<File> subdirs = Arrays.asList(files);
             Collections.sort(subdirs);
             for (File subdir : subdirs) {
-                suite.addTest(suiteForDirectory(baseDataDir, dataPath + ""/"" + subdir.getName(), recursive, filter, factory));","This change must sit in a separate commit, as it has no relation to the problem being solved by this one
",Why was this removed?
991,"@@ -97,12 +97,28 @@ class KotlinFoldingBuilder : CustomFoldingBuilder(), DumbAware {
     }
 
     override fun getLanguagePlaceholderText(node: ASTNode, range: TextRange): String = when {
-        node.elementType == KtTokens.BLOCK_COMMENT -> ""/.../""
-        node.elementType == KDocTokens.KDOC -> ""/**...*/""
+        node.elementType == KtTokens.BLOCK_COMMENT -> ""/${getFirstLineOfComment(node)}.../""
+        node.elementType == KDocTokens.KDOC -> ""/**${getFirstLineOfComment(node)}...*/""
         node.psi is KtImportList -> ""...""
         else ->  ""{...}""
     }
 
+    private fun getFirstLineOfComment(node: ASTNode): String {
+        val targetCommentLine = node.text.split(""\n"").firstOrNull {
+            getCommentContents(it).isNotEmpty()
+        } ?: return """"
+        return getCommentContents(targetCommentLine)
+    }
+
+    private fun getCommentContents(line: String): String {
+        val comment = KotlinCommenter()","There is no need to create a new object here; it's OK to hard-code the token texts.
",`getFirstLineOfComment` -> 
992,"@@ -97,12 +97,28 @@ class KotlinFoldingBuilder : CustomFoldingBuilder(), DumbAware {
     }
 
     override fun getLanguagePlaceholderText(node: ASTNode, range: TextRange): String = when {
-        node.elementType == KtTokens.BLOCK_COMMENT -> ""/.../""
-        node.elementType == KDocTokens.KDOC -> ""/**...*/""
+        node.elementType == KtTokens.BLOCK_COMMENT -> ""/${getFirstLineOfComment(node)}.../""
+        node.elementType == KDocTokens.KDOC -> ""/**${getFirstLineOfComment(node)}...*/""
         node.psi is KtImportList -> ""...""
         else ->  ""{...}""
     }
 
+    private fun getFirstLineOfComment(node: ASTNode): String {
+        val targetCommentLine = node.text.split(""\n"").firstOrNull {
+            getCommentContents(it).isNotEmpty()
+        } ?: return """"
+        return getCommentContents(targetCommentLine)
+    }
+
+    private fun getCommentContents(line: String): String {
+        val comment = KotlinCommenter()
+        return line.trim()
+                .replace(comment.documentationCommentPrefix!!, """")
+                .replace(comment.blockCommentPrefix!!, """")
+                .replace(comment.blockCommentSuffix!!, """")
+                .replace(comment.documentationCommentLinePrefix!!, """")","Please make sure that the line has at most one leading and at most one trailing space after you've remove the prefix and suffix
",`getFirstLineOfComment` -> `getFirstLineOfComment`
993,"@@ -97,3 +96,24 @@ inline fun AbstractInsnNode.findPreviousOrNull(predicate: (AbstractInsnNode) ->
 
 fun AbstractInsnNode.hasOpcode(): Boolean =
         getOpcode() >= 0
+
+//   See InstructionAdapter
+//
+//   public void iconst(final int cst) {
+//       if (cst >= -1 && cst <= 5) {
+//           mv.visitInsn(Opcodes.ICONST_0 + cst);
+//       } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {
+//           mv.visitIntInsn(Opcodes.BIPUSH, cst);
+//       } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {
+//           mv.visitIntInsn(Opcodes.SIPUSH, cst);
+//       } else {
+//           mv.visitLdcInsn(new Integer(cst));
+//       }
+//   }
+val AbstractInsnNode.intConstant: Int? get() =
+    when (opcode) {
+        in ICONST_0..ICONST_5 -> opcode - ICONST_0","What about `ICONST_M1`?
",Can we remove this?
994,"@@ -97,3 +96,24 @@ inline fun AbstractInsnNode.findPreviousOrNull(predicate: (AbstractInsnNode) ->
 
 fun AbstractInsnNode.hasOpcode(): Boolean =
         getOpcode() >= 0
+
+//   See InstructionAdapter
+//
+//   public void iconst(final int cst) {
+//       if (cst >= -1 && cst <= 5) {
+//           mv.visitInsn(Opcodes.ICONST_0 + cst);
+//       } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {
+//           mv.visitIntInsn(Opcodes.BIPUSH, cst);
+//       } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {
+//           mv.visitIntInsn(Opcodes.SIPUSH, cst);
+//       } else {
+//           mv.visitLdcInsn(new Integer(cst));
+//       }
+//   }
+val AbstractInsnNode.intConstant: Int? get() =
+    when (opcode) {
+        in ICONST_0..ICONST_5 -> opcode - ICONST_0
+        BIPUSH, SIPUSH -> (this as IntInsnNode).operand
+        LDC -> (this as LdcInsnNode).cst as? Int?","`as? Int` should work I think
",Can we remove this?
995,"@@ -97,7 +98,15 @@ fun KotlinType.isResolvableInScope(scope: LexicalScope?, checkTypeParameters: Bo
 
     val descriptor = constructor.declarationDescriptor
     if (descriptor == null || descriptor.name.isSpecial) return false
-    if (!checkTypeParameters && descriptor is TypeParameterDescriptor) return true
+
+    if (descriptor is TypeParameterDescriptor) {
+        if (checkTypeParameters) {
+            val owner = descriptor.containingDeclaration
+            if (owner is FunctionDescriptor && owner.typeParameters.any { it == descriptor }) return true",any { it == descriptor } is equivalent to just contains(descriptor),Why do we need this?
996,"@@ -97,7 +98,15 @@ fun KotlinType.isResolvableInScope(scope: LexicalScope?, checkTypeParameters: Bo
 
     val descriptor = constructor.declarationDescriptor
     if (descriptor == null || descriptor.name.isSpecial) return false
-    if (!checkTypeParameters && descriptor is TypeParameterDescriptor) return true
+
+    if (descriptor is TypeParameterDescriptor) {
+        if (checkTypeParameters) {
+            val owner = descriptor.containingDeclaration
+            if (owner is FunctionDescriptor && owner.typeParameters.any { it == descriptor }) return true
+        } else {","FYI: in Kotlin project if...else is formatted in a different way:
```
if () {
}
else {
}
```",Why do we need this?
997,"@@ -988,7 +988,7 @@ public inline fun <T> Stream<T>.firstOrNull(predicate: (T) -> Boolean): T? {
 }
 
 /**
- * Returns first element matching the given *predicate*, or *null* if element was not found
+ * Returns first character matching the given [predicate], or *null* if character was not found","May be replace _null_ with `null`?
",* Returns the first element matching the given pre
998,"@@ -99,10 +100,18 @@ class KotlinFoldingBuilder : CustomFoldingBuilder(), DumbAware {
     override fun getLanguagePlaceholderText(node: ASTNode, range: TextRange): String = when {
         node.elementType == KtTokens.BLOCK_COMMENT -> ""/${getFirstLineOfComment(node)}.../""
         node.elementType == KDocTokens.KDOC -> ""/**${getFirstLineOfComment(node)}...*/""
+        node.elementType == KtNodeTypes.STRING_TEMPLATE -> ""\""\""\""${getFirstLineOfString(node)}...\""\""\""""
         node.psi is KtImportList -> ""...""
         else ->  ""{...}""
     }
 
+    private fun getFirstLineOfString(node: ASTNode): String {
+        val targetStringLine = node.text.split(""\n"").firstOrNull {","You can avoid multiple `replace` calls if you use `asSequence().map { it.replace(...) }.firstOrNull { it.isNotBlank }`
",`getFirstLineOfString` should be renamed to `getFi
999,"@@ -99,10 +100,18 @@ class KotlinFoldingBuilder : CustomFoldingBuilder(), DumbAware {
     override fun getLanguagePlaceholderText(node: ASTNode, range: TextRange): String = when {
         node.elementType == KtTokens.BLOCK_COMMENT -> ""/${getFirstLineOfComment(node)}.../""
         node.elementType == KDocTokens.KDOC -> ""/**${getFirstLineOfComment(node)}...*/""
+        node.elementType == KtNodeTypes.STRING_TEMPLATE -> ""\""\""\""${getFirstLineOfString(node)}...\""\""\""""
         node.psi is KtImportList -> ""...""
         else ->  ""{...}""
     }
 
+    private fun getFirstLineOfString(node: ASTNode): String {
+        val targetStringLine = node.text.split(""\n"").firstOrNull {
+            it.replace(""\""\""\"""", """").isNotBlank()
+        } ?: return """"
+        return "" ${targetStringLine.replace(""\""\""\"""", """").trim()} ""","It's better to add surrounding spaces in `getLanguagePlaceholderText()`, not in this function. (This applies also to `getFirstLineOfComment()`.)
",`getLanguagePlaceholderText` and `getFirstLineOfSt
